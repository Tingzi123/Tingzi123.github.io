<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-OS用户接口与作业调度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/28/OS用户接口与作业调度/" class="article-date">
  <time datetime="2019-03-28T07:34:47.117Z" itemprop="datePublished">2019-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/28/OS用户接口与作业调度/">操作系统-用户接口与作业调度</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、程 序 的 启 动 和 结 束<br>1.1．程序的启动<br>– 程序开始执行时必须满足两个前提条件：<br>• 程序已装入内存<br>• 程序计数器PC中已置入该程序在内存的入口地址 </p>
<p>1.2 五种启动程序执行的方式<br>1）命令方式<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi1.png?raw=true" alt="Image text"></p>
<p>2）批处理方式<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi2.png?raw=true" alt="Image text"></p>
<p>3）EXEC方式<br>– 在一个程序中运行另一个程序<br>– 返回原来的程序<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi3.png?raw=true" alt="Image text"></p>
<p>4）由硬件装入程序和启动程序执行</p>
<p>5）自启程序<br>• 自己装入自己，并启动自己开始执行的程序<br>• 自启程序由两部分组成：引导程序和程序主体<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi4.png?raw=true" alt="Image text"></p>
<p>2、程序的结束<br>正常结束：程序按自身的逻辑有效地完成预定功能<br>后结束<br>（a）返回父程序并回送结果信息。<br>（b）释放所用资源（空间、设备），记录使用情<br>况，记帐等<br>– 异常结束：发生了某些错误而导致程序在没有完成<br>预定功能时提前结束 </p>
<p>3、用户与操作系统的接口<br>为用户提供两种接口：<br>（1）命令接口<br>用户通过这些命令来组织和控制作业的执行。<br>（2）程序接口<br>编程人员使用他们来请求操作系统服务。</p>
<p>作业控制的主要方式：<br>（1）联机命令接口<br>又称交互式命令接口，由一组键盘操作命令组<br>成。用户通过控制台或者终端键入操作命令，完<br>成对作业的控制。<br>（2）脱机命令接口<br>又称批处理命令接口，由一组作业控制语言组<br>成，由系统负责解释执行。（涉及到作业的相关<br>概念） </p>
<p>3、作 业 的 基 本 概 念<br>（1）作业<br>用户在一次计算过程中，或者一次事务处理过程中，<br>要求计算机系统所做工作的总称<br>（2）作业步<br> 一个作业可划分成若干部分，称为一个作业步<br>（3）典型的作业控制过程：<br> “编译”、“连接装配”、“运行” </p>
<p> 作业组织：<br> 作业由三部分组成，即程序、数据、作业说明书。</p>
<p> 作 业 控 制 块（JCB：Job Control Block）<br>– 作业控制块是作业存在的标志<br>– 保存现有系统对于作业进行管理所需要的全部信息<br>– 位于磁盘区域中 </p>
<p><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi5.png?raw=true" alt="Image text"></p>
<p>作 业 的 状 态 及 转 换：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi6.png?raw=true" alt="Image text"></p>
<p>4、作 业 调 度<br>调度的实质<br>• 资源的分配<br>– 调度算法定义<br>• 根据系统的资源分配策略所规定的资源分配算法</p>
<p>调 度 算 法 的 性 能 准 则：<br>– （平均）周转时间：作业从提交到完成的时间（用户角度）<br>周转时间：Ti=Tc-Ts<br>Tc作业完成时刻；<br>Ts作业进入系统时刻</p>
<p>平均周转时间：（T1+T2+…+Tn)/n</p>
<p>– （平均）带权周转时间：周转时间 / CPU运行时间（用户角度）<br>带权周转时间:<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi7.png?raw=true" alt="Image text"></p>
<p>平均带权周转时间：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi8.png?raw=true" alt="Image text"></p>
<p>– 响应时间：用户输入一个请求（如击键）到系统给出首次响应（如屏幕<br>显示）的时间（处理机的角度）<br>– 公平性：不因作业或进程本身的特性而使上述指标过分恶化（算法本身的角度）<br>– 优先级：可以使关键任务达到更好的指标（算法本身的角度）</p>
<p>5、先来先服务算法FCFS （First Come First Served）<br>– 按作业的先后顺序进行调度<br>– 处理过程<br>1）按照作业提交先后次序，分配CPU执行；<br>2）当前作业占用CPU，直到执行完或阻塞（如申请I/O）让出CPU；<br>3）作业被唤醒后（如I/O完成），不立即恢复执行，等待当前作业<br> 让出CPU后才可以恢复执行。<br>– 最简单的调度算法<br>– 对短作业不利（平均周转时间延长）</p>
<p>举例：假设在单道批处理环境下有四个作业，已知它们进入系统的时间、估计运行时间 ，求：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi9.png?raw=true" alt="Image text"></p>
<p>6、短 作 业 优 先 算 法 SJF （Shortest Job First ）<br>按作业的长短顺序进行调度，短作业优先<br>• 对预计执行时间短的作业优先分配CPU<br>• 通常后来的短作业不抢占正在执行的作业<br>– 对FCFS算法的改进，目标是减少平均周转时间</p>
<p>– 优点：<br>• 相比于FCFS改善平均周转时间和平均带权周转时间；<br>• 缩短作业的等待时间；<br>• 提高系统的吞吐量；<br>– 缺点：<br>• 对长作业非常不利，可能长时间得不到执行；<br>• 难以准确估计作业（进程）的执行时间，从而影响调度性能。<br>• 未能依据作业的紧迫程度来划分执行的优先级；</p>
<p>举例：<br>假设在单道批处理环境下有四个作业，已知它们进入系统的时间、估计运行时间 ，求：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi10.png?raw=true" alt="Image text"></p>
<p>7、最 短 剩 余 时 间 优 先 算 法 SRT （Shortest Remaining Time）<br>– 短作业优先算法的变型，也称作抢占式的短作业优先算法<br>– 允许比当前进程剩余时间更短的进程来抢占<br>– 抢占时机：新作业加入队列时 </p>
<p>8、最 高 响 应 比 优 先 算 法HRRN （Highest Response Ratio Next）<br>– 从就绪队列中选出响应比最高的作业投入执行<br>– 响应比R = (等待时间W +要求执行时间T) / 要求执行时间T<br>– FCFS和SJF的折衷</p>
<p>– 优点：既照顾了短作业，也考虑到先后顺序<br>– 缺点：每次调度时要调用响应比计算，增加了系统开销 </p>
<p>举例：假设在单道批处理环境下有四个作业，已知它们进入系统的时间、估计运行时间 ，求：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi11.png?raw=true" alt="Image text"></p>
<p>9、基 于 优 先 数 调 度 算 法 HPF （ Highest Priority First ）<br>（a）由用户规定优先数（外部优先数）<br> 用户提交作业时，根据急迫程度规定适当的优先数<br> 作业调度程序根据JCB优先数决定进入内存的次序<br>（b）由系统计算优先数（内部优先数） </p>
<p>举例：<br>在两道环境下有四个作业，已知它们进入系统的时间、估计运行时间； 作业调度采用短作业优先调度算法（作业被调度<br>运行后直到结束前不再退出内存）； 进程调度采用最短剩余时间优先调度算法（当新作业投入运行后，可按照作业剩余运行时间长短调整次<br>序，可抢占CPU）； 请给出这四个作业的执行时间序列，并计算出平均周转时间及平均带权周转时间；<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi12.png?raw=true" alt="Image text"></p>
<p>10、系 统 调 用<br>系统调用，是用户在程序中调用操作系统所提供的一些子功能（程序接口）。<br>这个指令还将系统转入管态<br>系统调用是操作系统提供给编程人员的唯一接口 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/28/OS用户接口与作业调度/" data-id="cjuc6lbau0003lss6222andg2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-os的硬件环境" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/28/os的硬件环境/" class="article-date">
  <time datetime="2019-03-28T03:18:16.509Z" itemprop="datePublished">2019-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/28/os的硬件环境/">操作系统的硬件环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、中央处理器（CPU）<br>构成:处理器由运算器、控制器、一系列的寄存器以及<br>高速缓存构成<br>– 运算器：实现指令中的算术和逻辑运算<br>– 控制器：负责控制程序运行的流程<br>– 寄存器：具有最快的访问速度<br>– 高速缓存：处于CPU和物理内存之间，访问速度快<br>于内存，低于寄存器</p>
<p>两类寄存器:<br>（1）用户编程寄存器<br>—数据寄存器<br>—地址寄存器<br>—条件码寄存器 </p>
<p>（2）控制状态寄存器<br>—程序计数器PC<br>—指令寄存器IR<br>—程序状态字PSW<br>—中断现场保护寄存器</p>
<p>处理器的状态:<br>– 管态：操作系统管理程序运行的状态，<br>较高的特权级别，又称为特权态（特态）、<br>系统态<br>– 目态：用户程序运行时的状态，较低的<br>特权级别，又称为普通态（普态）、用户态<br>– 特权指令：只能由操作系统使用的指令</p>
<p>管态和目态的差别:<br>– 处理器处于管态时：<br>• 全部指令（包括特权指令）可以执行<br>• 可使用所有资源<br>• 并具有改变处理器状态的能力<br>– 处理器处于目态时：<br>• 只有非特权指令能执行</p>
<p>CPU 状 态 的 转 换:<br>目态——–管态<br>其转换的唯一途径就是通过中断</p>
<p>管态——–目态<br>可用设置PSW实现</p>
<p>2、程 序 状 态 字 P S W<br>特殊寄存器，用以表明处理器当前的工作状态。</p>
<p>通常包括以下状态码：<br>（1）CPU的工作状态码——指明管态还是目态<br>（2）条件码——反映指令执行后的结果特征<br>（3）中断屏蔽码——指出是否允许中断</p>
<p>3、存储系统<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ophard1.png?raw=true" alt="Image text"></p>
<p>存 储 访 问 局 部 性 原 理:<br>提高存储系统效能关键点：程序存储访问局部性原理,处理器主要和存储器的局部打交道</p>
<p>4、中 断 机 制<br>中断机制是操作系统得以正常工作的最重<br>要的手段：<br>–它使得OS可以捕获普通程序发出的系统功能调用<br>–及时处理设备的中断请求<br>–防止用户程序中破坏性的活动等等</p>
<p>中 断：– CPU对系统发生的某个事件作出的一种反应<br>– CPU暂停正在执行的程序，保留现场后自动转去执行<br>相应事件的处理程序，处理完成后返回断点，继续执行<br>被打断的程序</p>
<p><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ophard2.png?raw=true" alt="Image text"></p>
<p>– 引入中断的目的<br>• 解决主机与外设的并行工作问题<br>• 提高可靠性<br>• 实现实时控制<br>– 特点：<br>• 中断是随机的<br>• 中断是可恢复的<br>• 中断是自动处理的</p>
<p>中 断 的 有 关 概 念：<br>– 中断源：引起中断发生的事件<br>– 中断寄存器：记录中断<br>– 中断字：中断寄存器的内容<br>– 系统堆栈:<br>在内存开辟的一块区域，用于临时保存现场</p>
<p>中断类型:<br>– 强迫性中断<br>• 正在运行的程序所不期望的，由于某种硬件故障<br>或外部请求引起的<br>– 自愿性中断<br>• 用户在程序中有意识安排的中断，是由于用户在<br>编制程序时因为要求操作系统提供服务，有意使用<br>“访管”指令或系统调用，使中断发生</p>
<p>强迫性中断<br>• 输入/输出(I/O)中断：主要来自外部设备通道<br>• 程序性中断：运行程序中本身的中断<br>(如溢出,缺页中断,缺段中断,地址越界)<br>• 时钟中断<br>• 硬件故障</p>
<p>自愿性中断<br>• 执行I/O，创建进程，分配内存<br>• 信号量操作，发送/接收消息<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ophard3.png?raw=true" alt="Image text"></p>
<p>5、缓 冲 技 术<br>缓冲区是硬件设备之间进行数据传输时，<br>用来暂存数据的一个存储区域</p>
<p>–缓冲技术三种用途:<br>• 处理器与主存储器之间<br>• 处理器和其它外部设备之间<br>• 设备与设备之间的通信</p>
<p>–目的：解决部件之间速度不匹配的问题、使得部件并<br>行工作</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/28/os的硬件环境/" data-id="cjuc6lbb30009lss6tr2mgg77" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-操作系统概述" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/27/操作系统概述/" class="article-date">
  <time datetime="2019-03-27T12:35:30.855Z" itemprop="datePublished">2019-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/操作系统概述/">操作系统概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、计算机系统的组成<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/op1.png?raw=true" alt="Image text"></p>
<p>操作系统的地位：<br>紧贴系统硬件之上，所有其他软件之下<br>（是其他软件的共同环境）<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/op2.png?raw=true" alt="Image text"></p>
<p>2、操作系统的作用:<br>(1)OS是计算机硬件、软件资源的管理者<br>管理的对象：CPU、存储器、外部设备、信息（数<br>据和软件）；<br>– 管理的内容：<br>1、资源的当前状态（数量和使用情况）<br>2、资源的分配、回收和访问操作<br>3、相应管理策略（包括用户权限）</p>
<p>(2)OS是用户使用系统硬件、软件的接口。<br>系统命令（命令行、菜单式、命令脚本式）；<br>– 系统调用（形式上类似于过程调用，在应用编程<br>中使用API）；<br>– 图形用户接口GUI</p>
<p>（3）OS是扩展机(extended machine)/虚拟机(virtual machine)。<br>在裸机上添加：设备管理、文件管理、存储管理（包括内存和外存）、处理机管理（针对CPU）；<br>– 另外，为合理组织工作流程：作业管理、进程管理</p>
<p>– 通道：用于控制I/O设备与内存间的数据传输。启动后可<br>独立于CPU运行，实现CPU与I/O的并行。<br>• 通道有专用的I/O处理器，可与CPU并行工作<br>• 可实现 I/O联机处理<br>– 中断是指CPU在收到外部中断信号后，停止原来工作，转<br>去处理该中断事件，完毕后回到原来断点继续工作。<br>• 中断处理过程：中断请求，中断响应，中断点（暂停当前任务并<br>保存现场），中断处理例程，中断返回（恢复中断点的现场并继续原<br>有任务</p>
<p>3、通道和中断技术<br>通道：用于控制I/O设备与内存间的数据传输。启动后可<br>独立于CPU运行，实现CPU与I/O的并行。 </p>
<p>中断是指CPU在收到外部中断信号后，停止原来工作，转<br>去处理该中断事件，完毕后回到原来断点继续工作。<br>• 中断处理过程：中断请求，中断响应，中断点（暂停当前任务并<br>保存现场），中断处理例程，中断返回（恢复中断点的现场并继续原<br>有任务</p>
<p>3.1、手工操作<br>计算机的工作特点<br>• 用户独占全机：不出现资源被其他用户占用，资源利<br>用率低；<br>• CPU等待用户：计算前，手工装入纸带或卡片；计算完<br>成后，手工卸取纸带或卡片；CPU利用率低；</p>
<p>3.2、单道批处理系统<br>联机批处理：输入输出设备和主机直接相连，串行工作<br>脱机批处理：利用卫星机完成输入输出功能。主机与卫星机可<br>并行工作。<br>– 卫星机：完成面向用户的输入输出（纸带或卡<br>片），中间结果暂存在磁带或磁盘上。<br>– 优点：同一批内各作业的自动依次更替，改善了<br>主机CPU和I/O设备的使用效率，提高了吞吐量。<br>– 缺点：磁带或磁盘需要人工装卸，作业需要人工<br>分类，监督程序易遭到用户程序的破坏（由人工干预<br>才可恢复）</p>
<p>3.3 多道批处理系统<br>多道批处理的运行特征<br>• 多道：内存中同时存放几个作业；<br>• 宏观上并行运行：都处于运行状态，但都未运行完；<br>• 微观上串行运行：各作业交替使用CPU；<br>在当前运行的作业需作I/O处理时，CPU转而执行<br>另一个作业。<br>优点：<br>• 资源利用率高：CPU和内存利用率较高；<br>• 作业吞吐量大：单位时间内完成的工作总量大；<br>– 缺点：<br>• 用户交互性差：整个作业完成后或中间出错时，<br>才与用户交互，不利于调试和修改；<br>• 作业平均周转时间长：短作业的周转时间显著<br>增长；</p>
<p>3.4 分 时 系 统<br>许多个联机用户同时使用一台计算机系统进行计算的操作<br>系统称分时操作系统<br>系统把中央处理器的时间划分成时间片 ，按时间片轮流<br>把处理机分配给联机作业<br>– “分时”的含义分时是指多个用户分享使用同一台计算机。<br>多个程序分时共享硬件和软件资源<br>– 人机交互性好：在调试和运行程序时由用户自己<br>操作。<br>– 共享主机：多个用户同时使用。<br>– 用户独立性：对每个用户而言好象独占主机</p>
<p>3.5 实 时 系 统<br>– 要求：响应时间短，在规定的时间之内（s, ms,<br>us）；系统可靠性高</p>
<p>3.6 通用操作系统<br>目前的操作系统，通常具有分时、实时和批处理<br>功能，又称作通用操作系统。</p>
<p>4、操作系统的分类<br>4.1 批处理操作系统<br>批处理系统中作业处理及状态：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/op3.png?raw=true" alt="Image text"></p>
<p>单道和多道批处理的比较<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/op4.png?raw=true" alt="Image text"></p>
<p>– 多道程序系统和多重处理系统(multi-processing<br>system)的区别：<br>• 前者指多个程序同时在内存中交替运行<br>• 后者指多个处理器</p>
<p>多道批处理系统上的技术<br>– 作业调度：作业的现场保存和恢复－－上下文切换<br>– 资源共享：资源的竞争和同步－－互斥(exclusion)<br>和同步(synchronization)机制<br>– 内存使用：提高内存使用效率（为当前由CPU执行<br>的程序提供足够的内存）－－覆盖(overlay)，交换<br>(swap)和虚拟存储(virtual memory)<br>– 内存保护：系统存储区和各应用程序存储区不可冲<br>突－－存储保护</p>
<p>4.2 分时操作系统<br>– 多路性：多个用户同时工作。<br>– 独立性：各用户独立操作，互不干扰。<br>– 交互性：系统能及时对用户的操作进行响应，显<br>著提高调试和修改程序的效率：缩短了周转时间。<br>（对批处理的改进）</p>
<p>4.3 实时操作系统<br>– 实时操作系统主要用于过程控制、事务处理等有<br>实时要求的领域，其主要特征是实时性和可靠性</p>
<p>5、 操作系统的特征<br>5.1 并 发 ( c o n c u r r e n c y )<br>– 多个事件在同一时间段内发生。操作系统是一个并<br>发系统，各进程间的并发，系统与应用间的并发。操作<br>系统要完成这些并发过程的管理。并行(parallel)是指<br>在同一时刻发生。<br>– 在多道程序处理时，宏观上并发，微观上交替执行<br>（在单处理器情况下）。<br>– 程序的静态实体是可执行文件，而动态实体是进程<br>（或称作任务），并发指的是进程。</p>
<p> 5.2 共 享 (sharing)<br> 多个进程共享有限的计算机系统资源。操作系统要<br>对系统资源进行合理分配和使用。资源在一个时间段内<br>交替被多个进程所用。<br>– 互斥共享（如视频设备）：资源分配后到释放前，<br>不能被其他进程所用</p>
<p>5.3 虚 拟 (virtual)<br>– 一个物理实体映射为若干个对应的逻辑实体－－分<br>时或分空间。虚拟是操作系统管理系统资源的重要手段，<br>可提高资源利用率</p>
<p>5.4 异步性 ( asynchronism )<br>– 也称不确定性，指进程的执行顺序和执行时间的不<br>确定性；<br>– 进程的运行速度不可预知：分时系统中，多个进程<br>并发执行，程序是以走走停停的方式运行的。系统中的<br>每个程序何时执行，执行顺序，完成时间都是不确定的。</p>
<p>6、操作系统的功能<br>6.1 处 理 机 管 理<br>– 完成处理机资源的分配调度等功能。处理机调度的<br>单位可为进程或线程。<br>– 进程控制：创建、撤销、状态转换<br>– 进程同步：对并发执行的进程进行协调<br>– 进程通信：负责完成进程间的信息交换<br>– 进程调度：按一定算法进行处理机分配</p>
<p>6.2 存 储 管 理<br>– 内存分配：按一定的策略分配内存并负责回收<br>– 内存保护：保证进程间互不干扰、相互保密<br>– 地址变换：进程逻辑地址到内存物理地址的映射；<br>– 内存扩充：为允许大型作业或多个作业运行，借助<br>虚拟技术获得更大逻辑内存的效果；</p>
<p>6.3 设备管理<br>– 设备分配：为了使设备与主机并行工作，一定的分<br>配原则对设备进行分配，常采用缓冲技术和虚拟技术<br>– 设备传输控制：实现物理的输入/输出操作<br>– 设备独立性：用户向系统申请的设备和实际操作的<br>设备无关</p>
<p>6.4 文 件 管 理<br>– 文件存储空间管理：存储空间的分配和回收。<br>– 目录管理：解决信息检索问题。<br>– 文件操作管理：实现文件的操作，负责完成数据的<br>读写<br>– 文件保护：提供文件保护功能，防止文件遭到破坏</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/27/操作系统概述/" data-id="cjuc6lbcs0010lss6y3s4n8pk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计网-应用层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/27/计网-应用层/" class="article-date">
  <time datetime="2019-03-27T11:43:49.837Z" itemprop="datePublished">2019-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/计网-应用层/">计网-应用层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、 域名系统 DNS (Domain Name System)<br>互联网采用了层次树状结构的命名方法。<br>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。<br>域名的结构由标号序列组成，各标号之间用点隔开： … . 三级域名 . 二级域名 . 顶级域名</p>
<p>(1) 国家顶级域名 nTLD<br>    .cn 表示中国，<br>    .us 表示美国，<br>    .uk 表示英国，等等。</p>
<p>(2) 通用顶级域名 gTLD<br>    最早的顶级域名是：<br>    .com    （公司和企业）<br>    .net    （网络服务机构<br>    .org    （非赢利性组织）<br>    .edu    （美国专用的教育机构）<br>    .gov    （美国专用的政府部门）<br>    .mil    （美国专用的军事部门）<br>    .int    （国际组织）</p>
<p>(3) 基础结构域名 (infrastructure domain)<br>    这种顶级域名只有一个，即 arpa，<br>    用于反向域名解析，因此又称为反向域名。</p>
<p>互联网的域名空间 ：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netapp1.png?raw=true" alt="Image text"></p>
<p>DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netapp2.png?raw=true" alt="Image text"></p>
<p>域名服务器有以下四种类型<br>根域名服务器 :在互联网上共有 13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从 a  一直到 m（前 13 个字母）。<br>根域名服务器共有 13 套装置，不是 13 个机器。到2016年2月，全世界已经在 588 个地点安装了根域名服务器，使世界上大部分 DNS 域名服务器都能就近找到一个根域名服务器。 </p>
<p>顶级域名服务器 :级域名服务器（即 TLD 服务器）负责管理在该顶级域名服务器注册的所有二级域名。<br>权限域名服务器 :负责一个区的域名服务器。</p>
<p>本地域名服务器 :本地域名服务器对域名系统非常重要。<br>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，<br>这种域名服务器有时也称为默认域名服务器。 </p>
<p>2、文件传送协议<br>文件传送协议 FTP (File Transfer Protocol) 是互联网上使用得最广泛的文件传送协议。<br>文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。</p>
<p>FTP 使用的两个 TCP 连接<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netapp3.png?raw=true" alt="Image text"></p>
<p>3、远程终端协议 TELNET<br>TELNET 是一个简单的远程终端协议，也是互联网的正式标准。<br>TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。 </p>
<p>4、万维网 WWW<br>万维网 WWW (World Wide Web)是一个大规模的、联机式的信息储藏所。<br>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。<br>这种访问方式称为“链接”。<br>使用统一资源定位符 URL (Uniform Resource Locator) 来标志万维网上的各种文档。<br>使每一个文档在整个互联网的范围内具有唯一的标识符 URL。<br>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。<br>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 </p>
<p>5、超文本传送协议 HTTP<br>从层次的角度看，HTTP 是面向事务的(transaction-oriented)应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。<br>HTTP 是面向事务的客户服务器协议。<br>HTTP 1.0 协议是无状态的 (stateless)。<br>HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。HTTP/1.1 协议使用持续连接 (persistent connection)。<br>万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。<br>这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。</p>
<p>代理服务器 (proxy server) 又称为万维网高速缓存 (Web cache)，它代表浏览器发出 HTTP 请求。</p>
<p>HTTP 的报文结构 HTTP 有两类报文：<br>请求报文——从客户向服务器发送请求报文。<br>响应报文——从服务器到客户的回答。<br>由于 HTTP 是面向正文的 (text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netapp4.png?raw=true" alt="Image text"></p>
<p>状态码都是三位数字<br>1xx 表示通知信息的，如请求收到了或正在进行处理。<br>2xx 表示成功，如接受或知道了。<br>3xx 表示重定向，表示要完成请求还必须采取进一步的行动。<br>4xx 表示客户的差错，如请求中有错误的语法或不能完成。<br>5xx 表示服务器的差错，如服务器失效无法完成请求。</p>
<p>6、电子邮件<br>发送邮件的协议：SMTP<br>读取邮件的协议：POP3 和 IMAP<br>MIME 在其邮件首部中说明了邮件的数据类型(如文本、声音、图像、视像等)，使用 MIME 可在邮件中同时传送多种类型的数据。 </p>
<p>7、动态主机配置协议 DHCP<br>为了将软件协议做成通用的和便于移植，协议软件的编写者把协议软件参数化。这就使得在很多台计算机上使用同一个经过编译的二进制代码成为可能。<br>需要配置的项目<br>    (1) IP 地址<br>    (2) 子网掩码<br>    (3) 默认路由器的 IP 地址<br>    (4) 域名服务器的 IP 地址<br>这些信息通常存储在一个配置文件中，计算机在引导过程中可以对这个文件进行存取。<br>互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网 (plug-and-play networking) 的机制。<br>这种机制允许一台计算机加入新的网络和获取IP 地址而不用手工参与。<br>DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。<br>租用期的数值应由 DHCP 服务器自己决定</p>
<p>8、简单网络管理协议 SNMP<br>网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能，服务质量等。网络管理常简称为网管。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/27/计网-应用层/" data-id="cjuc6lbb6000qlss6v9wssibg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计网-传输层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/27/计网-传输层/" class="article-date">
  <time datetime="2019-03-27T03:36:45.875Z" itemprop="datePublished">2019-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/计网-传输层/">计网-传输层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、传输层与网络层的主要区别<br>网络层是为主机之间提供逻辑通信，<br>而运输层为应用进程之间提供端到端的逻辑通信。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra1.png?raw=true" alt="Image text"></p>
<p>2、 运输层的两个主要协议<br>(1) 用户数据报协议 UDP (User Datagram Protocol)<br> UDP 传送的数据单位协议是 UDP 报文或用户数据报。<br>UDP：一种无连接协议<br>提供无连接服务。<br>在传送数据之前不需要先建立连接。<br>传送的数据单位协议是 UDP 报文或用户数据报。<br>对方的运输层在收到 UDP 报文后，不需要给出任何确认。<br>虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。</p>
<p>UDP 的主要特点：<br>(1) UDP 是无连接的，发送数据之前不需要建立连接，，因此减少了开销和发送数据之前的时延。<br>(2) UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。<br>(3) UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。<br>(4) UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。<br>(5) UDP 支持一对一、一对多、多对一和多对多的交互通信。<br>(6) UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</p>
<p>UDP 的首部格式<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra3.png?raw=true" alt="Image text"><br>伪首部仅仅是为了计算检验和<br>请注意，虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字。</p>
<p>(2) 传输控制协议 TCP (Transmission Control Protocol)<br>TCP 传送的数据单位协议是 TCP 报文段(segment)。<br>TCP：一种面向连接的协议<br>提供面向连接的服务。<br>传送的数据单位协议是 TCP 报文段 (segment)。<br>TCP 不提供广播或多播服务。<br>由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</p>
<p>TCP 最主要的特点<br>TCP 是面向连接的运输层协议。<br>每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。<br>TCP 提供可靠交付的服务。<br>TCP 提供全双工通信。<br>面向字节流<br>TCP 中的“流”(stream)指的是流入或流出进程的字节序列。<br>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。</p>
<p>TCP 面向流的概念<br>TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。<br>但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。<br> <img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra4.png?raw=true" alt="Image text"><br>注 意<br>TCP 连接是一条虚连接而不是一条真正的物理连接。<br>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。<br>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。<br>TCP 可把太长的数据块划分短一些再传送。<br>TCP 也可等待积累有足够多的字节后再构成报文段发送出去。<br>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字 (socket) 或插口。<br>端口号拼接到 (contatenated with) IP 地址即构成了套接字。 </p>
<ul>
<li>socket = (IP地址 : 端口号)</li>
</ul>
<p>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：</p>
<p>TCP 连接 ::= {socket1, socket2} = {(IP1: port1)，(IP2: port2)}</p>
<p>3、两大类端口<br>(1) 服务器端使用的端口号<br>熟知端口，数值一般为 0~1023。<br>登记端口号，数值为 1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。<br>(2) 客户端使用的端口号<br>又称为短暂端口号，数值为 49152~65535，留给客户进程选择暂时使用。<br>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。<br>常用端口号：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra2.png?raw=true" alt="Image text"></p>
<p>4、可靠传输的工作原理<br>停止等待协议<br>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。<br>全双工通信的双方既是发送方也是接收方。</p>
<p>（1）无差错情况<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra5.png?raw=true" alt="Image text"><br>（2）出现差错<br>在接收方 B 会出现两种情况：<br>B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。<br>M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。<br>在这两种情况下，B 都不会发送任何信息。</p>
<p>解决方法：<br>超时重传<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra6.png?raw=true" alt="Image text"></p>
<p>确认丢失和确认迟到<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra7.png?raw=true" alt="Image text"><br>在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。<br>分组和确认分组都必须进行编号。<br>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 </p>
<p>自动重传请求 ARQ协议<br>通常 A 最终总是可以收到对所有发出的分组的确认。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。<br>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。<br>像上述的这种可靠传输协议常称为自动重传请求 ARQ  (Automatic Repeat reQuest)。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。</p>
<p>连续 ARQ 协议（滑动窗口协议）<br>是 TCP 协议的精髓所在。<br>发送方维持的发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。<br>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra8.png?raw=true" alt="Image text"></p>
<p>累积确认<br>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。<br>优点：容易实现，即使确认丢失也不必重传。<br>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<p>Go-back-N（回退 N）<br>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。<br>这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。<br>可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 </p>
<p>TCP 可靠通信的具体实现<br>TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。<br>TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。<br>TCP 两端的四个窗口经常处于动态变化之中。<br>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。  </p>
<p>TCP 报文段的首部格式<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra9.png?raw=true" alt="Image text"><br>01 源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。<br>02 序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。<br>03 确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。<br>数据偏移（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。<br>04 紧急 URG —— 当 URG  1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。<br>05 确认 ACK —— 只有当 ACK  1 时确认号字段才有效。当 ACK  0 时，确认号无效。<br>06 推送 PSH (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。<br>07 复位 RST (ReSeT) —— 当 RST  1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。<br>08 同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。<br>09 终止 FIN (FINish) —— 用来释放一个连接。FIN  1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。<br>10 窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。<br>检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。<br>11 填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。</p>
<p>5、TCP 可靠传输的实现<br>滑动窗口：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra10.png?raw=true" alt="Image text"><br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra11.png?raw=true" alt="Image text"></p>
<p>发送缓存用来暂时存放：<br>发送应用程序传送给发送方 TCP 准备发送的数据；<br>TCP 已发送出但尚未收到确认的数据。<br>接收缓存用来暂时存放：<br>按序到达的、但尚未被接收应用程序读取的数据；<br>不按序到达的数据。 </p>
<p>超时重传时间的选择<br>TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。<br>超时重传时间 RTO<br>RTO (Retransmission Time-Out) 应略大于上面得出的加权平均往返时间 RTTS。<br>RFC 2988 建议使用下式计算 RTO：<br>RTO = RTTS + 4 * RTTD<br>RTTD 是 RTT 的偏差的加权平均值。</p>
<p>修正的 Karn 算法<br>报文段每重传一次，就把 RTO 增大一些：<br>新的 RTO = a * (旧的 RTO) </p>
<p>系数a的典型值是 2 。<br>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。</p>
<p>6、TCP 的流量控制<br>利用可变窗口进行流量控制<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra12.png?raw=true" alt="Image text"><br>TCP 为每一个连接设有一个持续计时器  (persistence timer) 。<br>只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。<br>若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。<br>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。</p>
<p>7、TCP 的拥塞控制<br>拥塞：在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。</p>
<p>拥塞控制与流量控制的区别<br>拥塞控制就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。<br>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。<br>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p>
<p>流量控制往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端）。<br>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 </p>
<p>TCP 的拥塞控制方法<br>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。<br>TCP发送方维持一个拥塞窗口 CWND (Congestion Window)<br>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<br>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。<br>所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：<br>真正的发送窗口值 = Min(公告窗口值，拥塞窗口值)</p>
<p>TCP拥塞控制算法<br>(1)慢开始 (Slow start)<br>用来确定网络的负载能力。<br>算法的思路：由小到大逐渐增大拥塞窗口数值。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra13.png?raw=true" alt="Image text"><br>慢开始门限 ssthresh（状态变量）：防止拥塞窗口cwnd 增长过大引起网络拥塞。<br>拥塞窗口 cwnd  控制方法：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 最大报文段 SMSS (Sender Maximum Segment Size) 的数值。<br>拥塞窗口cwnd每次的增加量 = min (N, SMSS)</p>
<p>慢开始门限 ssthresh 的用法如下：<br>当 cwnd &lt; ssthresh 时，使用慢开始算法。<br>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>(2)拥塞避免算法<br>让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。<br>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）：<br>ssthresh = max(cwnd/2，2)<br>cwnd = 1<br>执行慢开始算法<br>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 </p>
<p>慢开始和拥塞避免算法的实现举例<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra14.png?raw=true" alt="Image text"></p>
<p>(3)快重传算法<br>采用快重传FR (Fast Retransmission) 算法可以让发送方尽早知道发生了个别报文段的丢失。发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。<br>快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。<br>快重传举例<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra15.png?raw=true" alt="Image text"></p>
<p>（4）快恢复算法<br>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法：<br>01 慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；<br>02 新拥塞窗口 cwnd = 慢开始门限 ssthresh ；<br>03 开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra16.png?raw=true" alt="Image text"></p>
<p>TCP拥塞控制流程图<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra17.png?raw=true" alt="Image text"></p>
<p>发送窗口的上限值<br>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：<br>发送窗口的上限值  Min [rwnd, cwnd]</p>
<p>8、 TCP 的运输连接管理<br>TCP 是面向连接的协议。<br>运输连接有三个阶段：<br>连接建立<br>数据传送<br>连接释放<br>运输连接的管理就是使运输连接的建立和释放都能正常地进行。</p>
<p>（1）TCP 的连接建立：采用三次（三报文）握手<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra18.png?raw=true" alt="Image text"></p>
<p>（2）TCP 的连接释放：四次（四报文）握手。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/nettra19.png?raw=true" alt="Image text"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/27/计网-传输层/" data-id="cjuc6lbd00014lss6se2qbs8x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计网-网络层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/26/计网-网络层/" class="article-date">
  <time datetime="2019-03-26T11:50:34.168Z" itemprop="datePublished">2019-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/26/计网-网络层/">计网-网络层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。<br>与 IP 协议配套使用的还有三个协议：<br>地址解析协议 ARP<br>    (Address Resolution Protocol)<br>网际控制报文协议 ICMP<br>   (Internet Control Message Protocol)<br>网际组管理协议 IGMP<br>   (Internet Group Management Protocol)</p>
<p>网际层的 IP 协议及配套协议:<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet1.png?raw=true" alt="Image text"></p>
<p>2、IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。</p>
<p>3、<br>IP地址结构:<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet2.png?raw=true" alt="Image text"></p>
<p>几类IP地址：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet3.png?raw=true" alt="Image text"></p>
<p>点分十进制表示：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet4.png?raw=true" alt="Image text"></p>
<p>常用的三种类别的 IP 地址<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet5.png?raw=true" alt="Image text"></p>
<p>一般不使用的特殊的 IP 地址<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet6.png?raw=true" alt="Image text"></p>
<p>(1) IP 地址是一种分等级的地址结构。<br>(2) 实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口<br>(3) 用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。<br>(4) 所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。<br>（5）路由器总是具有两个或两个以上的 IP 地址。路由器的每一个接口都有一个不同网络号的 IP 地址。</p>
<p>4、IP 地址与硬件地址<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet7.png?raw=true" alt="Image text"></p>
<p>5、地址解析协议 ARP<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet8.png?raw=true" alt="Image text"><br>ARP 作用：<br>从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。</p>
<p>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</p>
<p>每一个主机都设有一个 ARP 高速缓存 (ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p>
<p>ARP工作过程：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet9.png?raw=true" alt="Image text"></p>
<p>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。</p>
<p>5、IP数据报格式：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet10.png?raw=true" alt="Image text"><br>（1）版本——占 4 位，指 IP 协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)。<br>（2）首部长度——占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。<br>（3）总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。<br>（4）标识(identification) ——占 16 位，它是一个计数器，用来产生 IP 数据报的标识。<br>（5）标志(flag) ——占 3 位，目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 DF (Don’t Fragment) 。只有当 DF = 0 时才允许分片。<br>（6）片偏移——占13 位，指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。<br>（7）生存时间——占8 位，记为 TTL (Time To Live)，指示数据报在网络中可通过的路由器数的最大值。<br>（8）协议——占8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给那个处理过程<br>（9）首部检验和——占16 位，只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。</p>
<p>6、划分子网<br>划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet11.png?raw=true" alt="Image text"></p>
<p>7、子网掩码<br>使用子网掩码 (subnet mask) 可以找出 IP 地址中的子网部分。<br>IP 地址的各字段和子网掩码<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet12.png?raw=true" alt="Image text"></p>
<p>(IP 地址) AND (子网掩码) =网络地址</p>
<p>8、无分类编址 CIDR<br>CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。<br>IP 地址从三级编址（使用子网掩码）又回到了两级编址。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet13.png?raw=true" alt="Image text"><br>CIDR 使用“斜线记法”(slash notation)，它又称为 CIDR 记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数，128.14.32.0/20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。</p>
<p>9、一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，路由聚合也称为构成超网 (supernetting)。</p>
<p>10、 网际控制报文协议 ICMP<br>ICMP报文格式：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet14.png?raw=true" alt="Image text"><br>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。<br>ICMP 差错报告报文共有 4 种<br>终点不可达<br>时间超过<br>参数问题<br>改变路由（重定向）(Redirect)  </p>
<p>ICMP 询问报文有两种<br>回送请求和回答报文<br>时间戳请求和回答报文</p>
<p>PING 用来测试两个主机之间的连通性。使用了 ICMP 回送请求与回送回答报文。是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。</p>
<p>11、互联网的路由选择协议<br>（1）内部网关协议 IGP (Interior Gateway Protocol)<br>在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。<br>（1.1）RIP 是一种分布式的、基于距离向量的路由选择协议。能使用的最大距离为 15（16 表示不可达）。</p>
<p>RIP协议更新路由器条件：<br>01 加入新网络<br>02 相邻路由器的路由改变了<br>03 有更短的最短路径</p>
<p>已知路由器 R6 有表 4-9(a) 所示的路由表。现在收到相邻路由器 R4 发来的路由更新信息，如表 4-9(b) 所示。试更新路由器 R6 的路由表。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet15.png?raw=true" alt="Image text"></p>
<p>（2）外部网关协议 EGP (External Gateway Protocol)<br>若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。</p>
<p>12、路由器的构成<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet16.png?raw=true" alt="Image text"></p>
<p>13、虚拟专用网 VPN和网络地址转换 NAT<br>（1）虚拟专用网 VPN：利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网VPN (Virtual Private Network)。</p>
<p>（2）网络地址转换 NAT<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netnet17.png?raw=true" alt="Image text"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/26/计网-网络层/" data-id="cjuc6lbbp000ulss6uvegpbyc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计网-链路层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/26/计网-链路层/" class="article-date">
  <time datetime="2019-03-26T08:15:48.246Z" itemprop="datePublished">2019-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/26/计网-链路层/">计网-数据链路层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、链路 (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。<br>2、数据链路 (data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
<p>3、数据链路层的三个基本问题：<br>封装成帧<br>透明传输<br>差错控制</p>
<p>4、封装成帧 (framing) ：就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。<br>首部和尾部的一个重要作用就是进行帧定界。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netlink1.png?raw=true" alt="Image text"><br>用控制字符进行帧定界：控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT (End Of Transmission) 表示帧的结束。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netlink2.png?raw=true" alt="Image text"></p>
<p>5、透明传输：如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netlink3.png?raw=true" alt="Image text"><br>解决方法：字节填充 (byte stuffing) 或字符填充 (character stuffing)。<br>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC” (其十六进制编码是 1B)。<br>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。<br>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netlink4.png?raw=true" alt="Image text"></p>
<p>6、差错检测：在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。<br>在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。<br>仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受 (accept)。<br>“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。<br>也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）</p>
<p>7、计算机通过适配器和局域网进行通信：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netlink5.png?raw=true" alt="Image text"></p>
<p>8、CSMA/CD协议 ：<br>CSMA/CD 含义：载波监听多点接入 / 碰撞检测  (Carrier Sense Multiple Access with Collision Detection) 。<br>“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。<br>“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。<br>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。</p>
<p>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。</p>
<p>8、以太网的 MAC 层<br>MAC 层的硬件地址：在局域网中，硬件地址又称为物理地址，或 MAC 地址。<br>MAC 帧的格式 ：<img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/netlink6.png?raw=true" alt="Image text"></p>
<p>9、</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/26/计网-链路层/" data-id="cjuc6lbbm000slss6dg9ui0u9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java集合总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/23/Java集合总结/" class="article-date">
  <time datetime="2019-03-23T11:19:34.374Z" itemprop="datePublished">2019-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/23/Java集合总结/">Java集合总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>List<br>ArrayList</p>
<p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。<br>按数组下标访问元素–get(i)/set(i,e) 的性能很高，这是数组的基本优势。<br>直接在数组末尾加入元素–add(e)的性能也高，但如果按下标插入、删除元素–add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p>
<p>LinkedList</p>
<p>以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。<br>按下标访问元素–get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。<br>插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作–add(), addFirst(),removeLast()或用iterator()上的remove()能省掉指针的移动。</p>
<p>CopyOnWriteArrayList</p>
<p>并发优化的ArrayList。用CopyOnWrite策略，在修改时先复制一个快照来修改，改完再让内部指针指向新数组。<br>因为对快照的修改对读操作来说不可见，所以只有写锁没有读锁，加上复制的昂贵成本，典型的适合读多写少的场景。如果更新频率较高，或数组较大时，还是Collections.synchronizedList(list)，对所有操作用同一把锁来保证线程安全更好。<br>增加了addIfAbsent(e)方法，会遍历数组来检查元素是否已存在，性能可想像的不会太好。</p>
<p>补充</p>
<p>无论哪种实现，按值返回下标–contains(e), indexOf(e), remove(e) 都需遍历所有元素进行比较，性能可想像的不会太好。<br>没有按元素值排序的SortedList，在线程安全类中也没有无锁算法的ConcurrentLinkedList，凑合着用Set与Queue中的等价类时，会缺少一些List特有的方法。<br>Map<br>HashMap</p>
<p>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。</p>
<p>插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。</p>
<p>查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。</p>
<p>当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。</p>
<p>取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。</p>
<p>iterator()时顺着哈希桶数组来遍历，看起来是个乱序。</p>
<p>在JDK8里，新增默认为8的閥值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找速度。</p>
<p>LinkedHashMap</p>
<p>扩展HashMap增加双向链表的实现，号称是最占内存的数据结构。支持iterator()时按Entry的插入顺序来排序(但是更新不算， 如果设置accessOrder属性为true，则所有读写访问都算)。</p>
<p>实现上是在Entry上再增加属性before/after指针，插入时把自己加到Header Entry的前面去。如果所有读写访问都要排序，还要把前后Entry的before/after拼接起来以在链表中删除掉自己。</p>
<p>TreeMap</p>
<p>以红黑树实现，篇幅所限详见入门教程。支持iterator()时按Key值排序，可按实现了Comparable接口的Key的升序排序，或由传入的Comparator控制。可想象的，在树上插入/删除元素的代价一定比HashMap的大。</p>
<p>支持SortedMap接口，如firstKey()，lastKey()取得最大最小的key，或sub(fromKey, toKey), tailMap(fromKey)剪取Map的某一段。</p>
<p>ConcurrentHashMap</p>
<p>并发优化的HashMap，默认16把写锁(可以设置更多)，有效分散了阻塞的概率，而且没有读锁。</p>
<p>数据结构为Segment[]，Segment里面才是哈希桶数组，每个Segment一把锁。Key先算出它在哪个Segment里，再算出它在哪个哈希桶里。</p>
<p>支持ConcurrentMap接口，如putIfAbsent(key，value)与相反的replace(key，value)与以及实现CAS的replace(key, oldValue, newValue)。</p>
<p>没有读锁是因为put/remove动作是个原子动作(比如put是一个对数组元素/Entry 指针的赋值操作)，读操作不会看到一个更新动作的中间状态。</p>
<p>ConcurrentSkipListMap</p>
<p>JDK6新增的并发优化的SortedMap，以SkipList实现。SkipList是红黑树的一种简化替代方案，是个流行的有序集合算法，篇幅所限见入门教程。Concurrent包选用它是因为它支持基于CAS的无锁算法，而红黑树则没有好的无锁算法。<br>很特殊的，它的size()不能随便调，会遍历来统计。</p>
<p>补充</p>
<p>关于null，HashMap和LinkedHashMap是随意的，TreeMap没有设置Comparator时key不能为null；ConcurrentHashMap在JDK7里value不能为null(这是为什么呢？)，JDK8里key与value都不能为null；ConcurrentSkipListMap是所有JDK里key与value都不能为null。<br>Set<br>Set几乎都是内部用一个Map来实现, 因为Map里的KeySet就是一个Set，而value是假值，全部使用同一个Object。Set的特征也继承了那些内部Map实现的特征。<br>HashSet：内部是HashMap。<br>LinkedHashSet：内部是LinkedHashMap。<br>TreeSet：内部是TreeMap的SortedSet。<br>ConcurrentSkipListSet：内部是ConcurrentSkipListMap的并发优化的SortedSet。<br>CopyOnWriteArraySet：内部是CopyOnWriteArrayList的并发优化的Set，利用其addIfAbsent()方法实现元素去重，如前所述该方法的性能很一般。</p>
<p>补充：好像少了个ConcurrentHashSet，本来也该有一个内部用ConcurrentHashMap的简单实现，但JDK偏偏没提供。Jetty就自己封了一个，Guava则直接用java.util.Collections.newSetFromMap(new ConcurrentHashMap()) 实现。<br>Queue<br>Queue是在两端出入的List，所以也可以用数组或链表来实现。</p>
<p>–普通队列–</p>
<p>LinkedList</p>
<p>是的，以双向链表实现的LinkedList既是List，也是Queue。它是唯一一个允许放入null的Queue。</p>
<p>ArrayDeque</p>
<p>以循环数组实现的双向Queue。大小是2的倍数，默认是16。</p>
<p>普通数组只能快速在末尾添加元素，为了支持FIFO，从数组头快速取出元素，就需要使用循环数组：有队头队尾两个下标：弹出元素时，队头下标递增；加入元素时，如果已到数组空间的末尾，则将元素循环赋值到数组<a href="如果此时队头下标大于0，说明队头弹出过元素，有空位">0</a>，同时队尾下标指向0，再插入下一个元素则赋值到数组[1]，队尾下标指向1。如果队尾的下标追上队头，说明数组所有空间已用完，进行双倍的数组扩容。</p>
<p>PriorityQueue</p>
<p>用二叉堆实现的优先级队列，详见入门教程，不再是FIFO而是按元素实现的Comparable接口或传入Comparator的比较结果来出队，数值越小，优先级越高，越先出队。但是注意其iterator()的返回不会排序。</p>
<p>–线程安全的队列–</p>
<p>ConcurrentLinkedQueue/ConcurrentLinkedDeque</p>
<p>无界的并发优化的Queue，基于链表，实现了依赖于CAS的无锁算法。</p>
<p>ConcurrentLinkedQueue的结构是单向链表和head/tail两个指针，因为入队时需要修改队尾元素的next指针，以及修改tail指向新入队的元素两个CAS动作无法原子，所以需要的特殊的算法，篇幅所限见入门教程。</p>
<p>PriorityBlockingQueue</p>
<p>无界的并发优化的PriorityQueue，也是基于二叉堆。使用一把公共的读写锁。虽然实现了BlockingQueue接口，其实没有任何阻塞队列的特征，空间不够时会自动扩容。</p>
<p>DelayQueue</p>
<p>内部包含一个PriorityQueue，同样是无界的。元素需实现Delayed接口，每次调用时需返回当前离触发时间还有多久，小于0表示该触发了。</p>
<p>pull()时会用peek()查看队头的元素，检查是否到达触发时间。ScheduledThreadPoolExecutor用了类似的结构。</p>
<p>–线程安全的阻塞队列–</p>
<p>BlockingQueue的队列长度受限，用以保证生产者与消费者的速度不会相差太远，避免内存耗尽。队列长度设定后不可改变。当入队时队列已满，或出队时队列已空，不同函数的效果见下表：</p>
<p>ArrayBlockingQueue</p>
<p>定长的并发优化的BlockingQueue，基于循环数组实现。有一把公共的读写锁与notFull、notEmpty两个Condition管理队列满或空时的阻塞状态。</p>
<p>LinkedBlockingQueue/LinkedBlockingDeque</p>
<p>可选定长的并发优化的BlockingQueue，基于链表实现，所以可以把长度设为Integer.MAX_VALUE。利用链表的特征，分离了takeLock与putLock两把锁，继续用notEmpty、notFull管理队列满或空时的阻塞状态。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/23/Java集合总结/" data-id="cjuc6lbcr000ylss6xrew1b5m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/19/Linux-小结/" class="article-date">
  <time datetime="2019-03-19T08:03:18.421Z" itemprop="datePublished">2019-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/19/Linux-小结/">Linux小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、Linux严格区分大小写<br>2、Linux中所有内容以文件的形式保存，包括硬件、用户</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/19/Linux-小结/" data-id="cjuc6lbar0001lss6x4czjuvr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法-递归" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/18/算法-递归/" class="article-date">
  <time datetime="2019-03-18T07:47:30.884Z" itemprop="datePublished">2019-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/18/算法-递归/">算法-递归</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>递归重点：<br><em><br>    1、寻找相似性（可能需要主动构造）<br>    2、参数设置（参数分配不相同，否则死循环）<br>    3、出口设置<br>    （每次调用的层次不同，注意返回的次序）
</em></p>
<p>例子：取球问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetBall</span> </span>&#123;</span><br><span class="line"><span class="comment">//在n个球中，任意取m个（不放回），求有多少种取法</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">int</span> k=getBall(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">		System.out.println(k);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBall</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//假设有一个球被标记，则规模变成</span></span><br><span class="line">		<span class="comment">//1、被标记的球已取到，则还剩n-1,还需取 m-1,即f(n-1,m-1) </span></span><br><span class="line">		<span class="comment">//2、被标记球一定不取，则需从剩下的 n-1 中取 m,即f(n-1,m)</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(n==m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> getBall(n-<span class="number">1</span>,m-<span class="number">1</span>)+getBall(n-<span class="number">1</span>,m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/18/算法-递归/" data-id="cjuc6lbb6000nlss69kysnhgg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/10/设计模式-备忘录模式/">设计模式-备忘录模式</a>
          </li>
        
          <li>
            <a href="/2019/04/05/设计模式-策略模式/">设计模式-策略模式</a>
          </li>
        
          <li>
            <a href="/2019/04/05/设计模式-RMI/">设计模式总结</a>
          </li>
        
          <li>
            <a href="/2019/04/01/Java-对象导论/">Thinking in Java - 对象导论</a>
          </li>
        
          <li>
            <a href="/2019/03/30/数据库总结/">数据库总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>