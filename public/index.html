<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-GO：2-1-数组和切片" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/16/GO：2-1-数组和切片/" class="article-date">
  <time datetime="2020-07-16T11:06:12.000Z" itemprop="datePublished">2020-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/16/GO：2-1-数组和切片/">GO：2.1 数组和切片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、数组（array）类型和切片（slice）类型的异同"><a href="#1、数组（array）类型和切片（slice）类型的异同" class="headerlink" title="1、数组（array）类型和切片（slice）类型的异同"></a>1、数组（array）类型和切片（slice）类型的异同</h3><h4 id="1、相同"><a href="#1、相同" class="headerlink" title="1、相同"></a>1、相同</h4><p>数组（array）类型和切片（slice）类型的共同点是都属于集合类的类型，并且，它们的值也都可以用来存储某一种类型的值（或者说元素）。</p>
<h4 id="2、区别"><a href="#2、区别" class="headerlink" title="2、区别"></a>2、区别</h4><p>它们最重要的不同是：<strong>数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。</strong></p>
<p>数组的长度在声明它的时候就必须给定，并且之后不会再改变。可以说，<strong>数组的长度是其类型的一部分</strong>。比如，<strong>[1]string和[2]string就是两个不同的数组类型</strong>。</p>
<p>而<strong>切片的类型字面量中只有元素的类型，而没有长度</strong>。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小。<br><img src="/2020/07/16/GO：2-1-数组和切片/arrslice1.png" alt="arrslice1"></p>
<p>我们其实可以<strong>把切片看做是对数组的一层简单的封装</strong>，因为在每个切片的底层数据结构中，一定会包含一个数组。<strong>数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。</strong></p>
<ul>
<li><p>也正因为如此，Go 语言的<strong>切片类型属于引用类型</strong>，同属<strong>引用类型的还有字典类型、通道类型、函数类型等</strong>；而 Go 语言的<strong>数组类型则属于值类型</strong>，同属<strong>值类型的有基础数据类型以及结构体类型</strong>。注意，Go 语言里不存在像 Java 等编程语言中令人困惑的“传值或传引用”问题。在 Go 语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。我们在数组和切片之上都可以应用索引表达式，得到的都会是某个元素。我们在它们之上也都可以应用切片表达式，也都会得到一个新的切片</p>
</li>
<li><p>通过调用内建函数len，得到数组和切片的长度。通过调用内建函数cap，我们可以得到它们的容量。但要注意，<strong>数组的容量永远等于其长度，都是不可变的</strong>。切片的容量却不是这样，并且它的变化是有规律可寻的。</p>
</li>
</ul>
<h3 id="2、怎样正确估算切片的长度和容量？"><a href="#2、怎样正确估算切片的长度和容量？" class="headerlink" title="2、怎样正确估算切片的长度和容量？"></a>2、怎样正确估算切片的长度和容量？</h3><p>1、如下例子demo15.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 示例1。</span></span><br><span class="line">  s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="comment">//用内建函数make声明了一个[]int类型的变量s1，传给make函数的第二个参数是5，从而指明了该切片的长度</span></span><br><span class="line">  </span><br><span class="line">  fmt.Printf(<span class="string">"The length of s1: %d\n"</span>, <span class="built_in">len</span>(s1))</span><br><span class="line">  fmt.Printf(<span class="string">"The capacity of s1: %d\n"</span>, <span class="built_in">cap</span>(s1))</span><br><span class="line">  fmt.Printf(<span class="string">"The value of s1: %d\n"</span>, s1)</span><br><span class="line">  </span><br><span class="line">  s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br><span class="line">  <span class="comment">//同样的方式声明了切片s2，多传入了一个参数8以指明该切片的容量。</span></span><br><span class="line">  </span><br><span class="line">  fmt.Printf(<span class="string">"The length of s2: %d\n"</span>, <span class="built_in">len</span>(s2))</span><br><span class="line">  fmt.Printf(<span class="string">"The capacity of s2: %d\n"</span>, <span class="built_in">cap</span>(s2))</span><br><span class="line">  fmt.Printf(<span class="string">"The value of s2: %d\n"</span>, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>切片s1和s2的容量都是多少？<br>切片s1的容量是5，s2的容量是8</li>
</ul>
<p>2、通过切片表达式基于某个数组或切片生成新切片的时候，情况就变得复杂起来了。<br>如下例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="comment">//s3中有 8 个元素，分别是从1到8的整数，s3的长度和容量都是8。</span></span><br><span class="line"></span><br><span class="line">s4 := s3[<span class="number">3</span>:<span class="number">6</span>]</span><br><span class="line"><span class="comment">//用切片表达式s3[3:6]初始化了切片s4</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"The length of s4: %d\n"</span>, <span class="built_in">len</span>(s4))</span><br><span class="line">fmt.Printf(<span class="string">"The capacity of s4: %d\n"</span>, <span class="built_in">cap</span>(s4))</span><br><span class="line">fmt.Printf(<span class="string">"The value of s4: %d\n"</span>, s4)</span><br></pre></td></tr></table></figure></p>
<p>运行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The length of s4: <span class="number">3</span></span><br><span class="line">The capacity of s4: <span class="number">5</span></span><br><span class="line">The value of s4: [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1、s4的长度是多少？<br>长度是3</li>
</ul>
<p>切片表达式中s3[3:6]取数范围为[3,6)，即从索引3开始取，取到索引6但不包含索引6。</p>
<p>这里的3可被称为起始索引，6可被称为结束索引。那么s4的长度就是6减去3，即3。</p>
<p>可以说，s4中的索引从0到2指向的元素对应的是s3及其底层数组中索引从3到5的那 3 个元素。<br><img src="/2020/07/16/GO：2-1-数组和切片/arrslice2.png" alt="arrslice2"></p>
<ul>
<li><p>2、再来看s4的容量是多少?<br>容量是5</p>
<p><strong>切片的容量代表了它的底层数组的长度，但这仅限于使用make函数或者切片值字面量初始化切片的情况。</strong></p>
</li>
</ul>
<p>更通用的规则是：<strong>一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。</strong></p>
<p>由于s4是通过在s3上施加切片操作得来的，所以s3的底层数组就是s4的底层数组。</p>
<p>又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾。</p>
<p>所以，s4的容量就是其底层数组的长度8, 减去上述切片表达式中的那个起始索引3，即5。</p>
<p>注意，切片代表的窗口是无法向左扩展的。也就是说，我们永远无法透过s4看到s3中最左边的那 3 个元素。</p>
<ul>
<li>把切片的窗口向右扩展到最大的方法。<br>对于s4来说，切片表达式s4[0:cap(s4)]就可以做到。我想你应该能看懂。该表达式的结果值（即一个新的切片）会是[]int{4, 5, 6, 7, 8}，其长度和容量都是5。 </li>
</ul>
<h3 id="3、怎样估算切片容量的增长？"><a href="#3、怎样估算切片容量的增长？" class="headerlink" title="3、怎样估算切片容量的增长？"></a>3、怎样估算切片容量的增长？</h3><p>一旦一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。<strong>在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。</strong></p>
<p>但是，当<strong>原切片的长度（以下简称原长度）大于或等于1024时</strong>，Go 语言将会<strong>以原容量的1.25倍作为新容量的基准（以下新容量基准）</strong>。<strong>新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）</strong>。最终，新容量往往会比新长度大一些，当然，相等也是可能的。</p>
<p>另外，如果我们一次追加的元素过多，以至于<strong>使新长度比原容量的 2 倍还要大</strong>，那么<strong>新容量就会以新长度为基准</strong>。注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些。</p>
<h3 id="4、切片的底层数组什么时候会被替换？"><a href="#4、切片的底层数组什么时候会被替换？" class="headerlink" title="4、切片的底层数组什么时候会被替换？"></a>4、切片的底层数组什么时候会被替换？</h3><p>确切地说，一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。</p>
<p>它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。</p>
<p>在无需扩容时，append函数返回的是指向原底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。所以，严格来讲，“扩容”这个词用在这里虽然形象但并不合适。</p>
<p>只要新长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/16/GO：2-1-数组和切片/" data-id="ckcpzrdo70004sovi5igia74d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：1-4-程序实体" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/13/GO：1-4-程序实体/" class="article-date">
  <time datetime="2020-07-13T02:42:07.000Z" itemprop="datePublished">2020-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/13/GO：1-4-程序实体/">GO：1.4 程序实体</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Go 语言中的<strong>程序实体包括变量、常量、函数、结构体和接口</strong>。 Go 语言是<strong>静态类型</strong>的编程语言，所以我们在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让 Go 语言能够推导出它们的类型。</p>
<h3 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h3><p>在 Go 语言中，<strong>变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数、结构体或接口</strong>。常量的合法类型不多，只能是那些 Go 语言预定义的基本类型。它的声明方式也更简单一些。</p>
<hr>
<h4 id="1、声明变量有几种方式？"><a href="#1、声明变量有几种方式？" class="headerlink" title="1、声明变量有几种方式？"></a>1、声明变量有几种方式？</h4><p>1、先声明后赋值<br>一个很简单的命令源码文件，命名为 demo7.go。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name <span class="keyword">string</span> <span class="comment">// 先声明</span></span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>) <span class="comment">// 后赋值</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、使用var声明变量的同时赋值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name = flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//声明的同时赋值</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, *name)。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>flag.String函数返回的结果值的类型是<em>string而不是string。类型</em>string代表的是字符串的指针类型，而不是字符串类型。因此，这里的变量name代表的是一个指向字符串值的指针。</p>
<p>注：</p>
<ul>
<li>1、声明变量name的同时，还为它赋了值，而这时声明中并没有显式指定name的类型。之前的变量声明语句是var name string。这里利用了 Go 语言自身的类型推断，而省去了对该变量的类型的声明。</li>
<li>2、类型推断是一种编程语言在编译期自动解释表达式类型的能力。</li>
<li>3、类型推断只能用于对变量或常量的初始化。</li>
</ul>
<p>3、使用”:=”短变量声明的同时赋值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  name := flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//声明的同时赋值</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, *name)。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：</p>
<ul>
<li>1、短变量声明，实际上就是 Go 语言的类型推断再加上一点点语法糖，<strong>只能在函数体内部使用短变量声明</strong></li>
<li>在编写if、for或switch语句的时候，我们经常把它安插在初始化子句中，并用来声明一些临时的变量。而相比之下，第一种方式更加通用，它可以被用在任何地方。<br><img src="/2020/07/13/GO：1-4-程序实体/app1.png" alt="app1"></li>
</ul>
<h4 id="2、Go-语言的类型推断可以带来哪些好处？"><a href="#2、Go-语言的类型推断可以带来哪些好处？" class="headerlink" title="2、Go 语言的类型推断可以带来哪些好处？"></a>2、Go 语言的类型推断可以带来哪些好处？</h4><p>在写代码时，我们通过使用 Go 语言的类型推断，而节省下来的键盘敲击次数几乎可以忽略不计。但它真正的好处，往往会体现在我们写代码之后的那些事情上，比如<strong>代码重构</strong>。</p>
<p>通过调用一个函数在声明name变量的同时为它赋值，这个函数是由我们自己定义的函数getTheFlag。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name = getTheFlag()</span><br><span class="line">  <span class="comment">//不显式地指定变量name的类型，使得它可以被赋予任何类型的值。也就是说，变量name的类型可以在其初始化时，由其他程序动态地确定。</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, *name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTheFlag</span><span class="params">()</span> *<span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以用getTheFlag函数包裹（或者说包装）那个对flag.String函数的调用，并把其结果直接作为getTheFlag函数的结果，结果的类型是*string。</p>
<p>这样一来，var name =右边的表达式，可以变为针对getTheFlag函数的调用表达式了。这实际上是对“声明并赋值name变量的那行代码”的重构。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重构：</span><br><span class="line">我们通常把不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码修改方式，叫做对该程序的重构。重构的对象可以是一行代码、一个函数、一个功能模块，甚至一个软件系统。</span><br></pre></td></tr></table></figure></p>
<p>你会发现，你可以随意改变getTheFlag函数的内部实现，及其返回结果的类型，而不用修改main函数中的任何代码。</p>
<p>注：</p>
<ul>
<li>我们不显式地指定变量name的类型，使得它可以被赋予任何类型的值。也就是说，变量name的类型可以在其初始化时，由其他程序动态地确定。</li>
<li>在你改变getTheFlag函数的结果类型之后，Go 语言的编译器会在你再次构建该程序的时候，自动地更新变量name的类型。</li>
<li>通过这种<strong>类型推断</strong>，你可以体验到动态类型编程语言所带来的一部分优势，即程序灵活性的明显提升。但在那些编程语言中，这种提升可以说是用程序的可维护性和运行效率换来的。</li>
<li>Go 语言是静态类型的，所以一旦在初始化变量时确定了它的类型，之后就不可能再改变。这就避免了在后面维护程序时的一些问题。另外，请记住，这种类型的确定是在<strong>编译期</strong>完成的，因此不会对程序的运行效率产生任何影响。</li>
</ul>
<hr>
<p><em>Go 语言的类型推断可以带来哪些好处？<br>Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。</em></p>
<hr>
<h4 id="2、变量的重声明是什么意思？"><a href="#2、变量的重声明是什么意思？" class="headerlink" title="2、变量的重声明是什么意思？"></a>2、变量的重声明是什么意思？</h4><p>1、变量的重声明：对已经声明过的变量再次声明。</p>
<p>2、这涉及了短变量声明。通过使用它，我们可以对同一个代码块中的变量进行重声明。</p>
<p>3、变量重声明的前提条件如下。</p>
<ul>
<li>1、由于变量的类型在其初始化时就已经确定了，所以对它<strong>再次声明时赋予的类型必须与其原本的类型相同</strong>，否则会产生编译错误。</li>
<li>2、变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了</li>
<li>3、变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。</li>
<li>4、被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。</li>
</ul>
<p>如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">n, err := io.WriteString(os.Stdout, <span class="string">"Hello, everyone!\n"</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用短变量声明，对新变量n和旧变量err进行了“声明并赋值”，这时也是对err的重声明。</p>
<h4 id="3、如果一个变量与其外层代码块中的变量重名会出现什么状况？"><a href="#3、如果一个变量与其外层代码块中的变量重名会出现什么状况？" class="headerlink" title="3、如果一个变量与其外层代码块中的变量重名会出现什么状况？"></a>3、如果一个变量与其外层代码块中的变量重名会出现什么状况？</h4><p>1、作用域：</p>
<ul>
<li>1、程序实体的访问权限有三种：<strong>包级私有的、模块级私有的和公开的</strong>。这其实就是 Go 语言在语言层面，依据代码块对程序实体作用域进行的定义。</li>
<li>2、包级私有和模块级私有访问权限对应的都是代码包代码块，公开的访问权限对应的是全域代码块。</li>
<li>3、<strong>一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制</strong>。对“高内聚，低耦合”这种程序设计思想的实践，就是从这里开始的。</li>
</ul>
<p>2、如果一个变量与其外层代码块中的变量重名会出现什么状况？<br>如下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> block = <span class="string">"package"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  block := <span class="string">"function"</span></span><br><span class="line">  &#123;</span><br><span class="line">    block := <span class="string">"inner"</span></span><br><span class="line">    fmt.Printf(<span class="string">"The block is %s.\n"</span>, block)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">"The block is %s.\n"</span>, block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个命令源码文件中有四个代码块，它们是：</p>
<ul>
<li>全域代码块、</li>
<li>main包代表的代码块、</li>
<li>main函数代表的代码块，</li>
<li>在main函数中的一个用花括号包起来的代码块。</li>
</ul>
<p>在后三个代码块（main包代表的代码块、main函数代表的代码块、在main函数中的一个用花括号包起来的代码块）中分别声明了一个名为block的变量，并分别把字符串值”package”、”function”和”inner”赋给了它们。此外，我在后两个代码块的最后分别尝试用fmt.Printf函数打印出“The block is %s.”。这里的“%s”只是为了占位，程序会用block变量的实际值替换掉。</p>
<p>那么，该源码文件中的代码能通过编译吗？<br>能通过编译。运行后打印出的内容是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The block is inner.</span><br><span class="line">The block is function.</span><br></pre></td></tr></table></figure></p>
<ul>
<li>对于同一个代码块而言，用短变量声明对已有变量进行重声明可以通过编译</li>
<li>对于不同的代码块来说，其中的变量重名没什么大不了，照样可以通过编译。即使这些代码块有直接的嵌套关系也是如此，就像上述代码中的main包代码块、main函数代码块和那个最内层的代码块那样。 </li>
</ul>
<p>3、这其实有一个很有画面感的查找过程。这个查找过程不只针对于变量，还适用于任何程序实体。如下面所示。</p>
<ul>
<li>首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。</li>
<li>其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块（父级代码块）开始，一层一层地查找。</li>
<li>一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了。</li>
<li>如果我们在当前源码文件中导入了其他代码包，那么引用其中的程序实体时，是需要以限定符为前缀的。所以程序在找代表变量未加限定符的名字（即标识符）的时候，是不会去被导入的代码包中查找的。</li>
</ul>
<p>但有个特殊情况，如果我们把代码包导入语句写成import . “XXX”的形式（注意中间的那个“.”），那么就会让这个“XXX”包中公开的程序实体，被当前源码文件中的代码，视为当前代码包中的程序实体。 比如，如果有代码包导入语句import . fmt，那么我们在当前源码文件中引用fmt.Printf函数的时候直接用Printf就可以了。在这个特殊情况下，程序在查找当前源码文件后会先去查用这种方式导入的那些代码包。</p>
<p>4、从作用域的角度也可以说，虽然通过var block = “package”声明的变量作用域是整个main代码包，但是在main函数中，它却被那两个同名的变量<strong>“屏蔽”</strong>了。<br>  相似的，虽然main函数首先声明的block的作用域，是整个main函数，但是在最内层的那个代码块中，它却是不可能被引用到的。反过来讲，最内层代码块中的block也不可能被该块之外的代码引用到，这也是打印内容的第二行是“The block is function.”的另一半原因。</p>
<h4 id="4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？"><a href="#4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？" class="headerlink" title="4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？"></a>4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？</h4><p>1、为了方便描述，我就把不同代码块中的重名变量叫做“可重名变量”吧。注意，在同一个代码块中不允许出现重名的变量，这违背了 Go 语言的语法。</p>
<p>区别：</p>
<ul>
<li>变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。</li>
<li>变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。</li>
<li>不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。</li>
<li>如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。</li>
</ul>
<p><img src="/2020/07/13/GO：1-4-程序实体/app2.png" alt="app2.png"></p>
<p>2、不同类型的可重名变量例子<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The element is <span class="string">"one"</span>.</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，有两个都叫做container的变量，分别位于main包代码块和main函数代码块。</p>
<p>main包代码块中的变量是切片（slice）类型的，另一个是字典（map）类型的。在main函数的最后，试图打印出container变量的值中索引为1的那个元素。</p>
<p>如果container的类型不是数组、切片或字典类型，那么索引表达式就会引发编译错误。</p>
<p>这正是利用 Go 语言语法，帮我们约束程序的一个例子；但是当我们想知道 container 确切类型的时候，利用索引表达式的方式就不够了。</p>
<p><strong>当可重名变量的值被转换成某个接口类型值，或者它们的类型本身就是接口类型的时候，严格的类型检查就很有必要了。</strong></p>
<h4 id="5、怎样判断一个变量的类型？"><a href="#5、怎样判断一个变量的类型？" class="headerlink" title="5、怎样判断一个变量的类型？"></a>5、怎样判断一个变量的类型？</h4><p>看如下例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>怎样在打印其中元素之前，正确判断变量container的类型？<br>使用<strong>“类型断言”</strong>表达式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">interface</span>&#123;&#125;(container).([]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></p>
<p>完整代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	value, ok := <span class="keyword">interface</span>&#123;&#125;(container).([]<span class="keyword">string</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"The value is %v.\n"</span>, value)</span><br><span class="line">	fmt.Printf(<span class="string">"The ok is %v.\n"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The element is <span class="string">"one"</span>.</span><br><span class="line">The value is [].</span><br><span class="line">The ok is <span class="literal">false</span>.</span><br></pre></td></tr></table></figure></p>
<p>1、这里有一条赋值语句。在赋值符号的右边，是一个类型断言表达式。</p>
<p>它包括了用来把container变量的值转换为空接口值的interface{}(container)。以及一个用于判断前者的类型是否为切片类型 []string  的 .([]string)。</p>
<p>这个表达式的结果可以被赋给两个变量，在这里由value和ok代表。变量ok是布尔（bool）类型的，它将代表类型判断的结果，true或false。</p>
<p>如果是true，那么被判断的值将会被自动转换为[]string类型的值，并赋给变量value，否则value将被赋予nil（即“空”）。这里的ok也可以没有。也就是说，类型断言表达式的结果，可以只被赋给一个变量，在这里是value。但是这样的话，当判断为否时就会引发异常。</p>
<p>这种异常在 Go 语言中被叫做panic，我把它翻译为运行时恐慌。因为它是一种在 Go 程序运行期间才会被抛出的异常，而“恐慌”二字是英文 Panic 的中文直译。除非显式地“恢复”这种“恐慌”，否则它会使 Go 程序崩溃并停止。所以，在一般情况下，我们还是应该使用带ok变量的写法。</p>
<p>如果将类型断言改为：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">interface</span>&#123;&#125;(container).(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></p>
<p>完整代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	value, ok := <span class="keyword">interface</span>&#123;&#125;(container).(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"The value is %v.\n"</span>, value)</span><br><span class="line">	fmt.Printf(<span class="string">"The ok is %v.\n"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The element is <span class="string">"one"</span>.</span><br><span class="line">The value is <span class="keyword">map</span>[<span class="number">0</span>:zero <span class="number">1</span>:one <span class="number">2</span>:two].</span><br><span class="line">The ok is <span class="literal">true</span>.</span><br></pre></td></tr></table></figure></p>
<p>1、类型断言表达式的语法形式是<strong>x.(T)</strong>。其中的x代表要被判断类型的值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的。</p>
<p>2、所以，当这里的container变量类型不是任何的接口类型时，我们就需要先把它转成某个接口类型的值。如果container是某个接口类型的，那么这个类型断言表达式就可以是container.([]string)。</p>
<p>3、在 Go 语言中，interface{}代表空接口，任何类型都是它的实现类型。这里的具体语法是interface{}(x)，例如前面展示的interface{}(container)。</p>
<p>4、你可能会对这里的{}产生疑惑，为什么在关键字interface的右边还要加上这个东西？</p>
<ul>
<li>一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。</li>
<li>比如struct{}，它就代表了不包含任何字段和方法的、空的结构体类型。而空接口interface{}则代表了不包含任何方法定义的、空的接口类型。</li>
<li>当然了，对于一些集合类的数据类型来说，{}还可以用来表示其值不包含任何元素，比如空的切片值[]string{}，以及空的字典值map[int]string{}。<br><img src="/2020/07/13/GO：1-4-程序实体/app3.png" alt="app3.png"></li>
</ul>
<h4 id="6、类型转换规则中有哪些值得注意的地方？"><a href="#6、类型转换规则中有哪些值得注意的地方？" class="headerlink" title="6、类型转换规则中有哪些值得注意的地方？"></a>6、类型转换规则中有哪些值得注意的地方？</h4><p>1、类型转换表达式的语法形式：<strong>T(x)</strong>。</p>
<p>其中的x可以是一个变量，也可以是一个代表值的字面量（比如1.23和struct{}{}），还可以是一个表达式。注意，如果是表达式，那么该表达式的结果只能是一个值，而不能是多个值。</p>
<p>在这个上下文中，x可以被叫做源值，它的类型就是源类型，而那个T代表的类型就是目标类型。如果从源类型到目标类型的转换是不合法的，那么就会引发一个编译错误。</p>
<p>2、三个注意点</p>
<ul>
<li>1、<strong>对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。</strong></li>
</ul>
<p>比如，之所以uint8(255)可以把无类型的常量255转换为uint8类型的值，是因为255在[0, 255]的范围内。</p>
<p>但需要特别注意的是，源整数类型的可表示范围较大，而目标类型的可表示范围较小的情况，比如把值的类型从int16转换为int8。请看下面这段代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> srcInt = <span class="keyword">int16</span>(<span class="number">-255</span>)</span><br><span class="line">dstInt := <span class="keyword">int8</span>(srcInt)<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>变量srcInt的值是int16类型的-255，而变量dstInt的值是由前者转换而来的，类型是int8。int16类型的可表示范围可比int8类型大了不少。</p>
<p>问题是，dstInt的值是多少？<br>首先你要知道，整数在 Go 语言以及计算机中都是以补码的形式存储的。这主要是为了简化计算机对整数的运算过程。补码其实就是原码各位求反再加 1。</p>
<p>比如，int16类型的值-255的补码是1111111100000001。如果我们把该值转换为int8类型的值，那么 Go 语言会把在较高位置（或者说最左边位置）上的 8 位二进制数直接截掉，从而得到00000001。又由于其最左边一位是0，表示它是个正整数，以及正整数的补码就等于其原码，所以<strong>dstInt的值就是1</strong>。</p>
<p>一定要记住，当整数值的类型的有效范围由宽变窄时，只需在补码形式下截掉一定数量的高位二进制数即可。</p>
<p>类似的快刀斩乱麻规则还有：当把一个浮点数类型的值转换为整数类型值时，前者的小数部分会被全部截掉。</p>
<ul>
<li>2、<strong>虽然直接把一个整数值转换为一个string类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的 Unicode 代码点，否则转换的结果将会是”�”（仅由高亮的问号组成的字符串值）。</strong><br>字符’�’的 Unicode 代码点是U+FFFD。它是 Unicode 标准中定义的 Replacement Character，专用于替换那些未知的、不被认可的以及无法展示的字符。<br>如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>(<span class="number">-1</span>)  <span class="comment">//�"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于-1肯定无法代表一个有效的 Unicode 代码点，所以得到的总会是”�”。</p>
<ul>
<li>3、string类型与各种切片类型之间的互转<br><strong>一个值在从string类型向[]byte类型转换时代表着以 UTF-8 编码的字符串会被拆分成零散、独立的字节。</strong></li>
</ul>
<p>除了与 ASCII 编码兼容的那部分字符集，以 UTF-8 编码的某个单一字节是无法代表一个字符的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>([]<span class="keyword">byte</span>&#123;<span class="string">'\xe4'</span>, <span class="string">'\xbd'</span>, <span class="string">'\xa0'</span>, <span class="string">'\xe5'</span>, <span class="string">'\xa5'</span>, <span class="string">'\xbd'</span>&#125;) <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure></p>
<p>比如，UTF-8 编码的三个字节\xe4、\xbd和\xa0合在一起才能代表字符’你’，而\xe5、\xa5和\xbd合在一起才能代表字符’好’。</p>
<p><strong>一个值在从string类型向[]rune类型转换时代表着字符串会被拆分成一个个 Unicode 字符。</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>([]<span class="keyword">rune</span>&#123;<span class="string">'\u4F60'</span>, <span class="string">'\u597D'</span>&#125;) <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure></p>
<h4 id="7、什么是别名类型？什么是潜在类型？"><a href="#7、什么是别名类型？什么是潜在类型？" class="headerlink" title="7、什么是别名类型？什么是潜在类型？"></a>7、什么是别名类型？什么是潜在类型？</h4><p>我们可以用关键字type声明自定义的各种类型。这些类型必须在 Go 语言基本类型和高级类型的范畴之内。在它们当中，有一种被叫做“别名类型”的类型。我们可以像下面这样声明它：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString = <span class="keyword">string</span></span><br></pre></td></tr></table></figure></p>
<p>这条声明语句表示，MyString是string类型的别名类型。顾名思义，别名类型与其源类型的区别只是在名称上，它们是完全相同的。</p>
<p><strong>源类型与别名类型是一对概念</strong>，是两个对立的称呼。别名类型主要是为了代码重构而存在的。</p>
<p>Go 语言内建的基本类型中就存在两个别名类型<strong>。byte是uint8的别名类型，而rune是int32的别名类型。</strong></p>
<p>一定要注意，如果我这样声明：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="keyword">string</span>  <span class="comment">// 注意，这里没有等号。</span></span><br></pre></td></tr></table></figure></p>
<p>MyString2和string就是两个不同的类型了。这里的MyString2是一个新的类型，不同于其他任何类型。</p>
<p>这种方式也可以被叫做对<strong>类型的再定义</strong>。我们刚刚把string类型再定义成了另外一个类型MyString2。<br><img src="/2020/07/13/GO：1-4-程序实体/app4.png" alt="app4.png"></p>
<p>对于这里的类型再定义来说，string可以被称为MyString2的潜在类型。<strong>潜在类型</strong>的含义是，<strong>某个类型在本质上是哪个类型。</strong></p>
<p><strong>潜在类型相同的不同类型的值之间是可以进行类型转换的</strong>。因此，<strong>MyString2类型的值与string类型的值可以使用类型转换表达式进行互转</strong>。</p>
<p><strong>但对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，因为[]MyString2与[]string的潜在类型不同，分别是[]MyString2和[]string。</strong></p>
<p>另外，<strong>即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/13/GO：1-4-程序实体/" data-id="ckcpzrdo10001sovimd6we0ed" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：1-3-库源码文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/12/GO：1-3-库源码文件/" class="article-date">
  <time datetime="2020-07-12T08:01:56.000Z" itemprop="datePublished">2020-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/12/GO：1-3-库源码文件/">GO：1.3 库源码文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、什么是库源码文件？"><a href="#1、什么是库源码文件？" class="headerlink" title="1、什么是库源码文件？"></a>1、什么是库源码文件？</h3><p>1、<strong>库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体</strong>，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）。</p>
<p>2、这里的“其他代码”可以与被使用的程序实体在同一个源码文件内，也可以在其他源码文件，甚至其他代码包中。</p>
<p>3、程序实体是什么？<br>在 Go 语言中，<strong>程序实体是变量、常量、函数、结构体和接口的统称</strong>。</p>
<ul>
<li>我们总是会先声明（或者说定义）程序实体，然后再去使用。</li>
<li>程序实体的名字被统称为标识符。标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。</li>
<li>从规则上说，我们可以用中文作为变量的名字。但是不建议这样做。</li>
</ul>
<h3 id="2、怎样把命令源码文件中的代码拆分到其他库源码文件？"><a href="#2、怎样把命令源码文件中的代码拆分到其他库源码文件？" class="headerlink" title="2、怎样把命令源码文件中的代码拆分到其他库源码文件？"></a>2、怎样把命令源码文件中的代码拆分到其他库源码文件？</h3><p>如果在某个目录下有一个命令源码文件 demo4.go，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  hello(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>demo4.go 在调用了hello函数，函数hello被声明在了另外一个源码文件中，我把它命名为 demo4_lib.go，并且放在与 demo4.go 相同的目录main下（在同一个目录下的源码文件都需要被声明为属于同一个代码包。）。如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：如果该目录下有一个命令源码文件，那么为了让同在一个目录下的文件都通过编译，其他源码文件应该也声明属于main包。</p>
<p>现在运行它们，比如，我们可以在这些文件所在的目录下运行如下命令并得到相应的结果。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run demo4.<span class="keyword">go</span> demo4_lib.<span class="keyword">go</span> </span><br><span class="line">Hello, everyone!</span><br></pre></td></tr></table></figure></p>
<p>或者，像下面这样先构建当前的代码包再运行。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build puzzlers/article3/q1</span><br><span class="line">$ ./q1            </span><br><span class="line">Hello, everyone!</span><br></pre></td></tr></table></figure></p>
<p>1、在这里，我把 demo4.go 和 demo4_lib.go 都放在了一个相对路径为puzzlers/article3/q1的目录中。</p>
<p>2、在默认情况下，相应的代码包的导入路径会与此一致。我们可以通过代码包的导入路径引用其中声明的程序实体。但是，这里的情况是不同的。</p>
<p>3、注意，demo4.go 和 demo4_lib.go 都声明自己属于main包。我在前面讲 Go 语言源码的组织方式的时候提到过这种用法，即：源码文件声明的包名可以与其所在目录的名称不同，只要这些文件声明的包名一致就可以。</p>
<p>4、代码包声明的基本规则：</p>
<ul>
<li>同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。如果目录中有命令源码文件，那么其他种类的源码文件也应该声明属于main包。这也是我们能够成功构建和运行它们的前提。</li>
<li>源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。对于命令源码文件而言，构建生成的可执行文件的主名称会与其父目录的名称相同</li>
</ul>
<p>###3、怎样把命令源码文件中的代码拆分到其他代码包？<br>1、把 demo4.go 另存为 demo5.go，并放到一个相对路径为puzzlers/article3/q2的目录中。</p>
<p>2、然后再创建一个相对路径为puzzlers/article3/q2/lib的目录，再把 demo4_lib.go 复制一份并改名为 demo5_lib.go 放到该目录中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lib5</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里修改了两个地方。</p>
<ul>
<li>第一个改动是，把代码包声明语句由package main改为了package lib5。注意，故意让声明的包名与其所在的目录的名称不同。</li>
<li><p>第二个改动是，把全小写的函数名hello改为首字母大写的Hello。</p>
<p>基于以上改动，我们再来看下面的几个问题。</p>
</li>
</ul>
<h4 id="1、代码包的导入路径总会与其所在目录的相对路径一致吗？"><a href="#1、代码包的导入路径总会与其所在目录的相对路径一致吗？" class="headerlink" title="1、代码包的导入路径总会与其所在目录的相对路径一致吗？"></a>1、代码包的导入路径总会与其所在目录的相对路径一致吗？</h4><p>库源码文件 demo5_lib.go 所在目录的相对路径是puzzlers/article3/q2/lib，而它却声明自己属于lib5包。在这种情况下，该包的导入路径是puzzlers/article3/q2/lib，还是puzzlers/article3/q2/lib5？<br>1、首先，我们在构建或者安装这个代码包的时候，提供给go命令的路径应该是目录的相对路径，就像这样：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> install puzzlers/article3/q2/lib</span><br></pre></td></tr></table></figure></p>
<p>该命令会成功完成。之后，当前工作区的 pkg 子目录下会产生相应的归档文件，具体的相对路径是:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg/darwin_amd64/puzzlers/article3/q2/lib.a</span><br></pre></td></tr></table></figure></p>
<p>其中的darwin_amd64就是我在讲工作区时提到的平台相关目录。可以看到，这里与源码文件所在目录的相对路径是对应的。</p>
<p>2、为了进一步说明问题，需要先对 demo5.go 做两个改动。</p>
<ul>
<li>第一个改动是，在以import为前导的代码包导入语句中加入puzzlers/article3/q2/lib，也就是试图导入这个代码包。</li>
<li>第二个改动是，把对hello函数的调用改为对lib.Hello函数的调用。其中的lib.叫做限定符，旨在指明右边的程序实体所在的代码包。不过这里与代码包导入路径的完整写法不同，只包含了路径中的最后一级lib，这与代码包声明语句中的规则一致。</li>
</ul>
<p>现在，通过运行go run demo5.go命令试一试。错误提示会类似于下面这种。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./demo5.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">2</span>: imported and not used: <span class="string">"puzzlers/article3/q2/lib"</span> as lib5</span><br><span class="line">./demo5.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">2</span>: undefined: lib</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一个错误提示的意思是，我们导入了puzzlers/article3/q2/lib包，但没有实际使用其中的任何程序实体。这在 Go 语言中是不被允许的，在编译时就会导致失败。</li>
<li>这里还有另外一个线索，那就是“as lib5”。这说明虽然导入了代码包puzzlers/article3/q2/lib，但是使用其中的程序实体的时候应该以lib5.为限定符。这也就是第二个错误提示的原因了。Go 命令找不到lib.这个限定符对应的代码包。</li>
</ul>
<p>3、为什么会是这样？<br>根本原因就是，我们在源码文件中声明所属的代码包与其所在目录的名称不同。请记住，源码文件所在的目录相对于 src 目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符要与它声明所属的代码包名称对应。</p>
<p>有两个方式可以使上述构建成功完成。我在这里选择把 demo5_lib.go 文件中的代码包声明语句改为package lib。理由是，为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。</p>
<h4 id="2、什么样的程序实体才可以被当前包外的代码引用？"><a href="#2、什么样的程序实体才可以被当前包外的代码引用？" class="headerlink" title="2、什么样的程序实体才可以被当前包外的代码引用？"></a>2、什么样的程序实体才可以被当前包外的代码引用？</h4><p>1、为什么要把 demo5_lib.go 文件中的那个函数名称hello的首字母大写？<br>实际上这涉及了 Go 语言中对于程序实体访问权限的规则。超级简单，<strong>名称的首字母为大写的程序实体才可以被当前包外的代码引用</strong>，否则它就只能被当前包内的其他代码引用。通过名称，Go 语言自然地把程序实体的访问权限划分为了<strong>包级私有的和公开的</strong>。<strong>对于包级私有的程序实体，即使你导入了它所在的代码包也无法引用到它。</strong></p>
<h4 id="3、对于程序实体，还有其他的访问权限规则吗？"><a href="#3、对于程序实体，还有其他的访问权限规则吗？" class="headerlink" title="3、对于程序实体，还有其他的访问权限规则吗？"></a>3、对于程序实体，还有其他的访问权限规则吗？</h4><p>1、答案是肯定的。在 Go 1.5 及后续版本中，我们可以通过创建internal代码包让一些程序实体仅仅能被当前模块中的其他代码引用。这被称为 Go 程序实体的第三种访问权限：<strong>模块级私有</strong>。</p>
<p>2、具体规则是，<strong>internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用</strong>。当然，引用前需要先导入这个internal包。<strong>对于其他代码包，导入该internal包都是非法的，无法通过编译</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/12/GO：1-3-库源码文件/" data-id="ckcpzrdnu0000sovizspudb7w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：1-2-命令源码文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/GO：1-2-命令源码文件/" class="article-date">
  <time datetime="2020-07-10T11:25:13.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/GO：1-2-命令源码文件/">GO：1.2 命令源码文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们已经知道，环境变量 GOPATH 指向的是一个或多个工作区，每个工作区中都会有以代码包为基本组织形式的源码文件。</p>
<p>这里的源码文件又分为三种，即：<strong>命令源码文件、库源码文件和测试源码文件</strong>，它们都有着不同的用途和编写规则。<br><img src="/2020/07/10/GO：1-2-命令源码文件/command1.png" alt="command1.png"></p>
<h3 id="1、命令源码文件的用途是什么，怎样编写它？"><a href="#1、命令源码文件的用途是什么，怎样编写它？" class="headerlink" title="1、命令源码文件的用途是什么，怎样编写它？"></a>1、命令源码文件的用途是什么，怎样编写它？</h3><p>1、命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。</p>
<p>2、如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么它就是命令源码文件。 就像下面这段代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello, world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你把这段代码存成 demo1.go 文件，那么运行go run demo1.go命令后就会在屏幕（标准输出）中看到Hello, world!</p>
<p>注：<br>1、当需要模块化编程时，我们往往会将代码拆分到多个文件，甚至拆分到不同的代码包中。但无论怎样，对于一个独立的程序来说，<strong>命令源码文件永远只会也只能有一个</strong>。如果有与命令源码文件同包的源码文件，那么它们也应该声明属于main包。</p>
<p>2、通过构建或安装命令源码文件，<strong>生成的可执行文件就可以被视为“命令”</strong>，既然是命令，那么就应该具备接收参数的能力。</p>
<h3 id="2、命令源码文件怎样接收参数"><a href="#2、命令源码文件怎样接收参数" class="headerlink" title="2、命令源码文件怎样接收参数"></a>2、命令源码文件怎样接收参数</h3><p>先看下面代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span><span class="comment">//1步</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//2步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、函数flag.StringVar接受 4 个参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、第 1 个参数是用于存储该命令参数值的地址，具体到这里就是在前面声明的变量name的地址了，由表达式&amp;name表示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、第 2 个参数是为了指定该命令参数的名称，这里是name。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、第 3 个参数是为了指定在未追加该命令参数时的默认值，这里是everyone。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、第 4 个函数参数，即是该命令参数的简短说明了，这在打印命令说明时会用到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()<span class="comment">//函数flag.Parse用于真正解析命令参数，并把它们的值赋给相应的变量。</span></span><br><span class="line">  <span class="comment">//3步</span></span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对该函数的调用必须在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是在[2]处对flag.StringVar函数的调用）之后，并且在读取任何命令参数值之前进行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">正因为如此，我们最好把flag.Parse()放在main函数的函数体的第一行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>注：还有一个与flag.StringVar函数类似的函数，叫flag.String。这两个函数的区别是，后者会直接返回一个已经分配好的用于存储命令参数值的地址。如果使用它的话，我们就需要把“var name string”改为<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明"><a href="#3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明" class="headerlink" title="3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明"></a>3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明</h3><p>我们把上述代码存成名为 demo2.go 的文件，那么运行如下命令就可以为参数name传值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run demo2.<span class="keyword">go</span> -name=<span class="string">"Robert"</span></span><br></pre></td></tr></table></figure></p>
<p>运行后，打印到标准输出（stdout）的内容会是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Robert!</span><br></pre></td></tr></table></figure></p>
<p>另外，如果想查看该命令源码文件的参数说明，可以这样做：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run demo2.<span class="keyword">go</span> --help</span><br></pre></td></tr></table></figure></p>
<p>其中的$表示我们是在命令提示符后运行go run命令的。运行后输出的内容会类似：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage of /<span class="keyword">var</span>/folders/ts/<span class="number">7</span>lg_tl_x2gd_k1lm5g_48c7w0000gn/T/<span class="keyword">go</span>-build155438482/b001/exe/demo2:</span><br><span class="line"> -name <span class="keyword">string</span></span><br><span class="line">    The greeting object. (<span class="keyword">default</span> <span class="string">"everyone"</span>)</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>以下是go run命令构建上述命令源码文件时临时生成的可执行文件的完整路径<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">var</span>/folders/ts/<span class="number">7</span>lg_tl_x2gd_k1lm5g_48c7w0000gn/T/<span class="keyword">go</span>-build155438482/b001/exe/demo2</span><br></pre></td></tr></table></figure></p>
<p>如果我们先构建这个命令源码文件再运行生成的可执行文件，像这样：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build demo2.<span class="keyword">go</span></span><br><span class="line">$ ./demo2 --help</span><br></pre></td></tr></table></figure></p>
<p>那么输出就会是<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage of ./demo2:</span><br><span class="line"> -name <span class="keyword">string</span></span><br><span class="line">    The greeting object. (<span class="keyword">default</span> <span class="string">"everyone"</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="4、怎样自定义命令源码文件的参数使用说明"><a href="#4、怎样自定义命令源码文件的参数使用说明" class="headerlink" title="4、怎样自定义命令源码文件的参数使用说明"></a>4、怎样自定义命令源码文件的参数使用说明</h3><p>1、最简单的一种方式就是对变量flag.Usage重新赋值。</p>
<p>flag.Usage的类型是func()，即一种无参数声明且无结果声明的函数类型。flag.Usage变量在声明时就已经被赋值了，所以我们才能够在运行命令go run demo2.go –help时看到正确的结果。注意，对flag.Usage的赋值必须在调用flag.Parse函数之前。现在，我们把 demo2.go 另存为 demo3.go，然后在main函数体的开始处加入如下代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span><span class="comment">//1步</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//2步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     fmt.Fprintf(os.Stderr, <span class="string">"Usage of %s:\n"</span>, <span class="string">"question"</span>)</span><br><span class="line">     flag.PrintDefaults()</span><br><span class="line">    &#125;</span><br><span class="line">  flag.Parse()<span class="comment">//函数flag.Parse用于真正解析命令参数，并把它们的值赋给相应的变量。</span></span><br><span class="line">  <span class="comment">//3步</span></span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run demo3.<span class="keyword">go</span> --help</span><br></pre></td></tr></table></figure></p>
<p>后，就会看到<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage of question:</span><br><span class="line"> -name <span class="keyword">string</span></span><br><span class="line">    The greeting object. (<span class="keyword">default</span> <span class="string">"everyone"</span>)</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>2、现在再深入一层，我们在调用flag包中的一些函数（比如StringVar、Parse等等）的时候，实际上是在调用flag.CommandLine变量的对应方法。</p>
<p><strong>flag.CommandLine相当于默认情况下的命令参数容器</strong>。所以，通过对flag.CommandLine重新赋值，我们可以更深层次地定制当前命令源码文件的参数使用说明。</p>
<p>现在我们把main函数体中的那条对flag.Usage变量的赋值语句注销掉，然后在init函数体的开始处添加如下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span><span class="comment">//1步</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.CommandLine = flag.NewFlagSet(<span class="string">""</span>, flag.ExitOnError)</span><br><span class="line">  flag.CommandLine.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Fprintf(os.Stderr, <span class="string">"Usage of %s:\n"</span>, <span class="string">"question"</span>)</span><br><span class="line">  flag.PrintDefaults()</span><br><span class="line">&#125;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//2步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()<span class="comment">//函数flag.Parse用于真正解析命令参数，并把它们的值赋给相应的变量。</span></span><br><span class="line">  <span class="comment">//3步</span></span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再运行命令go run demo3.go –help后，其输出会与上一次的输出的一致。不过后面这种定制的方法更加灵活。比如，当我们把为flag.CommandLine赋值的那条语句改为<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.CommandLine = flag.NewFlagSet(<span class="string">""</span>, flag.PanicOnError)</span><br></pre></td></tr></table></figure></p>
<p>后，再运行go run demo3.go –help命令就会产生另一种输出效果。这是由于我们在这里传给flag.NewFlagSet函数的第二个参数值是flag.PanicOnError。</p>
<ul>
<li>1、flag.PanicOnError和flag.ExitOnError都是预定义在flag包中的常量。</li>
<li>2、flag.ExitOnError的含义是，告诉命令参数容器，当命令后跟–help或者参数设置的不正确的时候，在打印命令参数使用说明后以状态码2结束当前程序。</li>
<li>状态码2代表用户错误地使用了命令，而flag.PanicOnError与之的区别是在最后抛出“运行时恐慌（panic）”。</li>
<li>上述两种情况都会在我们调用flag.Parse函数时被触发。</li>
</ul>
<p>3、下面再进一步，我们索性不用全局的flag.CommandLine变量，转而自己创建一个私有的命令参数容器。我们在函数外再添加一个变量声明：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cmdLine = flag.NewFlagSet(<span class="string">"question"</span>, flag.ExitOnError)</span><br></pre></td></tr></table></figure></p>
<p>然后，我们把对flag.StringVar的调用替换为对cmdLine.StringVar调用，再把flag.Parse()替换为cmdLine.Parse(os.Args[1:])。</p>
<p>其中的os.Args[1:]指的就是我们给定的那些命令参数。这样做就完全脱离了flag.CommandLine。</p>
<p>这样做的好处依然是更灵活地定制命令参数容器。但更重要的是，你的定制完全不会影响到那个全局变量flag.CommandLine。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/10/GO：1-2-命令源码文件/" data-id="ckcpzrdo50003soviv0e8uwpo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：工作区和GOPATH" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/GO：工作区和GOPATH/" class="article-date">
  <time datetime="2020-07-10T06:27:34.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/GO：工作区和GOPATH/">GO：工作区和GOPATH</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、Go基础知识导图"><a href="#1、Go基础知识导图" class="headerlink" title="1、Go基础知识导图"></a>1、Go基础知识导图</h3><p><img src="/2020/07/10/GO：工作区和GOPATH/go1.jpg" alt="go1.jpg"></p>
<h3 id="2、工作区和GOPATH"><a href="#2、工作区和GOPATH" class="headerlink" title="2、工作区和GOPATH"></a>2、工作区和GOPATH</h3><h4 id="1、Go-3个环境变量"><a href="#1、Go-3个环境变量" class="headerlink" title="1、Go 3个环境变量"></a>1、Go 3个环境变量</h4><ul>
<li>GOROOT：Go语言安装根目录的路径，也就是GO语言的安装路径</li>
<li>GOPATH：若干工作区目录的路径，是我们自己定义的工作空间</li>
<li>GOBIN：Go程序生成的可执行文件的路径</li>
</ul>
<h4 id="2、GOPATH有什么意义"><a href="#2、GOPATH有什么意义" class="headerlink" title="2、GOPATH有什么意义"></a>2、GOPATH有什么意义</h4><ol>
<li><p>可以把GOPATH简单理解成Go语言的工作目录，它的值是一个目录的路径，也可以是多个目录的路径，每个目录都代表Go语言的一个工作区。</p>
</li>
<li><p>我们需要利用这些工作区去放置Go语言的源码文件，以及安装（install）后的归档文件（archive file，也就是以.a为扩展名的文件）和可执行文件。</p>
</li>
<li><p>Go语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本都是围绕GOPATH和工作区进行的。</p>
</li>
</ol>
<p>go build 命令一些可选项的用途和用法</p>
<h4 id="1、Go-语言源码的组织方式是怎样的？"><a href="#1、Go-语言源码的组织方式是怎样的？" class="headerlink" title="1、Go 语言源码的组织方式是怎样的？"></a>1、Go 语言源码的组织方式是怎样的？</h4><p>1、Go语言的源码也是以代码包为基本组织单位的。在文件系统中，这些代码包与目录一一对应。目录有子目录，代码包也可以有子包。</p>
<p>2、一个代码包可以包含任意个以.go为扩展名的原码文件，这些源码文件都需要被声明属于同一个代码包。</p>
<p>3、代码包的名称一般会与源码文件所在目录同名。如果不同名，在构建、安装时会以代码包名称为准。</p>
<p>4、每个代码包都有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/labstack/echo"</span></span><br></pre></td></tr></table></figure></p>
<p>5、在工作区中，一个代码包的导入路径实际上就是从src子目录到该包的实际存储位置的相对路径。</p>
<p>6、所以说，Go语言源码的组织方式就是以环境变量GOPATH、工作区、src目录个代码包为主线的。一般情况下，Go语言的源码文件都需要存放在环境变量GOPATH包含的某个工作区（目录）中的src目录下的某个代码包（目录）中。</p>
<h4 id="2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）"><a href="#2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）" class="headerlink" title="2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）"></a>2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）</h4><p>1、源码文件通常会被放在某个工作区的src子目录下</p>
<p>2、安装后如果产生了归档文件（以.a为扩展名的文件）会被放进该工作区的pkg子目录</p>
<p>3、如果产生了可执行文件，就可能会被放在该工作区的bin子目录下。</p>
<p><strong>归档文件存放具体位置和规则：</strong><br>1、源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件就是与这个代码包同名的。</p>
<p>2、放置它的相对目录就是该代码包的导入路径的直接父级。比如，一个已存在的代码包的导入路径是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com/labstack/echo</span><br></pre></td></tr></table></figure></p>
<p>那么执行命令<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> insatll github.com/labstack/echo</span><br></pre></td></tr></table></figure></p>
<p>生成的归档文件的相对目录就是github.com/labstack，文件名为echo.a。</p>
<p>3、上面这个代码包导入路径还有一层含义，即：该代码包的源码文件存在于github网站的labstack组的代码仓库echo中</p>
<p>4、归档文件的相对目录与pkg目录之间还有一级目录，称为平台相关目录。平台相关目录的名称是由“build”的目标操作系统、下划线和目标计算架构的代号组成的。比如，构建某个代码包的目标擦欧总系统时Linux，目标计算架构是64位，对应的平台相关目录就是linux_amd64。<br>因此，上述代码包的归档文件就会被放置在当前工作区的子目录<br>pkg/linux_amd64/github.com/labstack中。<br>gopath与工作区：<br><img src="/2020/07/10/GO：工作区和GOPATH/gopath1.png" alt="gopath1.png"></p>
<p>5、某个工作区的src子目录下的源码文件在安装后一般会被放置到当前工作区的pkg子目录下对应的目录中，或者直接被放置到该工作区的bin子目录中。</p>
<h4 id="3、理解构建和安装Go程序的过程"><a href="#3、理解构建和安装Go程序的过程" class="headerlink" title="3、理解构建和安装Go程序的过程"></a>3、理解构建和安装Go程序的过程</h4><p>构建与安装的异同：<br>1、构建使用命令go build，安装使用命令go install。构建和安装代码包的时候都会执行编译、打包等操作，并且，这些操作生成的任何文件都会先被保存到某个临时的目录中。</p>
<p>2、构建源码文件</p>
<ul>
<li>如果构建的是库源码文件</li>
</ul>
<p>那么操作后产生的结果只会存在于临时目录中，这里构建的主要意义在于检查和验证；</p>
<ul>
<li>如果构建的是命令源码文件</li>
</ul>
<p>操作的结果文件会被搬运到源码文件所在的目录中。</p>
<p>3、安装过程会先执行构建、然后还会进行你链接操作，并且把结果文件搬运到指定目录。如：</p>
<ul>
<li>安装库源码文件，结果文件被搬运到他所在工作区的pkg目录下的某个子目录中；</li>
<li>安装命令源码文件，结果文件被搬运到他所在工作区的bin目录中，或者环境变量GOBIN指向的目录中。</li>
</ul>
<h3 id="4、go-build-命令一些可选项的用途和用法"><a href="#4、go-build-命令一些可选项的用途和用法" class="headerlink" title="4、go build 命令一些可选项的用途和用法"></a>4、go build 命令一些可选项的用途和用法</h3><p>1、在运行go build命令的时候，默认不会编译目标代码包所依赖的那些代码包。</p>
<p>2、如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。</p>
<p>3、如果要强制编译它们，可以在执行命令的时候加入标记-a。此时，不但目标代码包总是会被编译，它依赖的代码包也总会被编译，即使依赖的是标准库中的代码包也是如此。</p>
<p>5、另外，如果不但要编译依赖的代码包，还要安装它们的归档文件，那么可以加入标记-i。</p>
<p>6、那么我们怎么确定哪些代码包被编译了呢？有两种方法。</p>
<ul>
<li>运行go build命令时加入标记-x，这样可以看到go build命令具体都执行了哪些操作。另外也可以加入标记-n，这样可以只查看具体操作而不执行它们。</li>
<li>运行go build命令时加入标记-v，这样可以看到go build命令编译的代码包的名称。它在与-a标记搭配使用时很有用。</li>
</ul>
<p>7、下面再说一说与 Go 源码的安装联系很紧密的一个命令：go get。<br>命令go get会自动从一些主流公用代码仓库（比如 GitHub）下载目标代码包，并把它们安装到环境变量GOPATH包含的第 1 工作区的相应目录中。如果存在环境变量GOBIN，那么仅包含命令源码文件的代码包会被安装到GOBIN指向的那个目录。</p>
<p>最常用的几个标记有下面几种。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-u：下载并安装代码包，不论工作区中是否已存在它们。</span><br><span class="line"></span><br><span class="line">-d：只下载代码包，不安装代码包。</span><br><span class="line"></span><br><span class="line">-fix：在下载代码包后先运行一个用于根据当前 Go 语言版本修正代码的工具，然后再安装代码包。</span><br><span class="line"></span><br><span class="line">-t：同时下载测试所需的代码包。</span><br><span class="line"></span><br><span class="line">-insecure：允许通过非安全的网络协议下载和安装代码包。HTTP 就是这样的协议。</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/10/GO：工作区和GOPATH/" data-id="ckcpzrdo40002sovi6gurhfdr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hexo博客迁移" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/02/hexo博客迁移/" class="article-date">
  <time datetime="2020-07-02T07:53:23.000Z" itemprop="datePublished">2020-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/02/hexo博客迁移/">hexo博客迁移</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、安装hexo博客必要的软件"><a href="#1、安装hexo博客必要的软件" class="headerlink" title="1、安装hexo博客必要的软件"></a>1、安装hexo博客必要的软件</h4><p>1、下载安装Git客户端<br>2、安装node js</p>
<h4 id="2、Github添加新电脑生成的密钥"><a href="#2、Github添加新电脑生成的密钥" class="headerlink" title="2、Github添加新电脑生成的密钥"></a>2、Github添加新电脑生成的密钥</h4><p>打开git bash输入如下命令：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"xxxxx@xxx.com"</span></span><br></pre></td></tr></table></figure></p>
<p>邮箱为GitHub注册邮箱，输入命令后直接回车，生成密钥对。根据提示找到密钥对所在位置，将id_rsa.pub公钥内容复制粘贴到Github-settings-‘SSH and GPG keys’-‘SSH keys’中。</p>
<p>使用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com   测试公钥是否添加成功</span><br></pre></td></tr></table></figure></p>
<h4 id="3、备份原文件"><a href="#3、备份原文件" class="headerlink" title="3、备份原文件"></a>3、备份原文件</h4><p>需要转移的文件有：<br><img src="/2020/07/02/hexo博客迁移/hexo1.png" alt="hexo1"><br>由于配置文件和主题文件需要经常更改，采用github创建博客分支的方式进行备份。</p>
<p><strong>1、创建分支</strong><br> 克隆github上上生成的静态文件到hexo文件夹中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/yourname/xxxx.github.io.git hexo</span></span><br></pre></td></tr></table></figure></p>
<p>克隆后将除.git文件外其他所有文件删除。主要是为了得到版本管理文件夹.git（.git文件为隐藏文件，可直接将可见文件全部删除）。</p>
<p><strong>2、将备份的原文件复制到此文件夹</strong><br>若文件夹是从github克隆，则需要删除主题文件中的版本控制文件夹,以next主题为例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf thems/next/.git*</span><br></pre></td></tr></table></figure></p>
<p>创建名为hexo的分支<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hexo</span><br></pre></td></tr></table></figure></p>
<p>保存所有文件到暂存区<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all</span><br></pre></td></tr></table></figure></p>
<p>提交变更<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"hexo-2"</span></span><br></pre></td></tr></table></figure></p>
<p>提交变更时报错：<br><img src="/2020/07/02/hexo博客迁移/hexo2.png" alt="hexo2"><br>根据提示配置。<br>推送分支到github,并用–set-upstream与origin创建关联，将hexo设置为默认分支<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --set-upstream origin hexo</span><br></pre></td></tr></table></figure></p>
<h4 id="4、迁移"><a href="#4、迁移" class="headerlink" title="4、迁移"></a>4、迁移</h4><p>以后在其他电脑上写博客，直接将分支克隆下来。再使用npm install安装依赖。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b hexo https:<span class="comment">//github.com/yourname/xxx.github.io.git</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<h4 id="5、发表文章"><a href="#5、发表文章" class="headerlink" title="5、发表文章"></a>5、发表文章</h4><p>1、新建文章<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure></p>
<p>2、注意：需要使用git push把源文件推到分支上<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"xxxx"</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p>
<p>3、部署文章<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p>
<p>参考：<br>1、<a href="https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/" target="_blank" rel="noopener">https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/</a></p>
<p>2、<a href="https://blog.csdn.net/white_idiot/article/details/80685990" target="_blank" rel="noopener">https://blog.csdn.net/white_idiot/article/details/80685990</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/02/hexo博客迁移/" data-id="ckcpzrdp7000xsovihlgx9ba4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-测试驱动开发TDD" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/15/测试驱动开发TDD/" class="article-date">
  <time datetime="2020-06-15T06:27:12.000Z" itemprop="datePublished">2020-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/15/测试驱动开发TDD/">测试驱动开发TDD</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="测试驱动开发TDD（Test-Driven-Development）"><a href="#测试驱动开发TDD（Test-Driven-Development）" class="headerlink" title="测试驱动开发TDD（Test Driven Development）"></a>测试驱动开发TDD（Test Driven Development）</h2><h3 id="1、什么是-TDD"><a href="#1、什么是-TDD" class="headerlink" title="1、什么是 TDD"></a>1、什么是 TDD</h3><h4 id="1、TDD-有广义和狭义之分"><a href="#1、TDD-有广义和狭义之分" class="headerlink" title="1、TDD 有广义和狭义之分"></a>1、TDD 有广义和狭义之分</h4><p>1、常说的是狭义的TDD，也就是单元测试驱动开发UTDD（Unit Test Driven Development）；</p>
<p>2、广义的TDD：是验收测试驱动开发ATDD（Acceptance Test Driven Development），<br>包括行为驱动开发BDD（Behavior Driven Development）和消费者驱动契约开发Consumer-Driven Contracts Development 等。</p>
<h4 id="2、TDD-有三层含义："><a href="#2、TDD-有三层含义：" class="headerlink" title="2、TDD 有三层含义："></a>2、TDD 有三层含义：</h4><ul>
<li>Test-Driven Development，测试驱动开发。</li>
<li>Task-Driven Development，任务驱动开发，要对问题进行分析并进行任务分解。</li>
<li>Test-Driven Design，测试保护下的设计改善。TDD 并不能直接提高设计能力，它只是给你更多机会和保障去改善设计。</li>
</ul>
<h4 id="3、TDD-流程"><a href="#3、TDD-流程" class="headerlink" title="3、TDD 流程"></a>3、TDD 流程</h4><p>TDD 的基本流程是：红，绿，重构。<br><img src="/2020/06/15/测试驱动开发TDD/tdd2.jpg" alt="tdd2"></p>
<p>更详细的流程是：<br><img src="/2020/06/15/测试驱动开发TDD/tdd1.jpg" alt="tdd1"></p>
<p>1、编写测试<br>2、运行测试，观察测试结果是否如期失败（变红）<br>3、测试结果不如期失败，返回第1步修改测试<br>4、测试结果如期失败，编写刚好能够让测试通过的产品代码实现<br>5、运行测试，观察测试结果是否如期成功（变绿）<br>6、测试结果不如期成功，返回第4步修改实现<br>7、测试结果如期成功，分析代码是否需要重构<br>8、需要重构，返回第4步修改实现<br>9、不需要重构，编写下一个测试</p>
<h4 id="4、TDD-优点"><a href="#4、TDD-优点" class="headerlink" title="4、TDD 优点"></a>4、TDD 优点</h4><p>1、降低开发者负担<br>通过明确的流程，让我们一次只关注一个点，思维负担更小。</p>
<p>2、保护网<br>TDD 的好处是覆盖完全的单元测试，对产品代码提供了一个保护网，让我们可以轻松地迎接需求变化或改善代码的设计。<br>所以如果你的项目需求稳定，一次性做完，后续没有任何改动的话，能享受到 TDD 的好处就比较少了。</p>
<p>3、提前澄清需求<br>先写测试可以帮助我们去思考需求，并提前澄清需求细节，而不是代码写到一半才发现不明确的需求。</p>
<p>4、快速反馈<br>有很多人说 TDD 时，我的代码量增加了，所以开发效率降低了。但是，如果没有单元测试，你就要手工测试，你要花很多时间去准备数据，启动应用，跳转界面等，反馈是很慢的。准确说，快速反馈是单元测试的好处。</p>
<h4 id="5、TDD-的三条规则"><a href="#5、TDD-的三条规则" class="headerlink" title="5、TDD 的三条规则"></a>5、TDD 的三条规则</h4><p>1、除非是为了使一个失败的 unit test 通过，否则不允许编写任何产品代码</p>
<p>2、在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）</p>
<p>3、只允许编写刚好能够使一个失败的 unit test 通过的产品代码</p>
<p>如果违反了会怎么样呢？<br>1、违反第一条，先编写了产品代码，那这段代码是为了实现什么需求呢？怎么确保它真的实现了呢？<br>2、违反第二条，写了多个失败的测试，如果测试长时间不能通过，会增加开发者的压力，另外，测试可能会被重构，这时会增加测试的修改成本。<br>3、违反第三条，产品代码实现了超出当前测试的功能，那么这部分代码就没有测试的保护，不知道是否正确，需要手工测试。可能这是不存在的需求，那就凭空增加了代码的复杂性。如果是存在的需求，那后面的测试写出来就会直接通过，破坏了 TDD 的节奏感。</p>
<p>我认为它的本质是：<br>1、分离关注点，一次只戴一顶帽子<br>在我们编程的过程中，有几个关注点：需求，实现，设计。<br>TDD 给了我们明确的三个步骤，每个步骤关注一个方面。</p>
<ul>
<li>红：<br>写一个失败的测试，它是对一个小需求的描述，只需要关心输入输出，这个时候根本不用关心如何实现。</li>
<li>绿：<br>专注在用最快的方式实现当前这个小需求，不用关心其他需求，也不要管代码的质量多么惨不忍睹。</li>
<li>重构：<br>既不用思考需求，也没有实现的压力，只需要找出代码中的坏味道，并用一个手法消除它，让代码变成整洁的代码。</li>
</ul>
<p>2、注意力控制<br>人的注意力既可以主动控制，也会被被动吸引。注意力来回切换的话，就会消耗更多精力，思考也会不那么完整。<br>使用 TDD 开发，我们要主动去控制注意力，写测试的时候，发现一个类没有定义，IDE 提示编译错误，这时候你如果去创建这个类，你的注意力就不在需求上了，已经切换到了实现上，我们应该专注地写完这个测试，思考它是否表达了需求，确定无误后再开始去消除编译错误。</p>
<p>参考：<a href="https://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="noopener">https://www.jianshu.com/p/62f16cd4fef3</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/15/测试驱动开发TDD/" data-id="ckcpzrdpx001ssovi4yxdo4wx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go-goroutine、channel、反射" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-goroutine、channel、反射/" class="article-date">
  <time datetime="2020-06-11T07:58:15.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/go-goroutine、channel、反射/">go:goroutine、channel、反射</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、goroutine"><a href="#1、goroutine" class="headerlink" title="1、goroutine"></a>1、goroutine</h3><h4 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、Go协程和Go主线程</p>
<ul>
<li><strong>Go主线程</strong>（有的程序员直接成为线程/也可以理解成进程）：<strong>一个Go主线程上，可以起多个协程</strong>，即<strong>协程是轻量级的线程</strong>。</li>
</ul>
<p>2、Go协程的特点</p>
<ul>
<li>有独立的栈空间</li>
<li>共享程序堆空间</li>
<li>调度由用户控制</li>
<li>协程是轻量级的线程</li>
</ul>
<p>3、案例<br>1）在主线程（可以理解成进程），开启一个goroutine，该协程每隔一秒输出“hello world”<br>2）在主线程中也每隔一秒输出“hello world”，输出10次后，退出程序<br>3）要求主线程和goroutine同时执行<br>4）主线程和协程执行流程图</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>    </span><br><span class="line">    <span class="string">"strconv"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个函数，每隔1秒输出“hello world”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span> ;i++  &#123;   </span><br><span class="line">        fmt.Println(<span class="string">"test() hello world"</span>+strconv.Itoa(i))     </span><br><span class="line">        </span><br><span class="line">        time.Sleep(time.Second)  <span class="comment">//休眠一秒  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">go</span> test()<span class="comment">//开启一个协程    </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span> ;i++  &#123;    </span><br><span class="line">        fmt.Println(<span class="string">"main() hello world"</span>+strconv.Itoa(i))      </span><br><span class="line">        </span><br><span class="line">        time.Sleep(time.Second)     <span class="comment">//休眠一秒  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main() hello world1</span><br><span class="line">test() hello world1</span><br><span class="line">main() hello world2</span><br><span class="line">test() hello world2</span><br><span class="line">test() hello world3</span><br><span class="line">main() hello world3</span><br><span class="line">main() hello world4</span><br><span class="line">test() hello world4</span><br><span class="line">test() hello world5</span><br><span class="line">main() hello world5</span><br><span class="line">test() hello world6</span><br><span class="line">main() hello world6</span><br><span class="line">main() hello world7</span><br><span class="line">test() hello world7</span><br><span class="line">test() hello world8</span><br><span class="line">main() hello world8</span><br><span class="line">main() hello world9</span><br><span class="line">test() hello world9</span><br></pre></td></tr></table></figure></p>
<p>由输出看出，<strong>主线程main和协程test同时执行</strong></p>
<ul>
<li><p>主线程和协程执行流程图<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine1.jpg" alt="goroutine1"></p>
</li>
<li><p>程序开始执行，main主线程开始执行</p>
</li>
<li>go test()开启协程，<strong>主线程main和协程test同时执行</strong></li>
<li>程序退出以<strong>主线程</strong>为主：<pre><code>1） 如果主线程退出了，则协程即使还没有执行完毕也会退出
2）当然协程可以在主线程没有退出前，就执行完毕退出协程
</code></pre></li>
</ul>
<p>4、总结</p>
<ul>
<li><p>1）<strong>主线程</strong>是一个<strong>物理线程</strong>，<strong>直接作用在CPU上</strong>。是重量级的，非常耗费CPU资源。</p>
</li>
<li><p>2）<strong>协程从主线程开启的</strong>，是轻量级的线程，是<strong>逻辑态的</strong>。对资源消耗相对小</p>
</li>
<li><p>3）Go的协程机制是重要特点，可以轻松的开启上万个协程。（其他编程语言的开发机制一般是基于线程的，开启过多的线程，资源消耗大）</p>
</li>
</ul>
<h4 id="2、goroutine的调度模型"><a href="#2、goroutine的调度模型" class="headerlink" title="2、goroutine的调度模型"></a>2、goroutine的调度模型</h4><p>1、MPG模式基本介绍</p>
<ul>
<li>M：操作系统的主线程（是物理线程，真正干活的人）</li>
<li>P：协程执行需要的上下文环境（运行时需要的资源和运行时的状态）</li>
<li>G：协程（逻辑态的）</li>
</ul>
<p>2、MPG模式运行的状态</p>
<p>1）MPG模式运行的状态1<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine2.jpg" alt="goroutine2"></p>
<p>2）MPG模式运行的状态2<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine3.jpg" alt="goroutine3"></p>
<h4 id="3、设置运行CPU数目"><a href="#3、设置运行CPU数目" class="headerlink" title="3、设置运行CPU数目"></a>3、设置运行CPU数目</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="comment">//runtime.NumCPU()   查询系统的CPU数目</span></span><br><span class="line">    cpuNum := runtime.NumCPU()   </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"cpuNum="</span>,cpuNum)     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置使用多个CPU     </span></span><br><span class="line">    runtime.GOMAXPROCS(cpuNum<span class="number">-1</span>)     </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"ok"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、管道channel"><a href="#2、管道channel" class="headerlink" title="2、管道channel"></a>2、管道channel</h3><p>案例：计算1-20的各个数的阶乘，并且把各个数放入map中并打印，使用goroutine完成</p>
<p>思路：</p>
<ul>
<li>1、编写一个函数，计算各个数的阶乘并放入map中</li>
<li>2、启动多个协程，统计的结果放入map中</li>
<li>3、map应该做全局的</li>
</ul>
<p>解法一：使用全局变量加锁同步<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (     </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"sync"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(  </span><br><span class="line">    myMap =<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//全局资源不加锁，会发生资源竞争，同时写会报错   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以声明一个全局互斥锁解决    </span></span><br><span class="line">    <span class="comment">//sync是一个包，synchornized 同步    </span></span><br><span class="line">    <span class="comment">//Mutex 互斥      </span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//test函数计算n的阶乘，将结果放入myMap中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="keyword">int</span>)</span></span>&#123;    </span><br><span class="line">    res:=<span class="number">1</span>    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++&#123;      </span><br><span class="line">    res*=i  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入map前加锁    </span></span><br><span class="line">    lock.Lock()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//把结果放入myMap     </span></span><br><span class="line">    myMap[n]=res    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//写完map后解锁    </span></span><br><span class="line">    lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//这里开启20个协程，</span></span><br><span class="line">    <span class="comment">//20个协程同时向map写数据，会发生 并发map写 错误    </span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++&#123;         </span><br><span class="line">        <span class="keyword">go</span> test(i)    </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//休眠5秒钟（人为估算），让主线程等待所有的协程执行完   </span></span><br><span class="line">    time.Sleep(<span class="number">5</span>*time.Second)   </span><br><span class="line">    <span class="comment">//如果不休眠，可能main主线程已经结束退出，但是test协程还没写入map     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//互斥性资源读写都要加锁     </span></span><br><span class="line">    lock.Lock()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出结果，对map进行读操作     </span></span><br><span class="line">    <span class="keyword">for</span> i,v :=<span class="keyword">range</span> myMap&#123;           </span><br><span class="line">        fmt.Printf(<span class="string">"map[%d]=%d\n"</span>,i,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    lock.Unlock()&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="number">17</span>]=<span class="number">355687428096000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">16</span>]=<span class="number">20922789888000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">20</span>]=<span class="number">2432902008176640000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">9</span>]=<span class="number">362880</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">10</span>]=<span class="number">3628800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">12</span>]=<span class="number">479001600</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">3</span>]=<span class="number">6</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">19</span>]=<span class="number">121645100408832000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">11</span>]=<span class="number">39916800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">15</span>]=<span class="number">1307674368000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">18</span>]=<span class="number">6402373705728000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">8</span>]=<span class="number">40320</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">5</span>]=<span class="number">120</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">7</span>]=<span class="number">5040</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">14</span>]=<span class="number">87178291200</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">13</span>]=<span class="number">6227020800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">4</span>]=<span class="number">24</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">6</span>]=<span class="number">720</span></span><br></pre></td></tr></table></figure></p>
<p>因为map的key是无序的，所以未按递增顺序执行，而且并发执行的顺序也可能不是递增得到结果的</p>
<p>上面的解法中</p>
<ul>
<li>主线程等待所有goroutine全部完成时间很难确定，这里设置为5秒，是为估算</li>
<li>如果主线程休眠时间长了，会加长等待时间；如果等待时间短了，可能还有goroutine处于工作状态（没有执行完），这时也会随主线程的退出二销毁</li>
<li>通过全局变量加锁同步来实现协程间通讯，并不利于多个协程对全局变量的读写操作</li>
</ul>
<p>综上，我们引出一种新的通讯机制channel</p>
<p>解法二：使用channel</p>
<h4 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、channel本质上就是一个数据结构-队列</p>
<p>2、数据先进先出</p>
<p>3、<strong>线程安全</strong>，多个goroutine访问时，自己不需要再加锁，即：<strong>channel本身就是线程安全的</strong></p>
<p>4、<strong>channel是有类型的</strong>，一个string的channel只能存放string类型数据<br><img src="/2020/06/11/go-goroutine、channel、反射/channel1.jpg" alt="channel1"></p>
<h4 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h4><h5 id="1、定义-声明"><a href="#1、定义-声明" class="headerlink" title="1、定义/声明"></a>1、定义/声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 数据类型</span><br><span class="line"></span><br><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//intChan类型为int，只能存放int型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//mapChan类型为map[int]string，只能存放map[int]string型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> perChan <span class="keyword">chan</span> Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> perChan2 <span class="keyword">chan</span> *Person</span><br></pre></td></tr></table></figure>
<p>2、注意</p>
<ul>
<li>channel是<strong>引用类型</strong></li>
<li><strong>channel必须初始化后才能写入数据，即make后才能使用</strong></li>
<li>channel是由类型的，如intChan类型为int，只能存放int型数据</li>
</ul>
<h5 id="3、管道的初始化、从管道读写数据以及注意事项"><a href="#3、管道的初始化、从管道读写数据以及注意事项" class="headerlink" title="3、管道的初始化、从管道读写数据以及注意事项"></a>3、管道的初始化、从管道读写数据以及注意事项</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">//1、创建一个可以存放3个int的管道   </span></span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span>    </span><br><span class="line">    intChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)  <span class="comment">//channel make后才能使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、intChan是什么     </span></span><br><span class="line">    fmt.Printf(<span class="string">"intChan的值=%v intChan本身的地址=%v\n"</span>,intChan,&amp;intChan)   </span><br><span class="line">    <span class="comment">//输出：intChan的值=0xc000092080 </span></span><br><span class="line">    <span class="comment">//intChan本身的地址=0xc00008c018      </span></span><br><span class="line">    <span class="comment">//可以看出intChan的值为一个地址，所以channel是引用类型。    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、向管道写入数据     </span></span><br><span class="line">    intChan&lt;<span class="number">-10</span><span class="comment">//直接写入常量   </span></span><br><span class="line">    num:=<span class="number">211</span>     </span><br><span class="line">    intChan&lt;-num<span class="comment">//写入变量    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、看看管道的长度和容量    </span></span><br><span class="line">    <span class="comment">//容量是make时传入的，这里传入的是3，容量不能自动增长，和slice、map不一样    </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))     </span><br><span class="line">    <span class="comment">//channel len=2 cap=3    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、注意：给管道写入数据时不能超过容量     </span></span><br><span class="line">    intChan&lt;<span class="number">-50</span>      <span class="comment">//intChan&lt;-98     </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))   </span><br><span class="line">    <span class="comment">//fatal error: all goroutines are asleep - deadlock!   </span></span><br><span class="line">    <span class="comment">//报告死锁deadlock错误     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、从管道中读取数据     </span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">int</span>     </span><br><span class="line">    num2 = &lt;-intChan  </span><br><span class="line">    fmt.Println(<span class="string">"num2="</span>,num2)<span class="comment">//num2= 10，从队列头开始取     </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))    </span><br><span class="line">    <span class="comment">//channel len=2 cap=3     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、在没有使用协程的情况下，如果管道中的数据已经全部取出，再取数据就会报告死锁deadlock错误     </span></span><br><span class="line">    num3 := &lt;-intChan    </span><br><span class="line">    num4 := &lt;-intChan     </span><br><span class="line">    num5 := &lt;-intChan   </span><br><span class="line">    fmt.Println(<span class="string">"num3="</span>,num3,<span class="string">"num4="</span>,num4,<span class="string">"num5="</span>,num5)   </span><br><span class="line">    <span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<ul>
<li>channel中只能存放指定的数据类型</li>
<li>channel的数据放满后，就不能再放入了，否则报告死锁deadlock错误</li>
<li>当 channel的数据放满后，如果从channel中取出数据，可以再次放入数据</li>
<li>在没有使用协程的情况下，如果channel中的数据取完了，再次取数据，会报告死锁deadlock错误</li>
</ul>
<p>一个例子，当管道是空接口interface{}类型时，可以存放任意数据类型的值，取出管道中的值对象的的字段值时，需要类型断言<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123; </span><br><span class="line">    Name <span class="keyword">string</span>     </span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    allChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">3</span>)<span class="comment">//定义一个空接口类型，容量为3的管道allChan      </span></span><br><span class="line"></span><br><span class="line">    allChan&lt;<span class="number">-10</span><span class="comment">//往管道写入int类型的值     </span></span><br><span class="line">    allChan&lt;-<span class="string">"tom"</span><span class="comment">//往管道写入string类型的值    </span></span><br><span class="line"></span><br><span class="line">    cat:=Cat&#123;<span class="string">"小花猫"</span>,<span class="number">4</span>&#125;<span class="comment">//实例化一个Cat    </span></span><br><span class="line">    allChan&lt;-cat<span class="comment">////往管道写入Cat类型的值    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//想要取出管道中的第三个值，需要丢弃第一个和第二个    </span></span><br><span class="line">    &lt;-allChan    </span><br><span class="line">    &lt;-allChan    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//取到第三个   </span></span><br><span class="line">    newCat:=&lt;-allChan   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//newCat从编译层面看是空接口类型,接口类型本身没有字段    </span></span><br><span class="line">    <span class="comment">//但在运行时可动态指向结构体Cat，</span></span><br><span class="line">    <span class="comment">//下面写法语法上没错，运行时可动态指向Cat     </span></span><br><span class="line">    fmt.Printf(<span class="string">"newCat的类型=%T newCat的值=%v\n"</span>,newCat,newCat)   </span><br><span class="line">    <span class="comment">//输出：newCat的类型=main.Cat newCat的值=&#123;小花猫 4&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//newCat从编译层面看是空接口类型，接口类型本身没有字段，</span></span><br><span class="line">    <span class="comment">//直接写编译不通过，需要类型断言      </span></span><br><span class="line">    aNewCat:=newCat.(Cat)     </span><br><span class="line">    fmt.Printf(<span class="string">"newCat.Name=%v"</span>,aNewCat.Name)</span><br><span class="line">    <span class="comment">//输出：newCat.Name=小花猫</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4、管道的遍历和关闭"><a href="#4、管道的遍历和关闭" class="headerlink" title="4、管道的遍历和关闭"></a>4、管道的遍历和关闭</h5><p> 1、管道的关闭</p>
<p>使用内置函数<strong>close()可以关闭管道</strong>，当管道关闭后，就不能再向管道写数据了，但是仍然可以从管道中读取数据<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)  </span><br><span class="line">    intChan&lt;<span class="number">-100</span>   </span><br><span class="line">    intChan&lt;<span class="number">-200</span>    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、关闭管道    </span></span><br><span class="line">    <span class="built_in">close</span>(intChan)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、关闭管道后，不能再写入数据   </span></span><br><span class="line">    <span class="comment">//intChan&lt;-300    </span></span><br><span class="line">    <span class="comment">//panic: send on closed channel     </span></span><br><span class="line">    <span class="comment">//向一个关闭的通道中发送数据，panic终止程序    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、关闭管道后，可以再读取数据   </span></span><br><span class="line">    n1:=&lt;-intChan    </span><br><span class="line">    fmt.Println(<span class="string">"n1="</span>,n1)<span class="comment">//n1= 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、管道的遍历<br>channel支持for-range的方式进行遍历，有两个细节注意：</p>
<ul>
<li>在遍历时，如果channel没有关闭，则会出现死锁deadlock错误</li>
<li>在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历</li>
</ul>
<p>在遍历时不能使用普通for循环遍历，因为管道的长度（len(intChan)）是随数据出管道-1动态变化的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环往管道中写入100个数据      </span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">100</span> ;i++  &#123;       </span><br><span class="line">        intChan&lt;-i*<span class="number">2</span>   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历，一定要先关闭管道,如果不关闭管道，会出现死锁deadlock错误     </span></span><br><span class="line">    <span class="built_in">close</span>(intChan)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//管道没有下标，for-range只返回一个值    </span></span><br><span class="line">    <span class="keyword">for</span> v:= <span class="keyword">range</span> intChan&#123;         </span><br><span class="line">        fmt.Println(<span class="string">"v="</span>,v)     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、goroutine和管道channel结合使用"><a href="#3、goroutine和管道channel结合使用" class="headerlink" title="3、goroutine和管道channel结合使用"></a>3、goroutine和管道channel结合使用</h3><h4 id="1、案例："><a href="#1、案例：" class="headerlink" title="1、案例："></a>1、案例：</h4><p>案例：<br>goroutine和管道channel协同工作<br>1）开启一个wiiteData协程，向管道写入50个整数<br>2）开启一个readData协程，从管道中读取wiiteData写入的数据<br>3）注意：wiiteData和readData操作的是同一个管道<br>4）主线程需要等待wiiteData和readData协程完成工作后才能退出<br>思路图解：<br><img src="/2020/06/11/go-goroutine、channel、反射/goandchan1.jpg" alt="goandchan1"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++  &#123;   </span><br><span class="line">        intChan&lt;-i         </span><br><span class="line">        fmt.Println(<span class="string">"writeData "</span>,i)    </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(intChan)<span class="comment">//关闭intChan，后面intChan仍然可读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//readData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>,exitChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">for</span>&#123;         </span><br><span class="line">        v,ok:=&lt;-intChan      </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;       </span><br><span class="line">          <span class="keyword">break</span>     </span><br><span class="line">         &#125;         </span><br><span class="line">        fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//readData读取数据完后，    </span></span><br><span class="line">    <span class="comment">//往exitChan写入数据true，告知主线程readData执行完毕    </span></span><br><span class="line">    exitChan&lt;-<span class="literal">true</span>   </span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//创建两个管道  </span></span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">50</span>)  </span><br><span class="line">    exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)  <span class="comment">//该管道用于等到intChan管道的读取协程工作完毕后，往exitChan写入数据，标识主线程可退出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> writeData(intChan) <span class="comment">//向管道写入50个整数</span></span><br><span class="line">    <span class="keyword">go</span> readData(intChan,exitChan)   <span class="comment">//从管道中读取wiiteData写入的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>&#123;      </span><br><span class="line">        _,ok:=&lt;-exitChan    </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;            </span><br><span class="line">             <span class="keyword">break</span>       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、管道阻塞机制"><a href="#2、管道阻塞机制" class="headerlink" title="2、管道阻塞机制"></a>2、管道阻塞机制</h4><p>如果<strong>只向管道里写数据，而没有读取</strong>，就会出现<strong>阻塞而死锁</strong>deadlock。<br>注意：如果<strong>有向管道读取数据，但读取比写数据慢得多</strong>，也不会发生死锁，只要编译器检测到数据在管道中是流动的，即有读取也有写入，那么就不会发生死锁</p>
<p>下面例子中，intChan容量改为10<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++  &#123;   </span><br><span class="line">        intChan&lt;-i     <span class="comment">//数据一下就放入，但下面readData读取慢慢读</span></span><br><span class="line">    </span><br><span class="line">        fmt.Println(<span class="string">"writeData "</span>,i)    </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(intChan)<span class="comment">//关闭intChan，后面intChan仍然可读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//readData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>,exitChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">for</span>&#123;         </span><br><span class="line">        v,ok:=&lt;-intChan      </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;       </span><br><span class="line">          <span class="keyword">break</span>     </span><br><span class="line">         &#125;         </span><br><span class="line">       time.Sleep(time.Second)<span class="comment">//慢慢读，每隔一秒读一次</span></span><br><span class="line">       </span><br><span class="line">      fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//readData读取数据完后，    </span></span><br><span class="line">    <span class="comment">//往exitChan写入数据true，告知主线程readData执行完毕    </span></span><br><span class="line">    exitChan&lt;-<span class="literal">true</span>   </span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//创建两个管道  </span></span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)<span class="comment">//容量10</span></span><br><span class="line">    exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)  <span class="comment">//该管道用于等到intChan管道的读取协程工作完毕后，往exitChan写入数据，标识主线程可退出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> writeData(intChan) <span class="comment">//向管道写入50个整数</span></span><br><span class="line">    <span class="keyword">go</span> readData(intChan,exitChan)   <span class="comment">//从管道中读取wiiteData写入的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>&#123;      </span><br><span class="line">        _,ok:=&lt;-exitChan    </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;            </span><br><span class="line">             <span class="keyword">break</span>       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">writeData  <span class="number">1</span></span><br><span class="line">writeData  <span class="number">2</span></span><br><span class="line">writeData  <span class="number">3</span></span><br><span class="line">writeData  <span class="number">4</span></span><br><span class="line">writeData  <span class="number">5</span></span><br><span class="line">writeData  <span class="number">6</span></span><br><span class="line">writeData  <span class="number">7</span></span><br><span class="line">writeData  <span class="number">8</span></span><br><span class="line">writeData  <span class="number">9</span></span><br><span class="line">writeData  <span class="number">10</span></span><br><span class="line">writeData  <span class="number">11</span></span><br><span class="line">readData 读到数据=<span class="number">1</span></span><br><span class="line">writeData  <span class="number">12</span></span><br><span class="line">readData 读到数据=<span class="number">2</span></span><br><span class="line">writeData  <span class="number">13</span></span><br><span class="line">readData 读到数据=<span class="number">3</span></span><br><span class="line">writeData  <span class="number">14</span></span><br><span class="line">readData 读到数据=<span class="number">4</span></span><br><span class="line">writeData  <span class="number">15</span></span><br><span class="line">readData 读到数据=<span class="number">5</span></span><br><span class="line">writeData  <span class="number">16</span></span><br><span class="line">readData 读到数据=<span class="number">6</span></span><br><span class="line">writeData  <span class="number">17</span></span><br><span class="line">readData 读到数据=<span class="number">7</span></span><br><span class="line">writeData  <span class="number">18</span></span><br><span class="line">readData 读到数据=<span class="number">8</span></span><br><span class="line">writeData  <span class="number">19</span></span><br><span class="line">readData 读到数据=<span class="number">9</span></span><br><span class="line">writeData  <span class="number">20</span></span><br><span class="line">readData 读到数据=<span class="number">10</span></span><br><span class="line">writeData  <span class="number">21</span></span><br><span class="line">readData 读到数据=<span class="number">11</span></span><br><span class="line">writeData  <span class="number">22</span></span><br><span class="line">readData 读到数据=<span class="number">12</span></span><br><span class="line">writeData  <span class="number">23</span></span><br><span class="line">readData 读到数据=<span class="number">13</span></span><br><span class="line">writeData  <span class="number">24</span></span><br><span class="line">readData 读到数据=<span class="number">14</span></span><br><span class="line">writeData  <span class="number">25</span></span><br><span class="line">readData 读到数据=<span class="number">15</span></span><br><span class="line">writeData  <span class="number">26</span></span><br><span class="line">readData 读到数据=<span class="number">16</span></span><br><span class="line">writeData  <span class="number">27</span></span><br><span class="line">readData 读到数据=<span class="number">17</span></span><br><span class="line">writeData  <span class="number">28</span></span><br><span class="line">readData 读到数据=<span class="number">18</span></span><br><span class="line">writeData  <span class="number">29</span></span><br><span class="line">readData 读到数据=<span class="number">19</span></span><br><span class="line">writeData  <span class="number">30</span></span><br><span class="line">readData 读到数据=<span class="number">20</span></span><br><span class="line">writeData  <span class="number">31</span></span><br><span class="line">readData 读到数据=<span class="number">21</span></span><br><span class="line">writeData  <span class="number">32</span></span><br><span class="line">readData 读到数据=<span class="number">22</span></span><br><span class="line">writeData  <span class="number">33</span></span><br><span class="line">readData 读到数据=<span class="number">23</span></span><br><span class="line">writeData  <span class="number">34</span></span><br><span class="line">readData 读到数据=<span class="number">24</span></span><br><span class="line">writeData  <span class="number">35</span></span><br><span class="line">readData 读到数据=<span class="number">25</span></span><br><span class="line">writeData  <span class="number">36</span></span><br><span class="line">readData 读到数据=<span class="number">26</span></span><br><span class="line">writeData  <span class="number">37</span></span><br><span class="line">readData 读到数据=<span class="number">27</span></span><br><span class="line">writeData  <span class="number">38</span></span><br><span class="line">readData 读到数据=<span class="number">28</span></span><br><span class="line">writeData  <span class="number">39</span></span><br><span class="line">readData 读到数据=<span class="number">29</span></span><br><span class="line">writeData  <span class="number">40</span></span><br><span class="line">readData 读到数据=<span class="number">30</span></span><br><span class="line">writeData  <span class="number">41</span></span><br><span class="line">readData 读到数据=<span class="number">31</span></span><br><span class="line">writeData  <span class="number">42</span></span><br><span class="line">readData 读到数据=<span class="number">32</span></span><br><span class="line">writeData  <span class="number">43</span></span><br><span class="line">readData 读到数据=<span class="number">33</span></span><br><span class="line">writeData  <span class="number">44</span></span><br><span class="line">readData 读到数据=<span class="number">34</span></span><br><span class="line">writeData  <span class="number">45</span></span><br><span class="line">readData 读到数据=<span class="number">35</span></span><br><span class="line">writeData  <span class="number">46</span></span><br><span class="line">readData 读到数据=<span class="number">36</span></span><br><span class="line">writeData  <span class="number">47</span></span><br><span class="line">readData 读到数据=<span class="number">37</span></span><br><span class="line">writeData  <span class="number">48</span></span><br><span class="line">readData 读到数据=<span class="number">38</span></span><br><span class="line">writeData  <span class="number">49</span></span><br><span class="line">readData 读到数据=<span class="number">39</span></span><br><span class="line">writeData  <span class="number">50</span></span><br><span class="line">readData 读到数据=<span class="number">40</span></span><br><span class="line">readData 读到数据=<span class="number">41</span></span><br><span class="line">readData 读到数据=<span class="number">42</span></span><br><span class="line">readData 读到数据=<span class="number">43</span></span><br><span class="line">readData 读到数据=<span class="number">44</span></span><br><span class="line">readData 读到数据=<span class="number">45</span></span><br><span class="line">readData 读到数据=<span class="number">46</span></span><br><span class="line">readData 读到数据=<span class="number">47</span></span><br><span class="line">readData 读到数据=<span class="number">48</span></span><br><span class="line">readData 读到数据=<span class="number">49</span></span><br><span class="line">readData 读到数据=<span class="number">50</span></span><br></pre></td></tr></table></figure></p>
<p>因为管道容量为10，所以写到11的时候，需要等待数据被读出才能写入，所以写数据12-50与读取是交错的，读取数据每隔一秒读取一次。最后数据全部写完，只需要读取数据。</p>
<h4 id="3、细节"><a href="#3、细节" class="headerlink" title="3、细节"></a>3、细节</h4><p>1、在默认情况下，管道是双向的，即可读可写<br>2、管道可以声明为只读或只写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管道声明为只写</span></span><br><span class="line"><span class="keyword">var</span> chan1 <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">chan1 &lt;- <span class="number">1</span> <span class="comment">//ok</span></span><br><span class="line">num1 := &lt;-chan1 <span class="comment">//error，无效的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管道声明为只读</span></span><br><span class="line"><span class="keyword">var</span> chan2 &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">num2 := &lt;-chan2 <span class="comment">//ok</span></span><br><span class="line">chan2 &lt;- <span class="number">2</span> <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>管道声明为只读或只写的应用场景：</p>
<ul>
<li>先声明一个双向管道intChan</li>
<li>声明两个函数，一个往intChan只写数据的send函数，一个往intChan只读数据的recv函数，防止误操作</li>
<li>可以将双向管道intChan作为实参，传给只写数据的send函数，send函数形参为<strong>ch chan&lt;- int</strong></li>
<li>可以将双向管道intChan作为实参，传给只读数据的recv函数，re函数形参为<strong>ch &lt;-chan int</strong></li>
<li>上面所述中，将双向管道作为实参传给单向管道（只读或只写）并不会报错。</li>
<li>管道的双向和单向只是管道的性质，但是管道的类型都是chan int，所以不会报错</li>
</ul>
<p>3、使用<strong>select</strong>可以解决<strong>从管道取数据的阻塞问题</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">//使用select可以解决从管道取数据的阻塞问题     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、定义一个管道 10个数据 int     </span></span><br><span class="line">    intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++  &#123;     </span><br><span class="line">         intChan&lt;-i     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、定义一个管道 5个数据，string     </span></span><br><span class="line">    stringChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">5</span>)    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span> ;i++  &#123;   </span><br><span class="line">         stringChan&lt;-<span class="string">"hello"</span>+fmt.Sprintf(<span class="string">"%d"</span>,i)  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统方法在遍历管道时，如果不关闭会阻塞并死锁deadlock   </span></span><br><span class="line">    <span class="comment">//但在实际开发中，我们往往不确定关闭管道的时机    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由此我们使用select解决      </span></span><br><span class="line">    <span class="keyword">for</span>&#123;          </span><br><span class="line">        <span class="keyword">select</span> &#123;          </span><br><span class="line">        <span class="comment">//重点：这里如果intChan一直没有关闭，不会一直阻塞而死锁，                </span></span><br><span class="line">        <span class="comment">//会自动到下一个case匹配         </span></span><br><span class="line">            <span class="keyword">case</span> v:=&lt;-intChan:              </span><br><span class="line">            fmt.Printf(<span class="string">"从intChan读取了数据%d\n"</span>,v)         </span><br><span class="line">            <span class="keyword">case</span> v:=&lt;-stringChan:                   </span><br><span class="line">            fmt.Printf(<span class="string">"从stringChan读取了数据%s\n"</span>,v)              </span><br><span class="line">            <span class="keyword">default</span>:                     </span><br><span class="line">            fmt.Printf(<span class="string">"都取不到了，加入处理逻辑\n"</span>)                    </span><br><span class="line">            <span class="keyword">return</span>        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">从stringChan读取了数据hello0</span><br><span class="line">从intChan读取了数据<span class="number">0</span></span><br><span class="line">从stringChan读取了数据hello1</span><br><span class="line">从stringChan读取了数据hello2</span><br><span class="line">从stringChan读取了数据hello3</span><br><span class="line">从intChan读取了数据<span class="number">1</span></span><br><span class="line">从intChan读取了数据<span class="number">2</span></span><br><span class="line">从stringChan读取了数据hello4</span><br><span class="line">从intChan读取了数据<span class="number">3</span></span><br><span class="line">从intChan读取了数据<span class="number">4</span></span><br><span class="line">从intChan读取了数据<span class="number">5</span></span><br><span class="line">从intChan读取了数据<span class="number">6</span></span><br><span class="line">从intChan读取了数据<span class="number">7</span></span><br><span class="line">从intChan读取了数据<span class="number">8</span></span><br><span class="line">从intChan读取了数据<span class="number">9</span></span><br><span class="line">都取不到了，加入处理逻辑</span><br></pre></td></tr></table></figure></p>
<p>4、<strong>goroutine中使用recover，解决协程中出现panic</strong>，导致程序崩溃问题</p>
<ul>
<li><p>如果我们起了一个协程，但是这个协程出现了panic，如果我们没有捕获这个panic，就会造成成哥程序的崩溃，</p>
</li>
<li><p>这时可以在该协程中使用recover来捕获panic进行处理。这样即使这个协程发生问题，主线程仍然不受影响，继续执行。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数sayHello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;           </span><br><span class="line">        time.Sleep(time.Second)    </span><br><span class="line">        fmt.Println(<span class="string">"hello world"</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="comment">//这里使用defer+recover解决panic终止程序    </span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;           </span><br><span class="line">    <span class="comment">//捕获test抛出的panic         </span></span><br><span class="line">        <span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span> &#123;            </span><br><span class="line">              fmt.Println(<span class="string">"test() 发生错误"</span>)   </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个map  </span></span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>     </span><br><span class="line">    myMap[<span class="number">0</span>]=<span class="string">"golang"</span><span class="comment">//空map直接赋值，报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="keyword">go</span> sayHello()    </span><br><span class="line">    <span class="keyword">go</span> test()   <span class="comment">//这个协程会panic 使用defer+recover解决</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;       </span><br><span class="line">        time.Sleep(time.Second)       </span><br><span class="line">        fmt.Println(<span class="string">"main() ok="</span>,i)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">test() 发生错误</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">0</span></span><br><span class="line">main() ok= <span class="number">1</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">2</span></span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">3</span></span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">4</span></span><br><span class="line">main() ok= <span class="number">5</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">6</span></span><br><span class="line">main() ok= <span class="number">7</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">8</span></span><br><span class="line">main() ok= <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>由输出看出，test协程出错，但是主线程和sayHello协程继续执行</p>
<h3 id="4、反射"><a href="#4、反射" class="headerlink" title="4、反射"></a>4、反射</h3><h4 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、反射的作用：</p>
<ul>
<li><p>1）、反射可以在运行时动态获取变量的各种信息，如变量的类型（type）、类别（kind）</p>
</li>
<li><p>2）、如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段、方法）</p>
</li>
<li><p>3）、通过反射，可以修改变量的值，可以调用关联的方法</p>
</li>
<li><p>4）、使用反射，需要import（“reflect”）</p>
</li>
</ul>
<p>reflect实现了运行时反射，允许程序操作任意类型的对象，典型用法是用静态类型interface{}保存一个值，通过<strong>调用TypeOf获取类型信息</strong>，该函数返回一个Type类型值，<strong>调用ValueOf函数返回一个value类型值</strong>，该值代表运行时数据，Zero接受一个Type类型参数并返回该类型零值的value类型值。</p>
<ul>
<li>5）、反射示意图</li>
</ul>
<p><img src="/2020/06/11/go-goroutine、channel、反射/reflect1.png" alt="reflect1"></p>
<p><strong>reflect.Type是一个接口</strong>，定义了非常多方法，通过这些方法可以反向操作变量，获取变量的各种信息</p>
<p><strong>reflect.Value是一个结构体</strong>，包含了非常多方法，可通过Type()方法将Value转换为Type、返回变量的字段和方法等等</p>
<ul>
<li>6）、变量、interface{}和reflect.Value是可以相互转换的<br><img src="/2020/06/11/go-goroutine、channel、反射/reflect2.png" alt="reflect2"></li>
</ul>
<h4 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h4><p>1、对基本数据类型、interface{}、reflect.Value进行反射的基本操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (     </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//通过反射获取传入变量的type、kind、值     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、先获取到reflect.Type     </span></span><br><span class="line">    rTyp := reflect.TypeOf(b)     </span><br><span class="line">    fmt.Println(<span class="string">"rTyp="</span>,rTyp)     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取到reflect.Value     </span></span><br><span class="line">    rVal := reflect.ValueOf(b)<span class="comment">//rVal=100      </span></span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)     </span><br><span class="line">    <span class="comment">//n:=rVal+2 </span></span><br><span class="line">    <span class="comment">//error，rVal的类型不是int，是reflect.Value，不能做运算    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、如果要做运算，如下      </span></span><br><span class="line">    n:=rVal.Int()+<span class="number">2</span>     </span><br><span class="line">    fmt.Println(<span class="string">"n="</span>,n)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、将rval转成interface&#123;&#125;      </span></span><br><span class="line">    iv:=rVal.Interface()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、将interface&#123;&#125;通过断言转成int(对应的类型)    </span></span><br><span class="line">    num2:=iv.(<span class="keyword">int</span>)     </span><br><span class="line">    fmt.Printf(<span class="string">"num2=%v num2的type=%T\n"</span>,num2,num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//1、定义一个int     </span></span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span>     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、反射</span></span><br><span class="line">    reflectTest01(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rTyp= <span class="keyword">int</span></span><br><span class="line">rVal=<span class="number">100</span> rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">n= <span class="number">102</span></span><br><span class="line">num2=<span class="number">100</span> num2的<span class="keyword">type</span>=<span class="keyword">int</span></span><br></pre></td></tr></table></figure></p>
<p>2、对结构体、interface{}、reflect.Value进行反射的基本操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Name <span class="keyword">string</span>     </span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对结构体反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest02</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//通过反射获取传入变量的type、kind、值     </span></span><br><span class="line">    <span class="comment">//1、先获取到reflect.Type   </span></span><br><span class="line">    rTyp := reflect.TypeOf(b)    </span><br><span class="line">    fmt.Println(<span class="string">"rTyp="</span>,rTyp)   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取到reflect.Value     </span></span><br><span class="line">    rVal := reflect.ValueOf(b)   </span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、获取变量对应的kind，两种方式等价</span></span><br><span class="line">    <span class="comment">//(1)通过获取到的reflect.Type来获取 =》rTyp.Kind()</span></span><br><span class="line">    kind1:=rTyp.Kind()</span><br><span class="line">    <span class="comment">//(2)通过获取到的reflect.Value来获取 =》rVal.Kind()</span></span><br><span class="line">   kind2:=rVal.Kind()</span><br><span class="line">   fmt.Printf(<span class="string">"kind1=%v kind2=%v\n"</span>,kind1,kind2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、将rval转成interface&#123;&#125;     </span></span><br><span class="line">    iv:=rVal.Interface()     </span><br><span class="line">    fmt.Printf(<span class="string">"iv=%v iv的type=%T\n"</span>,iv,iv)  </span><br><span class="line">    <span class="comment">//输出：iv=&#123;tom 20&#125; iv的type=main.Student   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、iv的type=main.Student，但是通过iv取字段会报错     </span></span><br><span class="line">    <span class="comment">//iv.Name     </span></span><br><span class="line">    <span class="comment">//error 因为编译器在编译阶段无法知道iv的类型是main.Student，只有运行时才知道     </span></span><br><span class="line">    <span class="comment">//所以这里直接编译报错    </span></span><br><span class="line">    <span class="comment">//反射是在程序运行时工作的    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、将interface&#123;&#125;通过断言转成int(对应的类型)    </span></span><br><span class="line">    stu:=iv.(Student)    </span><br><span class="line">    <span class="keyword">if</span> ok &#123;     </span><br><span class="line">        fmt.Printf(<span class="string">"stu=%v stu的type=%T\n"</span>,stu,stu)    </span><br><span class="line">        fmt.Printf(<span class="string">"stu.Name=%v stu.Age=%v\n"</span>,stu.Name,stu.Age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//1、定义一个student实例   </span></span><br><span class="line">    stu:=Student&#123;<span class="string">"tom"</span>,<span class="number">20</span>&#125;     </span><br><span class="line">    <span class="comment">//2、反射   </span></span><br><span class="line">    reflectTest02(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rTyp= main.Student</span><br><span class="line">rVal=&#123;tom <span class="number">20</span>&#125; rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">kind1=<span class="keyword">struct</span> kind2=<span class="keyword">struct</span></span><br><span class="line">iv=&#123;tom <span class="number">20</span>&#125; iv的<span class="keyword">type</span>=main.Student</span><br><span class="line">stu=&#123;tom <span class="number">20</span>&#125; stu的<span class="keyword">type</span>=main.Student</span><br><span class="line">stu.Name=tom stu.Age=<span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h4><p>1、reflect.Value.Kind()，获取变量的类别，返回一个常量。type是一个大范畴，kind在type上细分（如type只返回int，kind返回具体的int32，int64的常量定义的值等）<br>在上面的例子中有：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、获取变量对应的kind，两种方式等价</span></span><br><span class="line">    <span class="comment">//(1)通过获取到的reflect.Type来获取 =》rTyp.Kind()</span></span><br><span class="line">    kind1:=rTyp.Kind()</span><br><span class="line">    <span class="comment">//(2)通过获取到的reflect.Value来获取 =》rVal.Kind()</span></span><br><span class="line">   kind2:=rVal.Kind()</span><br><span class="line">   fmt.Printf(<span class="string">"kind1=%v kind2=%v\n"</span>,kind1,kind2)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kind1=<span class="keyword">struct</span> kind2=<span class="keyword">struct</span></span><br></pre></td></tr></table></figure></p>
<p>2、Type和Kind的区别：Type是类型，Kind是类别，<strong>Type和Kind可能相同也可能不同</strong></p>
<ul>
<li>var num int = 10 num的Type是int，Kind也是int</li>
<li>var stu Student   stu的Type是<strong>包名.Student</strong>，Kind是struct</li>
</ul>
<p>3、变量、interface{}和reflect.Value是可以相互转换的</p>
<p>4、使用反射的方式来获取变量的值（并返回对应的类型），要求数据类型匹配，如x是int，那么就应该用reflect.ValueOf(x).Int()，不能使用其他，否则panic</p>
<p>5、通过反射修改变量的值，注意当使用SetXXX方法来修改变量的值，需要通过变量对应的指针来修改，这时需要使用reflect.Value.Elem()方法</p>
<ul>
<li><p>func (v Value) SetXXX(x XXX)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">SetXXX</span><span class="params">(x XXX)</span></span> </span><br><span class="line"><span class="comment">//SetXXX方法是和Value类型绑定的方法，不能用指针类型去调用它，只能把指针类型再转为Value类型，使用Elem函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>func (v Value) Elem() Value   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"> <span class="comment">//重点：Elem返回v持有的接口保管的值的Value类型封装，或持有的指针指向的值的Value类型封装</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line"><span class="string">"fmt"</span>    </span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改反射变量的值    </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;    </span><br><span class="line">    <span class="comment">//1、获取到reflect.Value  </span></span><br><span class="line">    rVal := reflect.ValueOf(b)<span class="comment">//rVal=100    </span></span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)  </span><br><span class="line">    <span class="comment">//main函数中调用函数时传的是地址，rVal的值为一个地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取rVal的Kind    </span></span><br><span class="line">    rKind:=rVal.Kind()  </span><br><span class="line">    fmt.Printf(<span class="string">"rVal Kind=%v\n"</span>,rKind)   </span><br><span class="line">    <span class="comment">//输出：rVal Kind=ptr，</span></span><br><span class="line">    <span class="comment">//rVal的Kind是指针，因为main函数中调用函数时传的是地址     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、通过SetXXX修改变量的值    </span></span><br><span class="line">    <span class="comment">//rVal.SetInt(20) //error   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//func (v Value) SetXXX(x XXX)，  </span></span><br><span class="line">    <span class="comment">//SetXXX方法是和Value类型绑定的方法，不能用指针类型去调用它    </span></span><br><span class="line">    <span class="comment">//只能把指针类型再转为Value类型，使用Elem函数    </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//func (v Value) Elem() Value   </span></span><br><span class="line">    <span class="comment">//Elem返回v持有的接口保管的值的Value类型封装，或持有的指针指向的值的Value类型封装     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、通过Elem()获取到指针指向的值，再通过SetXXX修改变量的值     </span></span><br><span class="line">    rVal.Elem().SetInt(<span class="number">20</span>)    <span class="comment">//值修改为20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;     </span><br><span class="line">    <span class="comment">//1、定义一个int    </span></span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span>     </span><br><span class="line">    <span class="comment">//2、反射    </span></span><br><span class="line">    reflectTest01(&amp;num)<span class="comment">//修改变量num的值，所以要穿num的地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、打印修改后的num</span></span><br><span class="line">    fmt.Println(<span class="string">"num="</span>,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rVal=<span class="number">0xc000060058</span> rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">rVal Kind=ptr</span><br><span class="line">num= <span class="number">20</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/" data-id="ckcpzrdox000ssovihyqglrpe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go-文件操作、json" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-文件操作、json/" class="article-date">
  <time datetime="2020-06-11T07:54:54.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/go-文件操作、json/">go:文件操作、json</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、文件操作"><a href="#1、文件操作" class="headerlink" title="1、文件操作"></a>1、文件操作</h3><h4 id="1、基本认识"><a href="#1、基本认识" class="headerlink" title="1、基本认识"></a>1、基本认识</h4><p>1、文件在程序中是以 <strong>流</strong> 的形式来操作的</p>
<ul>
<li>流：数据在数据源（文件）和程序（内存）之间经历的路径</li>
<li>输入流：数据从数据源（文件）到程序（内存）之间的路径</li>
<li>输出流：数据从程序（内存）到数据源（文件）之间的路径</li>
</ul>
<p><img src="/2020/06/11/go-文件操作、json/file1.png" alt="file1"></p>
<p>2、GO中，os.File封装所有文件相关操作（方法），File是一个结构体</p>
<p>3、<strong>文件是引用类型</strong></p>
<h4 id="2、文件操作"><a href="#2、文件操作" class="headerlink" title="2、文件操作"></a>2、文件操作</h4><h5 id="1、打开文件"><a href="#1、打开文件" class="headerlink" title="1、打开文件"></a>1、打开文件</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(file *File,err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Open打开一个文件用于读取，如果操作成功，返回一个文件对象（结构体指针或者文件句柄）可用于读取数据；如果出错，错误底层类型是PathError</p>
<h5 id="2、关闭文件"><a href="#2、关闭文件" class="headerlink" title="2、关闭文件"></a>2、关闭文件</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File )</span> <span class="title">Close</span> <span class="params">(error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Close关闭文件f，用于读取，使文件不能用于读写。返回可能出现的错误</p>
<p>案例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.Open(<span class="string">"d:/test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出文件</span></span><br><span class="line">    fmt.Printf(<span class="string">"file=%v"</span>,file)<span class="comment">//输出 file=&amp;&lt;0xcXXXXXXXX&gt;，</span></span><br><span class="line">    <span class="comment">//看出文件是一个地址（指针）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    err = file.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"close file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3、读文件操作应用实例"><a href="#3、读文件操作应用实例" class="headerlink" title="3、读文件操作应用实例"></a>3、读文件操作应用实例</h5><p>1、读取文件的内容并显示在终端（<strong>带缓冲区</strong>的方式）<br>os.Open()、 file.Close()、bufio.NewReader()<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.Open(<span class="string">"d:/test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当函数退出时，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个 *Reader，是带缓冲的</span></span><br><span class="line">    <span class="comment">//默认缓冲4096个字节</span></span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环读取文件的内容</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        str ,err :=  reader.ReadString(<span class="string">"\n"</span>)<span class="comment">//读到一个换行就结束一次</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;<span class="comment">//io.EOF表示文件的末尾</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//输出内容</span></span><br><span class="line">         fmt.Print(str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件读取结束</span></span><br><span class="line">     fmt.Println(<span class="string">"文件读取结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、读取文件的内容并显示在终端（使用ioutil一次性将整个文件读入到内存中），这种方式适合文件不大的情况 。</p>
<ul>
<li>这种方式不用显示的Open和Close文件，因为文件的Open和Close被封装到ReadFile函数内部</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file = <span class="string">"d:/test.txt"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用ioutil.ReadFile一次性将文件读取完</span></span><br><span class="line">    content,err := ioutil.ReadFile(file)<span class="comment">//返回一个[]byte（byt切片）</span></span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"read file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把读取的文件内容显示到终端</span></span><br><span class="line">    fmt.Printf(<span class="string">"content=%v"</span>,content)<span class="comment">//这是一个[]byte</span></span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">"content=%v"</span>,<span class="keyword">string</span>(content))<span class="comment">//[]byte转成string输出</span></span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4、写文件操作应用实例"><a href="#4、写文件操作应用实例" class="headerlink" title="4、写文件操作应用实例"></a>4、写文件操作应用实例</h5><p>1、基本介绍<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(path <span class="keyword">string</span>,flag <span class="keyword">int</span>,perm FileMode)</span> <span class="params">(file *File,err error)</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>path：要打开文件的路径</li>
<li>flag：打开文件的方式</li>
<li>perm：文件权限，Windows系统下无效，Unix和Linux下有效</li>
</ul>
<h6 id="1、实例一"><a href="#1、实例一" class="headerlink" title="1、实例一"></a>1、实例一</h6><p> 带缓冲bufio.NewWriter</p>
<p>1）创建一个<strong>新文件</strong>，<strong>写入</strong>内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_WRONLY | os.O_CREATE,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以只写方式打开，如果没有文件就创建一个，如果有就继续往下</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入内容</span></span><br><span class="line">    str := <span class="string">"要写入的内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2）打开一个<strong>已经存在</strong>的文件，将原来的内容<strong>覆盖</strong>成新的内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_WRONLY | os.O_TRUNC,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以只写方式打开，如果文件已经有内容就清空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入要覆盖的新内容</span></span><br><span class="line">    str := <span class="string">"写入要覆盖的新内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3）打开一个<strong>已经存在</strong>的文件，在原来的内容<strong>追加</strong>新的内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_WRONLY | os.O_APPEND,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以只写方式打开，在文件末尾以追加的形式写入内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入要追加写入的新内容</span></span><br><span class="line">    str := <span class="string">"追加写入的新内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4）打开一个已经存在的文件，将原来的内容<strong>读出</strong>显示在终端，并<strong>追加</strong>新的内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_RDWR | os.O_APPEND,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以读写方式打开，在文件末尾以追加的形式写入内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先读取文件原来的内容，并显示在终端</span></span><br><span class="line">     <span class="comment">//创建一个 *Reader，是带缓冲的</span></span><br><span class="line">    <span class="comment">//默认缓冲4096个字节</span></span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环读取文件的内容</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        str ,err :=  reader.ReadString(<span class="string">"\n"</span>)<span class="comment">//读到一个换行就结束一次</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;<span class="comment">//io.EOF表示文件的末尾</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//输出内容，显示在终端</span></span><br><span class="line">         fmt.Print(str)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入要追加写入的新内容</span></span><br><span class="line">    str := <span class="string">"第二次追加写入的新内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="2、实例二"><a href="#2、实例二" class="headerlink" title="2、实例二"></a>2、实例二</h6><p>将一个文件的内容，写入到另外一个文件。（两个文件已经存在）<br>ioutil.ReadFile/ioutil.WriteFile<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将”d:/test.txt“文件内容导入到”e:/kkk.txt“</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1、将”d:/test.txt“文件内容读取到内存</span></span><br><span class="line">    <span class="comment">//2、将读取到的内容写入”e:/kkk.txt“</span></span><br><span class="line">    </span><br><span class="line">      file1Path = <span class="string">"d:/test.txt"</span></span><br><span class="line">      file2Path = <span class="string">"e:/kkk.txt"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用ioutil.ReadFile一次性将文件读取完</span></span><br><span class="line">    data,err := ioutil.ReadFile(file1Path)<span class="comment">//返回一个[]byte（byt切片）</span></span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"read file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把读取的文件内容显写入e:/kkk.txt文件</span></span><br><span class="line">    err = ioutil.WriteFile(file2Path,data,<span class="number">0666</span>)<span class="comment">//data接收一个[]byte</span></span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"write file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5、判断文件或文件夹是否存在"><a href="#5、判断文件或文件夹是否存在" class="headerlink" title="5、判断文件或文件夹是否存在"></a>5、判断文件或文件夹是否存在</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(filePath <span class="keyword">string</span>)</span> <span class="params">(fi FileInfo,err error)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果返回的error为nil，说明文件或文件夹存在</li>
<li>如果返回的error使用为os.IsNotExist判断为true，说明文件或文件夹不存在</li>
<li>如果返回的error为其他类型，则不确定是否存在</li>
</ul>
<h3 id="2、json"><a href="#2、json" class="headerlink" title="2、json"></a>2、json</h3><p>1、JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。易于人阅读和编写，也易于机器解析和生成，并有效提升网络效率。</p>
<p>2、json序列化（如struct、map、slice序列化成json字符串）<br>json.Marshal()序列化后是一个[]byte，要转string<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span>    </span><br><span class="line">    Birthday  <span class="keyword">string</span>    </span><br><span class="line">    Sal <span class="keyword">float64</span>    </span><br><span class="line">    Skill <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monster := Monster&#123;</span><br><span class="line">        Name:<span class="string">"牛魔王"</span>,            </span><br><span class="line">        Age:<span class="number">500</span>,            </span><br><span class="line">        Birthday:<span class="string">"2011-11-11"</span>,           </span><br><span class="line">        Sal:<span class="number">8000.0</span>,            </span><br><span class="line">        Skill:<span class="string">"牛魔拳"</span>,      </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line"><span class="comment">//将monster序列化     </span></span><br><span class="line">data,err:=json.Marshal(&amp;monster)      </span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;            </span><br><span class="line">    fmt.Printf(<span class="string">"序列化失败 err=%v\n"</span>,err)     </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出序列化后的结果     </span></span><br><span class="line">    <span class="comment">//json.Marshal(&amp;monster)序列化后是一个[]byte，要转string      </span></span><br><span class="line">    fmt.Printf(<span class="string">"序列化后的结果monster=%v"</span>,<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testStruct()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序列化后的结果monster=&#123;<span class="string">"Name"</span>:<span class="string">"牛魔王"</span>,<span class="string">"Age"</span>:<span class="number">500</span>,<span class="string">"Birthday"</span>:<span class="string">"2011-11-11"</span>,<span class="string">"Sal"</span>:<span class="number">8000</span>,<span class="string">"Skill"</span>:<span class="string">"牛魔拳"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：也可以对基本数据类型进行序列化，序列化结果直接将基本数据类型转成string，但是对基本数据类型进行序列化一般没有意义。</p>
<p>3、json反序列化（如将json反序列化成struct、map、slice）<br>json.Unmarshal([]byte(str),&amp;monster)第一个参数要传一个[]byte<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span> </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span>    </span><br><span class="line">    Age <span class="keyword">int</span>    </span><br><span class="line">    Birthday  <span class="keyword">string</span>     </span><br><span class="line">    Sal <span class="keyword">float64</span>    </span><br><span class="line">    Skill <span class="keyword">string</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unSerialStruct</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    str:=<span class="string">"&#123;\"Name\":\"牛魔王\",\"Age\":500,\"Birthday\":\"2011-11-11\","</span> +            <span class="string">"\"Sal\":8000,\"Skill\":\"牛魔拳\"&#125;"</span>     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个Monster实例      </span></span><br><span class="line">    <span class="keyword">var</span> monster Monster      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//json.Unmarshal([]byte(str),&amp;monster)第一个参数要传一个[]byte     </span></span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str),&amp;monster)</span><br><span class="line">    <span class="comment">//传地址才能改变var monster的值</span></span><br><span class="line">      <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123; </span><br><span class="line">         fmt.Printf(<span class="string">"反序列化失败 err=%v\n"</span>,err)    </span><br><span class="line">      &#125;      </span><br><span class="line">      </span><br><span class="line">      fmt.Printf(<span class="string">"反序列化后的结果monster=%v"</span>,monster)</span><br><span class="line"> &#125;</span><br><span class="line">      </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">        unSerialStruct()  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反序列化后的结果monster=&#123;牛魔王 <span class="number">500</span> <span class="number">2011</span><span class="number">-11</span><span class="number">-11</span> <span class="number">8000</span> 牛魔拳&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-文件操作、json/" data-id="ckcpzrdp5000vsoviextb9szb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/" class="article-date">
  <time datetime="2020-06-11T07:35:04.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/">go:结构体、方法、工厂模式、OOP三大特性、类型断言、接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="面向对象-结构体"><a href="#面向对象-结构体" class="headerlink" title="面向对象-结构体"></a>面向对象-结构体</h3><p>1、GO支持面向对象编程（OOP），但不是纯粹的面向对象编程语言，更准确地说是<strong>GO支持面向对象编程特性</strong><br>2、GO没有类的概念，结构体（struct）来实现OOP<br>3、GO面向对象编程非常简洁，去掉传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等<br>4、Go仍然有面向对象编程的继承、封装和多态的特性，只是实现方式不一样。<br>5、GO面向对象（OOP）很优雅，OOP本身就是语言类型系统的一部分（Go天然支持OOP），通过接口（interface）关联，耦合性低，非常灵活。<br>6、GO更准确的说是<strong>面向接口编程</strong></p>
<h5 id="1、结构体变量在内存中的布局"><a href="#1、结构体变量在内存中的布局" class="headerlink" title="1、结构体变量在内存中的布局"></a>1、结构体变量在内存中的布局</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Color <span class="keyword">string</span></span><br><span class="line">    Hobby <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个结构体cat变量</span></span><br><span class="line">vat cat1 Cat</span><br><span class="line">cat.Name = <span class="string">"小白"</span></span><br><span class="line">cat.Age = <span class="number">3</span></span><br><span class="line">cat.Color = <span class="string">"白色"</span></span><br><span class="line">cat.Hobby = <span class="string">"吃鱼"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"cat1="</span>,cat1)</span><br></pre></td></tr></table></figure>
<p>结构体是自定义的数据类型(如Cat)，结构体变量（实例）是具体的、实际的一个变量(如cat1)</p>
<p>结构体实例在内存中的布局，以cat1为例<br>1、当代码执行到“var cat1 Cat”时，cat1指向一个结构体，这时还没有给结构体的各个字段赋值，所以各个字段为默认值<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/struct1.jpg" alt="struct1"></p>
<p>2、结构体有一个自己的地址，cat1直接指向一个结构体的数据空间，而不是结构体的地址，所以<strong>结构体是值类型</strong></p>
<p>3、赋值语句为结构体的字段赋值<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/struct2.jpg" alt="struct2"></p>
<p>总结：</p>
<ul>
<li>当我们声明一个结构体变量时，结构体的数据空间已经有了，且结构体的每个字段已有<strong>默认值</strong></li>
<li>声明结构体变量后，该变量指向一个结构体的数据空间，而不是该结构体数据空间的地址，所以结构体是<strong>值类型</strong></li>
</ul>
<h5 id="2、结构体声明"><a href="#2、结构体声明" class="headerlink" title="2、结构体声明"></a>2、结构体声明</h5><p>1、在创建一个变量后，如果没有给字段赋值，系统会赋零值</p>
<ul>
<li>基本数据类型赋零值</li>
<li><strong>引用类型：slice、map、指针的零值是nil，即没有分配内存空间</strong></li>
<li>数组类型的默认值与元素相关</li>
</ul>
<p>2、不同结构体变量的字段你是独立的，互不影响。因为结构体是值类型、默认是值拷贝</p>
<h5 id="3、创建结构体实例的4种方式"><a href="#3、创建结构体实例的4种方式" class="headerlink" title="3、创建结构体实例的4种方式"></a>3、创建结构体实例的4种方式</h5><p>1、直接声明<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vat person Person</span><br><span class="line">person.field1 = value1</span><br><span class="line">person.field2 = value2</span><br><span class="line">person.field3 = value3</span><br></pre></td></tr></table></figure></p>
<p>2、声明时直接为字段赋值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vat person Person = Person&#123;</span><br><span class="line">    field1:value1</span><br><span class="line">    field2:value2</span><br><span class="line">    field3:value3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、通过new函数创建，创建对象是一个指向该结构体的指针<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vat person *Person = <span class="built_in">new</span>(Person)</span><br><span class="line"><span class="comment">//person是一个指针，标准赋值方式如下</span></span><br><span class="line">(*person).field1 = value1  </span><br><span class="line">(*person).field2 = value2</span><br><span class="line">(*person).field3 = value3</span><br><span class="line"><span class="comment">//运算符优先级："." &gt; "*"，所以需要括号(*person).field1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可简写为</span></span><br><span class="line">person.field1 = value1</span><br><span class="line">person.field2 = value2</span><br><span class="line">person.field3 = value3</span><br><span class="line"></span><br><span class="line"><span class="comment">//GO的设计者为了使用方便，底层会对简写写法person.field1 = value1进行处理，会给person加上取值运算 (*person).field1 = value1</span></span><br></pre></td></tr></table></figure></p>
<p>4、vat person *Person = &amp;Person{}，可以直接再{}中赋值，如方式2，也可如下赋值，如方式3<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    vat person *Person = &amp;Person&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person是一个指针，标准赋值方式如下</span></span><br><span class="line">    (*person).field1 = value1</span><br><span class="line">    (*person).field2 = value2</span><br><span class="line">    (*person).field3 = value3</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可简写为</span></span><br><span class="line">    person.field1 = value1</span><br><span class="line">    person.field2 = value2</span><br><span class="line">    person.field3 = value3</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GO的设计者为了使用方便，底层会对简写写法person.field1 = value1进行处理，会给person加上取值运算 (*person).field1 = value1</span></span><br></pre></td></tr></table></figure></p>
<p>总结:</p>
<ul>
<li>方式3和方式4返回的是一个<strong>结构体指针</strong></li>
</ul>
<h5 id="4、结构体内细节"><a href="#4、结构体内细节" class="headerlink" title="4、结构体内细节"></a>4、结构体内细节</h5><p>1、<strong>结构体中所有字段在内存中是连续分布的</strong><br>2、当结构体的字段是指针时，指针本身的地址是连续的，但是指针指向的地址指值不一定连续<br>3、结构体使用户单独定义的类型，和其它类型转换时，需要有完全相同的字段（名字、个数和累型）<br>4、结构体进行type重新定义（相当于取别名），Go认为是<strong>新的数据类型</strong>，但是相互间可以强转<br>5、在结构体的每个字段上，可以写上一个<strong>tag</strong>，该tag可以通过<strong>反射机制</strong>获取，常见的使用场景就是<strong>序列化</strong>和<strong>反序列化</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age <span class="keyword">int</span> <span class="string">`json:"age"`</span></span><br><span class="line">    Skill <span class="keyword">string</span> <span class="string">`json:"skill"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">monster := Monster&#123;</span><br><span class="line">    <span class="string">"牛魔王"</span>，</span><br><span class="line">    <span class="number">500</span>，</span><br><span class="line">    “牛头拳”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将monster变量序列化为json字符串（反射机制）</span></span><br><span class="line">jsonStr,err := json.Marshal(monster)<span class="comment">//返回值为[]byte切片</span></span><br><span class="line"><span class="comment">//这里json包去访问monster中的字段，如果字段小写则访问不到，字段小写表示只能当前包内访问，则只能大写。但是大写，json格式化后json串中也是大写，与前端命名习惯不一致，所以可以用tag为字段取别名成小写形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"json处理错误"</span>，err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"jsonStr"</span>,<span class="keyword">string</span>(jsonStr))</span><br></pre></td></tr></table></figure></p>
<h3 id="方法method"><a href="#方法method" class="headerlink" title="方法method"></a>方法method</h3><p>1、Go中方法是<strong>作用在指定的数据类型上</strong>的（和指定数据类型绑定），因此自定义类型，都可以有方法（不仅是struct）。</p>
<p>2、方法的声明与调用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="comment">//A结构体有一个方法test，说明test方法和结构体（类型）A绑定，test方法只能被A的对象来调用</span></span><br><span class="line"></span><br><span class="line">    a.Num=<span class="number">2</span> <span class="comment">//这里的改变不会影响main函数中的赋值输出，因为struct是值类型，func (a A)这里不是指针。</span></span><br><span class="line">    fmt.Println(a.Num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a A </span><br><span class="line">    a.Num=<span class="number">1</span></span><br><span class="line">    a.test()<span class="comment">//调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   由上述代码有：</p>
<ul>
<li>1、test方法和A类型绑定</li>
<li>2、test方法只能通过A的实例来调用，<strong>不能直接调用</strong>，也不能用其他类型调用</li>
<li><strong>3</strong>、func (a A) test()，<strong>a表示哪个A实例调用，他就是该实例的副本</strong>，和函数传参类似，由于<strong>struct是值类型</strong>，func (a A)这里不是指针，所以方法中对字段重新赋值不会影响main函数中的值</li>
</ul>
<h4 id="方法的调用和传参机制"><a href="#方法的调用和传参机制" class="headerlink" title="方法的调用和传参机制"></a>方法的调用和传参机制</h4><p><strong>重点</strong>：方法的调用和传参机制和函数基本一样，不一样的地方是方法调用时，<strong>会将调用方法的实例变量，当作实参也传递给方法</strong></p>
<p>示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">getSum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p Person </span><br><span class="line">    p.Name = <span class="string">"tom"</span></span><br><span class="line">    </span><br><span class="line">    n1 := <span class="number">10</span></span><br><span class="line">    n2 := <span class="number">20</span></span><br><span class="line">    res := p.getSum(n1,n2)<span class="comment">//调用方法</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1、main函数中执行“n1 := 10 n2 := 20”时，内存中开辟main栈并压入变量n1和n2<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method1.png" alt="method1"></p>
<p>2、main函数执行 “ res := p.getSum(n1,n2)”时：</p>
<ul>
<li>先执行“p.getSum(n1,n2)”，内存中开辟getSum栈，并将n1和n2的值拷贝到getSum栈中，同时将结构体实例p值拷贝到getSum栈中（因为结构体实例p调用方法getSum），因为这里传的是“func (p Person)”，所以是值拷贝，所以main栈和getSum栈是完全独立的数据空间。若传指针则为引用传递<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method2.png" alt="method2"></li>
</ul>
<ul>
<li>然后执行赋值给res变量“res := p.getSum(n1,n2)”，main栈中压入res变量，res变量的值有函数getSum返回<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method3.png" alt="method3"></li>
</ul>
<p>注意：<strong>如果一个类型（结构体）实现了String()这个方法，fmt.Println默认会调用这个结构体变量的String()方法输出</strong></p>
<h4 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h4><p>1、调用方式不一样</p>
<ul>
<li>函数的调用方式：函数名（实参列表）</li>
<li>方法的调用方式：绑定类型变量.方法名（实参列表）</li>
</ul>
<p>2、对于普通函数，接收者为值类型时，不能将指针类型数据直接传递，反之亦然</p>
<p>3、对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反之亦然<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">       Name <span class="keyword">string</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">       p.Name = <span class="string">"jack"</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//jack</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">test01</span><span class="params">()</span></span> &#123;</span><br><span class="line">       p.Name = <span class="string">"marry"</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//marry</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">var</span> p Person </span><br><span class="line">       p.Name = <span class="string">"tom"</span></span><br><span class="line">       </span><br><span class="line">       p.test() <span class="comment">//ok</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//tom</span></span><br><span class="line">       </span><br><span class="line">       (&amp;p).test()  <span class="comment">//用p的地址（指针）调也可以，但仍然是值拷贝，只是形式上看是引用拷贝，但是接受的地方“func (p Person)”是传值，所以底层会处理为“p.test()”，只有接受的地方为传地址（如 func (p *Person)），才是引用传递</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//tom</span></span><br><span class="line">       </span><br><span class="line">       (&amp;p).test01()<span class="comment">//ok</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name)<span class="comment">//marry</span></span><br><span class="line">       </span><br><span class="line">       p.test01()<span class="comment">//ok，等价于(&amp;p).test01()，底层处理，形式上传值，实际传地址，因为接受的地方为传地址（如 func (p *Person)）</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name)<span class="comment">//marry </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>针对第3条总结</strong>：<strong>重点重点</strong><br>不管调用的形式如何，真正决定是值拷贝还是地址拷贝，看定义这个方法时跟哪个类型绑定，若跟指针（如 p *Person）绑定则为地址拷贝，若跟值类型（如 p Person）绑定则为值拷贝</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>1、GO的结构体没有<strong>构造函数</strong>，通常使用工厂模式来解决</p>
<ul>
<li>使用工厂模式实现跨包创建结构体实例</li>
</ul>
<p>1）model包下有结构体Student<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model </span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> student <span class="keyword">struct</span>&#123;</span><br><span class="line"> <span class="comment">//这里结构体定义为小写student，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Score <span class="keyword">float64</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//使用工厂模式</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>,score <span class="keyword">float64</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">          Name : name,</span><br><span class="line">          Score : score,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>2）main包下使用工厂模式创建结构体student实例<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"factory/model"</span></span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用工厂模式创建student实例</span></span><br><span class="line">    <span class="keyword">var</span> stu = model.NewStudent(<span class="string">"tom"</span>,<span class="number">88.8</span>)<span class="comment">//返回值为一个指针</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu) <span class="comment">//输出&amp;&#123;tom 88.8&#125;</span></span><br><span class="line">   fmt.Println(*stu) <span class="comment">//输出&#123;tom 88.8&#125;</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu.Name) <span class="comment">//等价于(*stu).Name 输出tom</span></span><br><span class="line">   fmt.Println(stu.Score) <span class="comment">//等价于(*stu).Score 输出88.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果结构体中的字段也是小写，只能在定义结构体的包中使用，其他包不可访问，同理可以为结构体绑定一个公有方法，用于返回字段<br>1）model包下有结构体Student<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model </span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> student <span class="keyword">struct</span>&#123;</span><br><span class="line"> <span class="comment">//这里结构体定义为小写student，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        score <span class="keyword">float64</span></span><br><span class="line"> <span class="comment">//这里字段score定义为小写，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//使用工厂模式</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>,score <span class="keyword">float64</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">          Name : name,</span><br><span class="line">          score : score,<span class="comment">//该包内可以访问小写字段，其他包不可以</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//GetScore方法绑定结构体，返回字段score</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">GetScore</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.score</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2）main包下使用工厂模式创建结构体student实例<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"factory/model"</span></span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用工厂模式创建student实例</span></span><br><span class="line">    <span class="keyword">var</span> stu = model.NewStudent(<span class="string">"tom"</span>,<span class="number">88.8</span>)<span class="comment">//返回值为一个指针</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu) <span class="comment">//输出&amp;&#123;tom 88.8&#125;</span></span><br><span class="line">   fmt.Println(*stu) <span class="comment">//输出&#123;tom 88.8&#125;</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu.Name) <span class="comment">//等价于(*stu).Name 输出tom</span></span><br><span class="line">   fmt.Println(stu.GetScore()) <span class="comment">//输出88.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="面向对象编程三大特性"><a href="#面向对象编程三大特性" class="headerlink" title="面向对象编程三大特性"></a>面向对象编程三大特性</h3><p>面向对象编程三大特性：<strong>封装、继承、多态</strong>。</p>
<h4 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h4><p>1、封装：把<strong>抽象出来的字段和对字段的操作封装在一起</strong>，数据就被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作</p>
<p>2、封装的优点</p>
<ul>
<li>隐藏实现的细节</li>
<li>提供方法可以对数据进行验证、保证安全合理</li>
</ul>
<p>3、如何体现封装</p>
<ul>
<li>对结构体中的属性进行封装</li>
<li>通过方法、包实现封装</li>
</ul>
<p>4、封装的实现<br>参考上一个笔记，工厂模式（将结构体、属性定义为包私有，通过公有方法访问）</p>
<h4 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h4><p>继承可以<strong>解决代码复用</strong>，提高扩展性、可维护性<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/oop1.jpg" alt="oop1"><br>GO使用在一个结构体中<strong>嵌套匿名结构体</strong>的方式来实现继承<br>案例：<br>1、抽取共有字段和方法，创建一个结构体Student<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">      Name <span class="keyword">string</span></span><br><span class="line">      Age <span class="keyword">int</span></span><br><span class="line">      Score <span class="keyword">float64</span>     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//共有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">ShowInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"学生名=%v年龄=%v 成绩=%v           \n"</span>,stu.Name,stu.Age,stu.Score)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">SetScore</span><span class="params">(score <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">       stu.Score = score</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>2、创建结构体Pupil<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pupil <span class="keyword">struct</span>&#123;</span><br><span class="line">      Student    <span class="comment">//嵌入Student匿名结构体</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Pupil特有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(p *Pupil)</span> <span class="title">testing</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"小学生正在考试中"</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>3、创建结构体Graduate<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Graduate <span class="keyword">struct</span>&#123;</span><br><span class="line">      Student    <span class="comment">//嵌入Student匿名结构体</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Graduate特有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(g *Graduate)</span> <span class="title">testing</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"大学生正在考试中"</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>4、main创建实例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//当我们对结构体嵌入了匿名结构体后，使用方法发生了变化</span></span><br><span class="line">     <span class="comment">//创建一个Pupil实例</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Student.Name = <span class="string">"tom"</span></span><br><span class="line">     pupil.Student.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.Student.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//创建一个Graduate实例</span></span><br><span class="line">     graduate := &amp;Graduate&#123;&#125;</span><br><span class="line">     graduate.Student.Name = <span class="string">"marry"</span></span><br><span class="line">     graduate.Student.Age = <span class="number">8</span></span><br><span class="line">     graduate.testing()</span><br><span class="line">     graduate.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     graduate.Student.ShowInfo()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="继承细节"><a href="#继承细节" class="headerlink" title="继承细节"></a>继承细节</h5><p>1、结构体可以使用嵌套匿名结构体的<strong>所有字段和方法</strong>，即：首字母大写和小写的字段和方法都可以使用</p>
<p>2、访问匿名结构体字段可以简化<br>在上述案例中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//当我们对结构体嵌入了匿名结构体后，使用方法发生了变化</span></span><br><span class="line">     <span class="comment">//创建一个Pupil实例</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Student.Name = <span class="string">"tom"</span></span><br><span class="line">     pupil.Student.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.Student.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//创建Pupil实例，访问Pupil结构体中的匿名结构体Student的字段和方法可以简化为</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Name = <span class="string">"tom"</span></span><br><span class="line">     pupi.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//pupil.Student.Name = "tom" 等价于pupil.Name = "tom"，</span></span><br><span class="line">    <span class="comment">// pupil.Name 先去pupil找Name字段，如果没有，再去Pupil结构体中的匿名结构体Student找字段Name</span></span><br><span class="line">    <span class="comment">//如果找到则访问，否则报错</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>3、当结构体和匿名结构体有相同的字段或方法时，编译器采用<strong>就近访问原则</strong>访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体来区分<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">SayOk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"A SayOK"</span>,a.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"A hello"</span>,a.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    A</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SayOk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"b SayOK"</span>,b.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    </span><br><span class="line">    b.Name = <span class="string">"jack"</span><span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//去结构体B中找字段Name，找到并赋值jack，则b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.SayOK() <span class="comment">//b SayOK jack</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法SayOK ，找到并执行fmt.Println("b SayOK",b.Name)，这里b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.hello() <span class="comment">//A hello ""空串</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法hello，没有找到，再去匿名结构体A中找，找到并执行fmt.Println("A hello"，a.Name)，前面的语句并没有为a.Name赋值，则为默认值空串，a.Name就近等于空串</span></span><br><span class="line">    </span><br><span class="line">    b.A.Name = <span class="string">"tom"</span><span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//去结构体B的匿名结构体A中找字段Name，找到并赋值tom，则b.Name= "tom"</span></span><br><span class="line">    </span><br><span class="line">    b.SayOK() <span class="comment">//b SayOK jack</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法SayOK ，找到并执行fmt.Println("b SayOK",b.Name)，这里b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.A.SayOK() <span class="comment">//A SayOK tom</span></span><br><span class="line">    <span class="comment">//去结构体B的匿名结构体A中找方法SayOK ，找到并执行fmt.Println("A hello",a.Name)，这里a.Name= "tom"</span></span><br><span class="line">    </span><br><span class="line">    b.hello() <span class="comment">//A hello tom</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法hello，没有找到，再去匿名结构体A中找，找到并执行fmt.Println("A hello"，a.Name)，前面的语句为a.Name赋值tom，则a.Name就近等于tom</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、当结构体嵌入两个（或多个）匿名结构体，如<strong>两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的字段和方法）</strong>，在访问时，就必须要明确指定匿名结构体的名字，否则编译报错</p>
<p>5、如果一个struct嵌套了一个有名字的结构体，这种模式就是<strong>组合</strong>，如果是组合关系，那么在访问组合的结构体的字段和方法时，就必须带上结构体的名字，<strong>不能简写</strong>。<br>Go中层级关系明确，如果是组合关系，例：一个结构体A嵌套了一个有名结构体B，B的名字为b,B有字段Name，现创建A的实例a,访问字段Name时，只能a.b.Name，不能a.Name，编译器会报错。看到a.Name时，编译器会去A中找字段Name，没有就立马报错（嵌套匿名结构体时会继续在匿名结构体中找）</p>
<p>6、嵌套匿名结构体后，也可以创建结构体变量时，直接指定各个匿名结构体字段的值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pupil := &amp;Pupil&#123;Student&#123;<span class="string">"tom"</span>，<span class="number">15</span>，<span class="number">78.5</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">pupil := &amp;Pupil&#123;</span><br><span class="line">    Student&#123;</span><br><span class="line">        Name:<span class="string">"tom"</span>，</span><br><span class="line">        Age:<span class="number">15</span>，</span><br><span class="line">        Score:<span class="number">78.5</span>，</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>7、在结构体中嵌入匿名结构体时，也可以直接嵌入匿名结构体的指针，这样效率更高</p>
<p>8、在结构体中嵌入匿名结构体时，也可以直接嵌入匿名基本数据类型。<br>如嵌入匿名int，访问时直接通过 “外层结构体实例名.int = 20”这种形式。但是不能同时侵入两个同样的匿名基本数据类型，因为无法区分，如嵌入两个匿名int，这是不允许的。</p>
<h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>一个struct嵌套了多个匿名结构体，那么该结构体可以直接访问所有嵌套的匿名结构体的字段和方法，从而实现多重继承<br>1、当结构体嵌入两个（或多个）匿名结构体，如<strong>两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的字段和方法）</strong>，在访问时，就必须要明确指定匿名结构体的名字，否则编译报错</p>
<p>2、为了代码简洁性，建议尽量不适用多重继承</p>
<h4 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a>3、多态</h4><h5 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、变量（实例）具有多种形态，在GO中，多态特征是通过接口实现的。可以按照统一的接口来调用不同的实现，这时<strong>接口变量就呈现不同的形态</strong>。<br>案例说明：<br>1、定义一个接口Usb<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span>&#123;</span><br><span class="line">    <span class="comment">//声明两个没有实现的方法</span></span><br><span class="line">    Start()</span><br><span class="line">    Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、定义一个结构体Phone<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">type</span> Stu <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让Phone实现接口Usb的所有方法，即实现了接口Usb</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机开始工作。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机停止工作。。。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、再定义一个结构体Camera<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> Stu Camera&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//让Camera实现接口Usb的所有方法，即实现了接口Usb</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">     fmt.Println(<span class="string">"相机开始工作。。。"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">     fmt.Println(<span class="string">"相机停止工作。。。"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>4、再定义一个结构体Computer<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu Computer&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个方法Working，接收一个Usb接口类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">Working</span><span class="params">(usb Usb)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过usb接口变量来调用Start和Stop方法</span></span><br><span class="line">    usb.Start()</span><br><span class="line">    usb.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5、在main函数中使用接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建结构体Computer变量</span></span><br><span class="line">    computer := Computer&#123;&#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//创建结构体Phone变量</span></span><br><span class="line">    phone := Phone&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建结构体Camera变量</span></span><br><span class="line">    camera := Camera&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关键点</span></span><br><span class="line">    computer.Working(phone)</span><br><span class="line">    <span class="comment">//手机开始工作。。。</span></span><br><span class="line">    <span class="comment">//手机停止工作。。。</span></span><br><span class="line">    </span><br><span class="line">    computer.Working(camera)</span><br><span class="line">     <span class="comment">//相机开始工作。。。</span></span><br><span class="line">    <span class="comment">//相机停止工作。。。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结构体Computer的Working函数接收的是一个Usb接口变量，因为结构体Phone和Camera都实现了这个接口，所以可以传入，并且当传Phone时，可以动态的调用phone.Start()和phone.Stop()，传入camera时同理。Usb接口变量体现出多态。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2、接口体现多态的特征"><a href="#2、接口体现多态的特征" class="headerlink" title="2、接口体现多态的特征"></a>2、接口体现多态的特征</h5><p>1、多态参数<br>在前面的Usb接口案例中，Computer的Working函数接收的是一个Usb接口变量，Phone和Camera都实现了这个接口，所以既可以接收Phone变量，又可以接收Camera变量，体现出多态。</p>
<p>2、多态数组<br>在上述Usb案例中，我们可以定义一个Usb接口数组<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个Usb接口数组，可以存放Phone和Camera的结构体变量</span></span><br><span class="line">    <span class="keyword">var</span> usbArr [<span class="number">3</span>]Usb</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;nil&gt;&lt;nil&gt;&lt;nil&gt;]</span></span><br><span class="line">    </span><br><span class="line">    usbArr[<span class="number">0</span>] = Phone&#123;&#125;</span><br><span class="line">    usbArr[<span class="number">1</span>] = Phone&#123;&#125;</span><br><span class="line">    usbArr[<span class="number">2</span>] = Camera&#123;&#125;</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;&gt;&lt;&gt;&lt;&gt;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上述的案例中的结构体都没有字段，这里都加上Name字段，然后创建结构体变量</span></span><br><span class="line">    usbArr[<span class="number">0</span>] = Phone&#123;<span class="string">"华为"</span>&#125;</span><br><span class="line">    usbArr[<span class="number">1</span>] = Phone&#123;<span class="string">"小米"</span>&#125;</span><br><span class="line">    usbArr[<span class="number">2</span>] = Camera&#123;<span class="string">"索尼"</span>&#125;</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;华为&gt;&lt;小米&gt;&lt;索尼&gt;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Usb接口数组usbArr，可以存放Phone和Camera的结构体变量，体现出多态数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><h5 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、<strong>类型断言</strong>，由于<strong>接口</strong>是一般类型，<strong>不知道具体类型</strong>。如果要转成具体类型，就需要使用类型断言。</p>
<h5 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h5><p>1、定义结构体Point<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">    y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、main函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; <span class="comment">//定义一个空接口类型变量a</span></span><br><span class="line">    <span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment">//定义Point类型变量point</span></span><br><span class="line">    </span><br><span class="line">    a = point <span class="comment">//ok，</span></span><br><span class="line">    <span class="comment">//将Point类型变量point赋给一个空接口类型变量a，</span></span><br><span class="line">    <span class="comment">//使空接口类型变量a指向Point类型的变量point</span></span><br><span class="line">    <span class="comment">//空接口变量可以接收任何数据类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b Point</span><br><span class="line">    <span class="comment">//b = a不可以，不可以将一个空接口类型变量a赋给其他数据类型</span></span><br><span class="line">    <span class="comment">//b = a.(Point)可以，a.(Point)称为类型断言</span></span><br><span class="line">    </span><br><span class="line">    b,ok = a.(Point) </span><br><span class="line">    <span class="comment">//判断空接口类型变量a是指向Point类型的变量</span></span><br><span class="line">    <span class="comment">//如果是就转成Point类型的变量并赋给b，否则报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类型断言检查，不要让断言失败直接panic终止程序</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(b)<span class="comment">//输出&lt;1，2&gt;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         fmt.Println(<span class="string">"转换失败"</span>)</span><br><span class="line">     &#125;       </span><br><span class="line">     </span><br><span class="line">     fmt.Println(<span class="string">"代码继续执行"</span>)<span class="comment">//类型断言检查，断言失败不会panic终止程序，这里还会执行到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>重点</strong>：</p>
<ul>
<li>在进行类型断言时，如果类型不匹配，就会报panic。因此进行类型断言时，要确保原来的空接口指向的就是要断言的类型</li>
<li>例：首先“a = point ”使空接口类型变量a指向Point类型的变量point，才可以类型断言“b = a.(Point) ”</li>
</ul>
<h5 id="3、类型断言最佳案例"><a href="#3、类型断言最佳案例" class="headerlink" title="3、类型断言最佳案例"></a>3、类型断言最佳案例</h5><p><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/assert1.png" alt="assert1"></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h5 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、interface类型可以定义一组方法但是不需要实现</p>
<p>2、interface中<strong>不能包含任何变量</strong></p>
<h5 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    method1(参数列表)返回值列表</span><br><span class="line">    method2(参数列表)返回值列表</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> 自定义类型名 <span class="keyword">struct</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s 自定义类型名)</span> <span class="title">method1</span><span class="params">(参数列表)</span>返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">//方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s 自定义类型名)</span> <span class="title">method2</span><span class="params">(参数列表)</span>返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">//方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意：<br>1）接口中的所有方法都没有方法体，即接口的方法都是没有实现的方法。体现<strong>多态</strong>、<strong>高内聚低耦合</strong></p>
<p>2）Go中的接口，不需要显示实现。只要一个结构体变量（实例）含有接口类型中的所有方法，则称这个结构体变量实现了这个接口（没有类似implement这样的关键字，GO是基于方法实现的多态，而不需显示指出接口名称）。</p>
<p>3）如果由接口a和接口b有完全一样的方法列表，那么有实例c如果实现了接口a，同时也就实现了接口b，即：同时实现两个或两个以上的接口（在其他语言中是做不到的，例如Java，必须显示implement实现a，再显示implement实现b）</p>
<p>4）特别指出，需要<strong>实现接口所有的方法</strong></p>
<h5 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h5><p>1、<strong>接口本身不能创建实例</strong>，但是可以指向一个实现了该接口的自定义类型（如struct）的变量（实例）</p>
<p>2、接口中的所有方法都没有方法体，即接口的方法都是没有实现的方法</p>
<p>3、Go中，一个自定义类型需要将某个接口的<strong>所有方法都实现</strong>，才能称这个自定义类型实现了该接口</p>
<p>4、只要是自定义类型，都可以实现接口，不仅仅是结构体类型。如自定义一个int类型“type integer int”，这个自定义的类型integer也可以实现接口</p>
<p>5、一个自定义类型可以<strong>实现多个</strong>接口。（只要把多个接口的方法都实现就可以）</p>
<p>6、Go接口中不能有任何变量（常量也不可以）</p>
<p>7、一个接口（如接口A）可以<strong>继承多个</strong>别的接口（如接口B和C），这时如果要实现接口A，也必须要将接口B和C的方法全部实现，但是<strong>接口B和C中不能有完全相同的方法</strong>，编译器会报错重复定义，因为无法区分。</p>
<p>8、interface类型默认是一个<strong>指针</strong>（<strong>引用类型</strong>），如果没有对interface初始化就使用，那么会输出nil</p>
<p>9、空接口interface{}，没有任何方法，所以<strong>所有类型都默认实现了空接口</strong>（即空接口可以接收任何数据类型，可以把任何数据类型变量赋给空接口）。</p>
<p>10、<strong>空接口也是一种数据类型</strong><br>例：可以声明一个空接口类型变量<br>“vat t interface{}”</p>
<p>该空接口类型变量可以接收任何数据类型的值<br>“t = student”//接收一个Student类型的变量student<br>“t = 8.8”//接收一个float类型的值8.8</p>
<h5 id="4、接口使用案例"><a href="#4、接口使用案例" class="headerlink" title="4、接口使用案例"></a>4、接口使用案例</h5><p>1、定义一个接口AInteger<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AInteger <span class="keyword">interface</span>&#123;</span><br><span class="line">    Test01()</span><br><span class="line">    Test02()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、再定义一个接口BInteger<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AInteger <span class="keyword">interface</span>&#123;</span><br><span class="line">    Test01()</span><br><span class="line">    Test03()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、定义一个结构体Stu<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test01</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test02</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test03</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4、在main函数中使用接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stu := Stu&#123;&#125;<span class="comment">//创建一个Stu实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> a AInteger =stu </span><br><span class="line">    <span class="comment">//ok，将实例stu赋给接口AInteger的变量a，因为stu实现了接口AInteger中的所有方法（ Test01和Test02）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b BInteger =stu</span><br><span class="line">    <span class="comment">//ok，将实例stu赋给接口BInteger的变量b，因为stu实现了接口BInteger中的所有方法（ Test01和Test03）</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"ok"</span>,a,b)<span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5、接口与继承比较"><a href="#5、接口与继承比较" class="headerlink" title="5、接口与继承比较"></a>5、接口与继承比较</h5><p>1、当B结构体继承了A结构体，那么B结构体就自动的继承了A结构体的字段和方法，并且可以直接使用</p>
<p>2、B结构体需要扩展功能，同时不希望破坏继承关系，可以去实现某个接口，因此，可以认为：实现<strong>接口是对继承机制的一种补充</strong></p>
<p>3、接口与继承解决的问题不同</p>
<ul>
<li>继承的价值：解决代码的<strong>复用性</strong>和<strong>可维护性</strong></li>
<li>接口的价值：<strong>设计</strong>，设计好各种规范（方法），让其他自定义类型去实现这些方法来增强功能</li>
</ul>
<p>4、接口比继承更加灵活。<strong>继承</strong>是满足 <strong>is - a</strong> 的关系，<strong>接口</strong>只需要满足 <strong>like - a</strong> 的关系</p>
<p>5、接口在一定程度上实现代码解耦，尤其在GO中更加松散</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/" data-id="ckcpzrdoz000usovi3zthrcgm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/16/GO：2-1-数组和切片/">GO：2.1 数组和切片</a>
          </li>
        
          <li>
            <a href="/2020/07/13/GO：1-4-程序实体/">GO：1.4 程序实体</a>
          </li>
        
          <li>
            <a href="/2020/07/12/GO：1-3-库源码文件/">GO：1.3 库源码文件</a>
          </li>
        
          <li>
            <a href="/2020/07/10/GO：1-2-命令源码文件/">GO：1.2 命令源码文件</a>
          </li>
        
          <li>
            <a href="/2020/07/10/GO：工作区和GOPATH/">GO：工作区和GOPATH</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>