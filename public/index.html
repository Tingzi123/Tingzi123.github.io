<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-GO：2-3-字典的操作和约束" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/20/GO：2-3-字典的操作和约束/" class="article-date">
  <time datetime="2020-07-20T12:38:58.000Z" itemprop="datePublished">2020-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/20/GO：2-3-字典的操作和约束/">GO：2.3 字典的操作和约束</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>字典（map）存储的不是单一值的集合，而是键值对的集合。</p>
<hr>
<p>什么是键值对？</p>
<p><strong><em>它是从英文 key-value pair 直译过来的一个词。顾名思义，一个键值对就代表了一对键和值。<br>注意，一个“键”和一个“值”分别代表了一个从属于某一类型的独立值，把它们两个捆绑在一起就是一个键值对了。</em></strong></p>
<hr>
<p>在 Go 语言规范中，应该是为了避免歧义，他们将键值对换了一种称呼，叫做：“键 - 元素对”。我们也沿用这个看起来更加清晰的词来讲解。</p>
<h3 id="1、为什么字典的键类型会受到约束？"><a href="#1、为什么字典的键类型会受到约束？" class="headerlink" title="1、为什么字典的键类型会受到约束？"></a>1、为什么字典的键类型会受到约束？</h3><p>Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，<strong>键的类型是受限的，而元素却可以是任意类型的。</strong></p>
<p>如果要探究限制的原因，我们就先要了解哈希表中最重要的一个过程：<strong>映射</strong>。</p>
<p>你可以<strong>把键理解为元素的一个索引</strong>，我们可以在哈希表中通过键查找与它成对的那个元素。</p>
<p>键和元素的这种对应关系，在数学里就被称为“映射”，这也是“map”这个词的本意，哈希表的映射过程就存在于对键 - 元素对的增、删、改、查的操作之中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">aMap := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">  <span class="string">"one"</span>:    <span class="number">1</span>,</span><br><span class="line">  <span class="string">"two"</span>:    <span class="number">2</span>,</span><br><span class="line">  <span class="string">"three"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">k := <span class="string">"two"</span></span><br><span class="line">v, ok := aMap[k]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"The element of key %q: %d\n"</span>, k, v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Not found!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，我们要在哈希表中查找与某个键值对应的那个元素值，那么我们需要先把键值作为参数传给这个哈希表。</p>
<p>哈希表会<strong>先用哈希函数（hash function）把键值转换为哈希值</strong>。哈希值通常是一个无符号的整数。一个哈希表会持有一定数量的桶（bucket），我们也可以叫它哈希桶，这些哈希桶会均匀地储存其所属哈希表收纳的键 - 元素对。</p>
<p>因此，哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。</p>
<p>由于键 - 元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素值。随后，哈希表就会把相应的元素值作为结果返回。</p>
<p>只要这个键 - 元素对存在哈希表中就一定会被查找到，因为哈希表增、改、删键 - 元素对时的映射过程，与前文所述如出一辙。</p>
<p>现在我们知道了，<strong>映射过程的第一步就是：把键值转换为哈希值。</strong></p>
<p>在 Go 语言的字典中，每一个键值都是由它的哈希值代表的。也就是说，字典不会独立存储任何键的值，但会独立存储它们的哈希值。</p>
<h3 id="2、字典的键类型不能是哪些类型？"><a href="#2、字典的键类型不能是哪些类型？" class="headerlink" title="2、字典的键类型不能是哪些类型？"></a>2、字典的键类型不能是哪些类型？</h3><p>Go 语言字典的键类型不可以是<strong>函数类型、字典类型和切片类型</strong>。</p>
<p>Go 语言规范规定，<strong>在键类型的值之间必须可以施加操作符==和!=</strong>。换句话说，键类型的值必须要支持<strong>判等</strong>操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。</p>
<p>另外，<strong>如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型</strong>，否则在程序运行过程中会引发 panic（即运行时恐慌）。<br>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> badMap2 = <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>&#123;</span><br><span class="line">  <span class="string">"1"</span>:   <span class="number">1</span>,</span><br><span class="line">  []<span class="keyword">int</span>&#123;<span class="number">2</span>&#125;: <span class="number">2</span>, <span class="comment">// 这里会引发panic。</span></span><br><span class="line">  <span class="number">3</span>:    <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的变量badMap2的类型是键类型为interface{}、值类型为int的字典类型。这样声明并不会引起什么错误。或者说，我通过这样的声明躲过了 Go 语言编译器的检查。</p>
<p>注意，我用字面量在声明该字典的同时对它进行了初始化，使它包含了三个键 - 元素对。其中第二个键 - 元素对的键值是[]int{2}，元素值是2。这样的键值也不会让 Go 语言编译器报错，因为从<strong>语法上说，这样做是可以的</strong>。</p>
<p>但是，当我们<strong>运行</strong>这段代码的时候，Go 语言的运行时（runtime）系统就会发现这里的问题，它会<strong>抛出一个 panic</strong>，并把根源指向字面量中定义第二个键 - 元素对的那一行。我们越晚发现问题，修正问题的成本就会越高，所以最好不要把字典的键类型设定为任何接口类型。如果非要这么做，请一定确保代码在可控的范围之内。</p>
<p>还要注意<strong>，如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型。</strong></p>
<p>比如，由于类型[1][]string的元素类型是[]string，所以它就不能作为字典类型的键类型。另外，如果键的类型是结构体类型，那么还要保证其中字段的类型的合法性。无论不合法的类型被埋藏得有多深，比如map[[1][2][3][]string]int，Go 语言编译器都会把它揪出来。</p>
<ul>
<li>你可能会有疑问，为什么键类型的值必须支持判等操作？我在前面说过，Go 语言一旦定位到了某一个哈希桶，那么就会试图在这个桶中查找键值。具体是怎么找的呢？</li>
</ul>
<p>首先，每个哈希桶都会把自己包含的所有键的哈希值存起来。Go 语言会用被查找键的哈希值与这些哈希值逐个对比，看看是否有相等的。如果一个相等的都没有，那么就说明这个桶中没有要查找的键值，这时 Go 语言就会立刻返回结果了。</p>
<p>如果有相等的，那就再用键值本身去对比一次。为什么还要对比？原因是，不同值的哈希值是可能相同的。这有个术语，叫做“<strong>哈希碰撞</strong>”。</p>
<p>所以，即使哈希值一样，键值也不一定一样。如果键类型的值之间无法判断相等，那么此时这个映射的过程就没办法继续下去了。最后，只有键的哈希值和键值都相等，才能说明查找到了匹配的键 - 元素对。</p>
<h3 id="3、应该优先考虑哪些类型作为字典的键类型？"><a href="#3、应该优先考虑哪些类型作为字典的键类型？" class="headerlink" title="3、应该优先考虑哪些类型作为字典的键类型？"></a>3、应该优先考虑哪些类型作为字典的键类型？</h3><p>在 Go 语言中，有些类型的值是支持判等的，有些是不支持的。那么在这些值支持判等的类型当中，哪些更适合作为字典的键类型呢？</p>
<p>这里先抛开我们使用字典时的上下文，只从性能的角度看。在前文所述的映射过程中，<strong>“把键值转换为哈希值”以及“把要查找的键值与哈希桶中的键值做对比”， 明显是两个重要且比较耗时的操作</strong>。</p>
<p>因此，可以说，<strong>求哈希和判等操作的速度越快，对应的类型就越适合作为键类型</strong>。</p>
<hr>
<p><em>对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go 语言都有一套算法与之对应。这套算法中就包含了<strong>哈希和判等</strong>。以求哈希的操作为例，<strong>宽度越小的类型速度通常越快</strong>。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。<strong>对于字符串类型</strong>，由于它的宽度是不定的，所以要看它的值的具体长度，<strong>长度越短求哈希越快</strong>。</em></p>
<hr>
<p>类型的宽度是指它的单个值需要占用的字节数。比如，bool、int8和uint8类型的一个值需要占用的字节数都是1，因此这些类型的宽度就都是1。</p>
<p>以上说的都是基本类型，再来看高级类型。</p>
<p><strong>对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并</strong>，所以<strong>速度就取决于它的元素类型以及它的长度</strong>。细则同上。</p>
<p>与之类似，对<strong>结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并</strong>，所以关键在于<strong>它的各个字段的类型以及字段的数量</strong>。而对于接口类型，具体的哈希算法，则由值的实际类型决定。</p>
<p>我不建议你使用这些高级数据类型作为字典的键类型，不仅仅是因为对它们的值求哈希，以及判等的速度较慢，更是因为在它们的值中存在变数。</p>
<p>比如，对一个数组来说，我可以任意改变其中的元素值，但在变化前后，它却代表了两个不同的键值。</p>
<p>对于结构体类型的值情况可能会好一些，因为如果我可以控制其中各字段的访问权限的话，就可以阻止外界修改它了。把接口类型作为字典的键类型最危险。</p>
<p>如果在这种情况下 Go 运行时系统发现某个键值不支持判等操作，那么就会立即抛出一个 panic。在最坏的情况下，这足以使程序崩溃。</p>
<ul>
<li>那么，在那些基本类型中应该优先选择哪一个？<br>答案是，<strong>优先选用数值类型和指针类型</strong>，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。</li>
</ul>
<ul>
<li>那什么是不通常的情况？笼统地说，Go<br>语言有时会对字典的增、删、改、查操作做一些优化。</li>
</ul>
<p>比如，在字典的键类型为字符串类型的情况下；又比如，在字典的键类型为宽度为4或8的整数类型的情况下。</p>
<h3 id="4、在值为nil的字典上执行读操作会成功吗，那写操作呢？"><a href="#4、在值为nil的字典上执行读操作会成功吗，那写操作呢？" class="headerlink" title="4、在值为nil的字典上执行读操作会成功吗，那写操作呢？"></a>4、在值为nil的字典上执行读操作会成功吗，那写操作呢？</h3><p>由于<strong>字典是引用类型</strong>，所以当我们<strong>仅声明而不初始化一个字典类型的变量的时候，它的值会是nil</strong>。</p>
<ul>
<li>在这样一个变量上试图通过键值获取对应的元素值，或者添加键 - 元素对，会成功吗？<br>这个问题虽然简单，但却是我们必须铭记于心的，因为这涉及程序运行时的稳定性。</li>
</ul>
<p><strong>除了添加键 - 元素对，我们在一个值为nil的字典上做任何操作都不会引起错误</strong>。当我们试图在一个值为nil的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。你可以运行一下 demo19.go 文件试试看。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/20/GO：2-3-字典的操作和约束/" data-id="ckcukir650005h8vih2b2bzgf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：2-2-container包中的容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/17/GO：2-2-container包中的容器/" class="article-date">
  <time datetime="2020-07-17T09:01:43.000Z" itemprop="datePublished">2020-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/17/GO：2-2-container包中的容器/">GO：2.2 container包中的容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Go 语言的链表实现在标准库的container/list代码包中。这个代码包中有两个公开的程序实体——List和Element，List 实现了一个双向链表（以下简称链表），而 Element 则代表了链表中元素的结构。</p>
<h3 id="1、可以把自己生成的Element类型值传给链表吗？"><a href="#1、可以把自己生成的Element类型值传给链表吗？" class="headerlink" title="1、可以把自己生成的Element类型值传给链表吗？"></a>1、可以把自己生成的Element类型值传给链表吗？</h3><p>这里用到了List的四种方法。</p>
<ul>
<li>MoveBefore方法和MoveAfter方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。</li>
<li>MoveToFront方法和MoveToBack方法，分别用于把给定的元素移动到链表的最前端和最后端。</li>
</ul>
<p>在这些方法中，“给定的元素”都是<em>Element类型的，</em>Element类型是Element类型的指针类型，*Element的值就是元素的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveBefore</span><span class="params">(e, mark *Element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveAfter</span><span class="params">(e, mark *Element)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveToFront</span><span class="params">(e *Element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveToBack</span><span class="params">(e *Element)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="1、如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？"><a href="#1、如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？" class="headerlink" title="1、如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？"></a>1、如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？</h4><p>典型回答：不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的Element值并不在链表中，所以也就谈不上“在链表中移动元素”。更何况链表不允许我们把自己生成的Element值插入其中。</p>
<ul>
<li>在List包含的方法中，用于插入新元素的那些方法都只接受interface{}类型的值。这些方法在内部会使用Element值，包装接收到的新元素。</li>
<li>这样做正是为了避免直接使用我们自己生成的元素，主要原因是避免链表的内部关联，遭到外界破坏，这对于链表本身以及我们这些使用者来说都是有益的。</li>
</ul>
<h4 id="2、List的方法还有下面这几种："><a href="#2、List的方法还有下面这几种：" class="headerlink" title="2、List的方法还有下面这几种："></a>2、List的方法还有下面这几种：</h4><ul>
<li>Front和Back方法分别用于获取链表中最前端和最后端的元素</li>
<li>InsertBefore和InsertAfter方法分别用于在指定的元素之前和之后插入新元素</li>
<li>PushFront和PushBack方法则分别用于在链表的最前端和最后端插入新元素。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Front</span><span class="params">()</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Back</span><span class="params">()</span> *<span class="title">Element</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">InsertBefore</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, mark *Element)</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">InsertAfter</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, mark *Element)</span> *<span class="title">Element</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">PushFront</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">PushBack</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Element</span></span></span><br></pre></td></tr></table></figure>
<p>这些方法都会把一个Element值的指针作为结果返回，它们就是链表留给我们的安全“接口”。拿到这些内部元素的指针，我们就可以去调用前面提到的用于移动元素的方法了。</p>
<h3 id="2、为什么链表可以做到开箱即用？"><a href="#2、为什么链表可以做到开箱即用？" class="headerlink" title="2、为什么链表可以做到开箱即用？"></a>2、为什么链表可以做到开箱即用？</h3><p>List和Element都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予各自类型的零值。</p>
<ul>
<li>广义来讲，所谓的零值就是只做了声明，但还未做初始化的变量被给予的缺省值。每个类型的零值都会依据该类型的特性而被设定。</li>
<li>比如，经过语句var a [2]int声明的变量a的值，将会是一个包含了两个0的整数数组。又比如，经过语句var s []int声明的变量s的值将会是一个[]int类型的、值为nil的切片。</li>
</ul>
<p>那么经过语句var l list.List声明的变量l的值将会是什么呢？<br>[1] 这个零值将会是一个长度为0的链表。这个链表持有的根元素也将会是一个空壳，其中只会包含缺省的内容。</p>
<ul>
<li>那这样的链表我们可以直接拿来使用吗？<br>答案是，可以的。这被称为“<strong>开箱即用</strong>”。Go 语言标准库中很多结构体类型的程序实体都做到了开箱即用。这也是在编写可供别人使用的代码包（或者说程序库）时，我们推荐遵循的最佳实践之一。</li>
</ul>
<p>那么，语句var l list.List声明的链表l可以直接使用，这是怎么做到的呢？<br>关键在于它的“<strong>延迟初始化</strong>”机制。</p>
<h4 id="1、延迟初始化"><a href="#1、延迟初始化" class="headerlink" title="1、延迟初始化"></a>1、延迟初始化</h4><p>所谓的延迟初始化，你可以理解为<strong>把初始化操作延后，仅在实际需要的时候才进行</strong>。延迟初始化的优点在于“延后”，它<strong>可以分散初始化操作带来的计算量和存储空间消耗</strong>。</p>
<p>例如，如果我们需要集中声明非常多的大容量切片的话，那么那时的 CPU 和内存空间的使用量肯定都会一个激增，并且只有设法让其中的切片及其底层数组被回收，内存使用量才会有所降低。</p>
<p>如果数组是可以被延迟初始化的，那么计算量和存储空间的压力就可以被分散到实际使用它们的时候。这些数组被实际使用的时间越分散，延迟初始化带来的优势就会越明显。</p>
<hr>
<p><strong><em>实际上，Go 语言的切片就起到了延迟初始化其底层数组的作用，你可以想一想为什么会这么说的理由。延迟初始化的缺点恰恰也在于“延后”。你可以想象一下，如果我在调用链表的每个方法的时候，它们都需要先去判断链表是否已经被初始化，那这也会是一个计算量上的浪费。在这些方法被非常频繁地调用的情况下，这种浪费的影响就开始显现了，程序的性能将会降低。</em></strong></p>
<hr>
<p>在这里的链表实现中，一些方法是无需对是否初始化做判断的。比如Front方法和Back方法，一旦发现链表的长度为0, 直接返回nil就好了。</p>
<p>又比如，在用于删除元素、移动元素，以及一些用于插入元素的方法中，只要判断一下传入的元素中指向所属链表的指针，是否与当前链表的指针相等就可以了。</p>
<p>如果不相等，就一定说明传入的元素不是这个链表中的，后续的操作就不用做了。反之，就一定说明这个链表已经被初始化了。</p>
<p>原因在于，链表的PushFront方法、PushBack方法、PushBackList方法以及PushFrontList方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始化。</p>
<p>而且，我们在向一个空的链表中添加新元素的时候，肯定会调用这四个方法中的一个，这时新元素中指向所属链表的指针，一定会被设定为当前链表的指针。所以，指针相等是链表已经初始化的充分必要条件。</p>
<p>？List利用了自身以及Element在结构上的特点，巧妙地平衡了延迟初始化的优缺点，使得链表可以开箱即用，并且在性能上可以达到最优。</p>
<h3 id="3、Ring与List的区别在哪儿？"><a href="#3、Ring与List的区别在哪儿？" class="headerlink" title="3、Ring与List的区别在哪儿？"></a>3、Ring与List的区别在哪儿？</h3><p>container/ring包中的Ring类型实现的是一个循环链表，也就是我们俗称的环。其实List在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。</p>
<p>所以也可以说，List的零值是一个只包含了根元素，但不包含任何实际元素值的空链表。<br>那么，既然Ring和List在本质上都是循环链表，那它们到底有什么不同呢？</p>
<p>最主要的不同有下面几种。</p>
<ul>
<li>1、Ring类型的数据结构仅由它自身即可代表，而List类型则需要由它以及Element类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。</li>
<li>2、一个Ring类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个List类型的值则代表了一个完整的链表。这是表示维度上的不同。</li>
<li>3、在创建并初始化一个Ring值的时候，我们可以指定它包含的元素的数量，但是对于一个List值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的New函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。</li>
<li>4、仅通过var r ring.Ring语句声明的r将会是一个长度为1的循环链表，而List类型的零值则是一个长度为0的链表。别忘了List中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。</li>
<li>5、Ring值的Len方法的算法复杂度是 O(N) 的，而List值的Len方法的算法复杂度则是 O(1) 的。这是两者在性能方面最显而易见的差别。</li>
</ul>
<p>其他的不同基本上都是方法方面的了。比如，循环链表也有用于插入、移动或删除元素的方法，不过用起来都显得更抽象一些，等等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/17/GO：2-2-container包中的容器/" data-id="ckcukir630004h8viuii7zux1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：2-1-数组和切片" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/16/GO：2-1-数组和切片/" class="article-date">
  <time datetime="2020-07-16T11:06:12.000Z" itemprop="datePublished">2020-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/16/GO：2-1-数组和切片/">GO：2.1 数组和切片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、数组（array）类型和切片（slice）类型的异同"><a href="#1、数组（array）类型和切片（slice）类型的异同" class="headerlink" title="1、数组（array）类型和切片（slice）类型的异同"></a>1、数组（array）类型和切片（slice）类型的异同</h3><h4 id="1、相同"><a href="#1、相同" class="headerlink" title="1、相同"></a>1、相同</h4><p>数组（array）类型和切片（slice）类型的共同点是都属于集合类的类型，并且，它们的值也都可以用来存储某一种类型的值（或者说元素）。</p>
<h4 id="2、区别"><a href="#2、区别" class="headerlink" title="2、区别"></a>2、区别</h4><p>它们最重要的不同是：<strong>数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。</strong></p>
<p>数组的长度在声明它的时候就必须给定，并且之后不会再改变。可以说，<strong>数组的长度是其类型的一部分</strong>。比如，<strong>[1]string和[2]string就是两个不同的数组类型</strong>。</p>
<p>而<strong>切片的类型字面量中只有元素的类型，而没有长度</strong>。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小。<br><img src="/2020/07/16/GO：2-1-数组和切片/arrslice1.png" alt="arrslice1"></p>
<p>我们其实可以<strong>把切片看做是对数组的一层简单的封装</strong>，因为在每个切片的底层数据结构中，一定会包含一个数组。<strong>数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。</strong></p>
<ul>
<li><p>也正因为如此，Go 语言的<strong>切片类型属于引用类型</strong>，同属<strong>引用类型的还有字典类型、通道类型、函数类型等</strong>；而 Go 语言的<strong>数组类型则属于值类型</strong>，同属<strong>值类型的有基础数据类型以及结构体类型</strong>。注意，Go 语言里不存在像 Java 等编程语言中令人困惑的“传值或传引用”问题。在 Go 语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。我们在数组和切片之上都可以应用索引表达式，得到的都会是某个元素。我们在它们之上也都可以应用切片表达式，也都会得到一个新的切片</p>
</li>
<li><p>通过调用内建函数len，得到数组和切片的长度。通过调用内建函数cap，我们可以得到它们的容量。但要注意，<strong>数组的容量永远等于其长度，都是不可变的</strong>。切片的容量却不是这样，并且它的变化是有规律可寻的。</p>
</li>
</ul>
<h3 id="2、怎样正确估算切片的长度和容量？"><a href="#2、怎样正确估算切片的长度和容量？" class="headerlink" title="2、怎样正确估算切片的长度和容量？"></a>2、怎样正确估算切片的长度和容量？</h3><p>1、如下例子demo15.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 示例1。</span></span><br><span class="line">  s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="comment">//用内建函数make声明了一个[]int类型的变量s1，传给make函数的第二个参数是5，从而指明了该切片的长度</span></span><br><span class="line">  </span><br><span class="line">  fmt.Printf(<span class="string">"The length of s1: %d\n"</span>, <span class="built_in">len</span>(s1))</span><br><span class="line">  fmt.Printf(<span class="string">"The capacity of s1: %d\n"</span>, <span class="built_in">cap</span>(s1))</span><br><span class="line">  fmt.Printf(<span class="string">"The value of s1: %d\n"</span>, s1)</span><br><span class="line">  </span><br><span class="line">  s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br><span class="line">  <span class="comment">//同样的方式声明了切片s2，多传入了一个参数8以指明该切片的容量。</span></span><br><span class="line">  </span><br><span class="line">  fmt.Printf(<span class="string">"The length of s2: %d\n"</span>, <span class="built_in">len</span>(s2))</span><br><span class="line">  fmt.Printf(<span class="string">"The capacity of s2: %d\n"</span>, <span class="built_in">cap</span>(s2))</span><br><span class="line">  fmt.Printf(<span class="string">"The value of s2: %d\n"</span>, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>切片s1和s2的容量都是多少？<br>切片s1的容量是5，s2的容量是8</li>
</ul>
<p>2、通过切片表达式基于某个数组或切片生成新切片的时候，情况就变得复杂起来了。<br>如下例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="comment">//s3中有 8 个元素，分别是从1到8的整数，s3的长度和容量都是8。</span></span><br><span class="line"></span><br><span class="line">s4 := s3[<span class="number">3</span>:<span class="number">6</span>]</span><br><span class="line"><span class="comment">//用切片表达式s3[3:6]初始化了切片s4</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"The length of s4: %d\n"</span>, <span class="built_in">len</span>(s4))</span><br><span class="line">fmt.Printf(<span class="string">"The capacity of s4: %d\n"</span>, <span class="built_in">cap</span>(s4))</span><br><span class="line">fmt.Printf(<span class="string">"The value of s4: %d\n"</span>, s4)</span><br></pre></td></tr></table></figure></p>
<p>运行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The length of s4: <span class="number">3</span></span><br><span class="line">The capacity of s4: <span class="number">5</span></span><br><span class="line">The value of s4: [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1、s4的长度是多少？<br>长度是3</li>
</ul>
<p>切片表达式中s3[3:6]取数范围为[3,6)，即从索引3开始取，取到索引6但不包含索引6。</p>
<p>这里的3可被称为起始索引，6可被称为结束索引。那么s4的长度就是6减去3，即3。</p>
<p>可以说，s4中的索引从0到2指向的元素对应的是s3及其底层数组中索引从3到5的那 3 个元素。<br><img src="/2020/07/16/GO：2-1-数组和切片/arrslice2.png" alt="arrslice2"></p>
<ul>
<li><p>2、再来看s4的容量是多少?<br>容量是5</p>
<p><strong>切片的容量代表了它的底层数组的长度，但这仅限于使用make函数或者切片值字面量初始化切片的情况。</strong></p>
</li>
</ul>
<p>更通用的规则是：<strong>一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。</strong></p>
<p>由于s4是通过在s3上施加切片操作得来的，所以s3的底层数组就是s4的底层数组。</p>
<p>又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾。</p>
<p>所以，s4的容量就是其底层数组的长度8, 减去上述切片表达式中的那个起始索引3，即5。</p>
<p>注意，切片代表的窗口是无法向左扩展的。也就是说，我们永远无法透过s4看到s3中最左边的那 3 个元素。</p>
<ul>
<li>把切片的窗口向右扩展到最大的方法。<br>对于s4来说，切片表达式s4[0:cap(s4)]就可以做到。我想你应该能看懂。该表达式的结果值（即一个新的切片）会是[]int{4, 5, 6, 7, 8}，其长度和容量都是5。 </li>
</ul>
<h3 id="3、怎样估算切片容量的增长？"><a href="#3、怎样估算切片容量的增长？" class="headerlink" title="3、怎样估算切片容量的增长？"></a>3、怎样估算切片容量的增长？</h3><p>一旦一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。<strong>在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。</strong></p>
<p>但是，当<strong>原切片的长度（以下简称原长度）大于或等于1024时</strong>，Go 语言将会<strong>以原容量的1.25倍作为新容量的基准（以下新容量基准）</strong>。<strong>新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）</strong>。最终，新容量往往会比新长度大一些，当然，相等也是可能的。</p>
<p>另外，如果我们一次追加的元素过多，以至于<strong>使新长度比原容量的 2 倍还要大</strong>，那么<strong>新容量就会以新长度为基准</strong>。注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些。</p>
<h3 id="4、切片的底层数组什么时候会被替换？"><a href="#4、切片的底层数组什么时候会被替换？" class="headerlink" title="4、切片的底层数组什么时候会被替换？"></a>4、切片的底层数组什么时候会被替换？</h3><p>确切地说，一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。</p>
<p>它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。</p>
<p>在无需扩容时，append函数返回的是指向原底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。所以，严格来讲，“扩容”这个词用在这里虽然形象但并不合适。</p>
<p>只要新长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/16/GO：2-1-数组和切片/" data-id="ckcukir630003h8vitq5qz5qo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：1-4-程序实体" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/13/GO：1-4-程序实体/" class="article-date">
  <time datetime="2020-07-13T02:42:07.000Z" itemprop="datePublished">2020-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/13/GO：1-4-程序实体/">GO：1.4 程序实体</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Go 语言中的<strong>程序实体包括变量、常量、函数、结构体和接口</strong>。 Go 语言是<strong>静态类型</strong>的编程语言，所以我们在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让 Go 语言能够推导出它们的类型。</p>
<h3 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h3><p>在 Go 语言中，<strong>变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数、结构体或接口</strong>。常量的合法类型不多，只能是那些 Go 语言预定义的基本类型。它的声明方式也更简单一些。</p>
<hr>
<h4 id="1、声明变量有几种方式？"><a href="#1、声明变量有几种方式？" class="headerlink" title="1、声明变量有几种方式？"></a>1、声明变量有几种方式？</h4><p>1、先声明后赋值<br>一个很简单的命令源码文件，命名为 demo7.go。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name <span class="keyword">string</span> <span class="comment">// 先声明</span></span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>) <span class="comment">// 后赋值</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、使用var声明变量的同时赋值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name = flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//声明的同时赋值</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, *name)。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>flag.String函数返回的结果值的类型是<em>string而不是string。类型</em>string代表的是字符串的指针类型，而不是字符串类型。因此，这里的变量name代表的是一个指向字符串值的指针。</p>
<p>注：</p>
<ul>
<li>1、声明变量name的同时，还为它赋了值，而这时声明中并没有显式指定name的类型。之前的变量声明语句是var name string。这里利用了 Go 语言自身的类型推断，而省去了对该变量的类型的声明。</li>
<li>2、类型推断是一种编程语言在编译期自动解释表达式类型的能力。</li>
<li>3、类型推断只能用于对变量或常量的初始化。</li>
</ul>
<p>3、使用”:=”短变量声明的同时赋值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  name := flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//声明的同时赋值</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, *name)。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：</p>
<ul>
<li>1、短变量声明，实际上就是 Go 语言的类型推断再加上一点点语法糖，<strong>只能在函数体内部使用短变量声明</strong></li>
<li>在编写if、for或switch语句的时候，我们经常把它安插在初始化子句中，并用来声明一些临时的变量。而相比之下，第一种方式更加通用，它可以被用在任何地方。<br><img src="/2020/07/13/GO：1-4-程序实体/app1.png" alt="app1"></li>
</ul>
<h4 id="2、Go-语言的类型推断可以带来哪些好处？"><a href="#2、Go-语言的类型推断可以带来哪些好处？" class="headerlink" title="2、Go 语言的类型推断可以带来哪些好处？"></a>2、Go 语言的类型推断可以带来哪些好处？</h4><p>在写代码时，我们通过使用 Go 语言的类型推断，而节省下来的键盘敲击次数几乎可以忽略不计。但它真正的好处，往往会体现在我们写代码之后的那些事情上，比如<strong>代码重构</strong>。</p>
<p>通过调用一个函数在声明name变量的同时为它赋值，这个函数是由我们自己定义的函数getTheFlag。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name = getTheFlag()</span><br><span class="line">  <span class="comment">//不显式地指定变量name的类型，使得它可以被赋予任何类型的值。也就是说，变量name的类型可以在其初始化时，由其他程序动态地确定。</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, *name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTheFlag</span><span class="params">()</span> *<span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以用getTheFlag函数包裹（或者说包装）那个对flag.String函数的调用，并把其结果直接作为getTheFlag函数的结果，结果的类型是*string。</p>
<p>这样一来，var name =右边的表达式，可以变为针对getTheFlag函数的调用表达式了。这实际上是对“声明并赋值name变量的那行代码”的重构。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重构：</span><br><span class="line">我们通常把不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码修改方式，叫做对该程序的重构。重构的对象可以是一行代码、一个函数、一个功能模块，甚至一个软件系统。</span><br></pre></td></tr></table></figure></p>
<p>你会发现，你可以随意改变getTheFlag函数的内部实现，及其返回结果的类型，而不用修改main函数中的任何代码。</p>
<p>注：</p>
<ul>
<li>我们不显式地指定变量name的类型，使得它可以被赋予任何类型的值。也就是说，变量name的类型可以在其初始化时，由其他程序动态地确定。</li>
<li>在你改变getTheFlag函数的结果类型之后，Go 语言的编译器会在你再次构建该程序的时候，自动地更新变量name的类型。</li>
<li>通过这种<strong>类型推断</strong>，你可以体验到动态类型编程语言所带来的一部分优势，即程序灵活性的明显提升。但在那些编程语言中，这种提升可以说是用程序的可维护性和运行效率换来的。</li>
<li>Go 语言是静态类型的，所以一旦在初始化变量时确定了它的类型，之后就不可能再改变。这就避免了在后面维护程序时的一些问题。另外，请记住，这种类型的确定是在<strong>编译期</strong>完成的，因此不会对程序的运行效率产生任何影响。</li>
</ul>
<hr>
<p><em>Go 语言的类型推断可以带来哪些好处？<br>Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。</em></p>
<hr>
<h4 id="2、变量的重声明是什么意思？"><a href="#2、变量的重声明是什么意思？" class="headerlink" title="2、变量的重声明是什么意思？"></a>2、变量的重声明是什么意思？</h4><p>1、变量的重声明：对已经声明过的变量再次声明。</p>
<p>2、这涉及了短变量声明。通过使用它，我们可以对同一个代码块中的变量进行重声明。</p>
<p>3、变量重声明的前提条件如下。</p>
<ul>
<li>1、由于变量的类型在其初始化时就已经确定了，所以对它<strong>再次声明时赋予的类型必须与其原本的类型相同</strong>，否则会产生编译错误。</li>
<li>2、变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了</li>
<li>3、变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。</li>
<li>4、被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。</li>
</ul>
<p>如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">n, err := io.WriteString(os.Stdout, <span class="string">"Hello, everyone!\n"</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用短变量声明，对新变量n和旧变量err进行了“声明并赋值”，这时也是对err的重声明。</p>
<h4 id="3、如果一个变量与其外层代码块中的变量重名会出现什么状况？"><a href="#3、如果一个变量与其外层代码块中的变量重名会出现什么状况？" class="headerlink" title="3、如果一个变量与其外层代码块中的变量重名会出现什么状况？"></a>3、如果一个变量与其外层代码块中的变量重名会出现什么状况？</h4><p>1、作用域：</p>
<ul>
<li>1、程序实体的访问权限有三种：<strong>包级私有的、模块级私有的和公开的</strong>。这其实就是 Go 语言在语言层面，依据代码块对程序实体作用域进行的定义。</li>
<li>2、包级私有和模块级私有访问权限对应的都是代码包代码块，公开的访问权限对应的是全域代码块。</li>
<li>3、<strong>一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制</strong>。对“高内聚，低耦合”这种程序设计思想的实践，就是从这里开始的。</li>
</ul>
<p>2、如果一个变量与其外层代码块中的变量重名会出现什么状况？<br>如下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> block = <span class="string">"package"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  block := <span class="string">"function"</span></span><br><span class="line">  &#123;</span><br><span class="line">    block := <span class="string">"inner"</span></span><br><span class="line">    fmt.Printf(<span class="string">"The block is %s.\n"</span>, block)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">"The block is %s.\n"</span>, block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个命令源码文件中有四个代码块，它们是：</p>
<ul>
<li>全域代码块、</li>
<li>main包代表的代码块、</li>
<li>main函数代表的代码块，</li>
<li>在main函数中的一个用花括号包起来的代码块。</li>
</ul>
<p>在后三个代码块（main包代表的代码块、main函数代表的代码块、在main函数中的一个用花括号包起来的代码块）中分别声明了一个名为block的变量，并分别把字符串值”package”、”function”和”inner”赋给了它们。此外，我在后两个代码块的最后分别尝试用fmt.Printf函数打印出“The block is %s.”。这里的“%s”只是为了占位，程序会用block变量的实际值替换掉。</p>
<p>那么，该源码文件中的代码能通过编译吗？<br>能通过编译。运行后打印出的内容是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The block is inner.</span><br><span class="line">The block is function.</span><br></pre></td></tr></table></figure></p>
<ul>
<li>对于同一个代码块而言，用短变量声明对已有变量进行重声明可以通过编译</li>
<li>对于不同的代码块来说，其中的变量重名没什么大不了，照样可以通过编译。即使这些代码块有直接的嵌套关系也是如此，就像上述代码中的main包代码块、main函数代码块和那个最内层的代码块那样。 </li>
</ul>
<p>3、这其实有一个很有画面感的查找过程。这个查找过程不只针对于变量，还适用于任何程序实体。如下面所示。</p>
<ul>
<li>首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。</li>
<li>其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块（父级代码块）开始，一层一层地查找。</li>
<li>一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了。</li>
<li>如果我们在当前源码文件中导入了其他代码包，那么引用其中的程序实体时，是需要以限定符为前缀的。所以程序在找代表变量未加限定符的名字（即标识符）的时候，是不会去被导入的代码包中查找的。</li>
</ul>
<p>但有个特殊情况，如果我们把代码包导入语句写成import . “XXX”的形式（注意中间的那个“.”），那么就会让这个“XXX”包中公开的程序实体，被当前源码文件中的代码，视为当前代码包中的程序实体。 比如，如果有代码包导入语句import . fmt，那么我们在当前源码文件中引用fmt.Printf函数的时候直接用Printf就可以了。在这个特殊情况下，程序在查找当前源码文件后会先去查用这种方式导入的那些代码包。</p>
<p>4、从作用域的角度也可以说，虽然通过var block = “package”声明的变量作用域是整个main代码包，但是在main函数中，它却被那两个同名的变量<strong>“屏蔽”</strong>了。<br>  相似的，虽然main函数首先声明的block的作用域，是整个main函数，但是在最内层的那个代码块中，它却是不可能被引用到的。反过来讲，最内层代码块中的block也不可能被该块之外的代码引用到，这也是打印内容的第二行是“The block is function.”的另一半原因。</p>
<h4 id="4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？"><a href="#4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？" class="headerlink" title="4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？"></a>4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？</h4><p>1、为了方便描述，我就把不同代码块中的重名变量叫做“可重名变量”吧。注意，在同一个代码块中不允许出现重名的变量，这违背了 Go 语言的语法。</p>
<p>区别：</p>
<ul>
<li>变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。</li>
<li>变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。</li>
<li>不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。</li>
<li>如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。</li>
</ul>
<p><img src="/2020/07/13/GO：1-4-程序实体/app2.png" alt="app2.png"></p>
<p>2、不同类型的可重名变量例子<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The element is <span class="string">"one"</span>.</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，有两个都叫做container的变量，分别位于main包代码块和main函数代码块。</p>
<p>main包代码块中的变量是切片（slice）类型的，另一个是字典（map）类型的。在main函数的最后，试图打印出container变量的值中索引为1的那个元素。</p>
<p>如果container的类型不是数组、切片或字典类型，那么索引表达式就会引发编译错误。</p>
<p>这正是利用 Go 语言语法，帮我们约束程序的一个例子；但是当我们想知道 container 确切类型的时候，利用索引表达式的方式就不够了。</p>
<p><strong>当可重名变量的值被转换成某个接口类型值，或者它们的类型本身就是接口类型的时候，严格的类型检查就很有必要了。</strong></p>
<h4 id="5、怎样判断一个变量的类型？"><a href="#5、怎样判断一个变量的类型？" class="headerlink" title="5、怎样判断一个变量的类型？"></a>5、怎样判断一个变量的类型？</h4><p>看如下例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>怎样在打印其中元素之前，正确判断变量container的类型？<br>使用<strong>“类型断言”</strong>表达式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">interface</span>&#123;&#125;(container).([]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></p>
<p>完整代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	value, ok := <span class="keyword">interface</span>&#123;&#125;(container).([]<span class="keyword">string</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"The value is %v.\n"</span>, value)</span><br><span class="line">	fmt.Printf(<span class="string">"The ok is %v.\n"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The element is <span class="string">"one"</span>.</span><br><span class="line">The value is [].</span><br><span class="line">The ok is <span class="literal">false</span>.</span><br></pre></td></tr></table></figure></p>
<p>1、这里有一条赋值语句。在赋值符号的右边，是一个类型断言表达式。</p>
<p>它包括了用来把container变量的值转换为空接口值的interface{}(container)。以及一个用于判断前者的类型是否为切片类型 []string  的 .([]string)。</p>
<p>这个表达式的结果可以被赋给两个变量，在这里由value和ok代表。变量ok是布尔（bool）类型的，它将代表类型判断的结果，true或false。</p>
<p>如果是true，那么被判断的值将会被自动转换为[]string类型的值，并赋给变量value，否则value将被赋予nil（即“空”）。这里的ok也可以没有。也就是说，类型断言表达式的结果，可以只被赋给一个变量，在这里是value。但是这样的话，当判断为否时就会引发异常。</p>
<p>这种异常在 Go 语言中被叫做panic，我把它翻译为运行时恐慌。因为它是一种在 Go 程序运行期间才会被抛出的异常，而“恐慌”二字是英文 Panic 的中文直译。除非显式地“恢复”这种“恐慌”，否则它会使 Go 程序崩溃并停止。所以，在一般情况下，我们还是应该使用带ok变量的写法。</p>
<p>如果将类型断言改为：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">interface</span>&#123;&#125;(container).(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></p>
<p>完整代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	value, ok := <span class="keyword">interface</span>&#123;&#125;(container).(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"The value is %v.\n"</span>, value)</span><br><span class="line">	fmt.Printf(<span class="string">"The ok is %v.\n"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The element is <span class="string">"one"</span>.</span><br><span class="line">The value is <span class="keyword">map</span>[<span class="number">0</span>:zero <span class="number">1</span>:one <span class="number">2</span>:two].</span><br><span class="line">The ok is <span class="literal">true</span>.</span><br></pre></td></tr></table></figure></p>
<p>1、类型断言表达式的语法形式是<strong>x.(T)</strong>。其中的x代表要被判断类型的值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的。</p>
<p>2、所以，当这里的container变量类型不是任何的接口类型时，我们就需要先把它转成某个接口类型的值。如果container是某个接口类型的，那么这个类型断言表达式就可以是container.([]string)。</p>
<p>3、在 Go 语言中，interface{}代表空接口，任何类型都是它的实现类型。这里的具体语法是interface{}(x)，例如前面展示的interface{}(container)。</p>
<p>4、你可能会对这里的{}产生疑惑，为什么在关键字interface的右边还要加上这个东西？</p>
<ul>
<li>一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。</li>
<li>比如struct{}，它就代表了不包含任何字段和方法的、空的结构体类型。而空接口interface{}则代表了不包含任何方法定义的、空的接口类型。</li>
<li>当然了，对于一些集合类的数据类型来说，{}还可以用来表示其值不包含任何元素，比如空的切片值[]string{}，以及空的字典值map[int]string{}。<br><img src="/2020/07/13/GO：1-4-程序实体/app3.png" alt="app3.png"></li>
</ul>
<h4 id="6、类型转换规则中有哪些值得注意的地方？"><a href="#6、类型转换规则中有哪些值得注意的地方？" class="headerlink" title="6、类型转换规则中有哪些值得注意的地方？"></a>6、类型转换规则中有哪些值得注意的地方？</h4><p>1、类型转换表达式的语法形式：<strong>T(x)</strong>。</p>
<p>其中的x可以是一个变量，也可以是一个代表值的字面量（比如1.23和struct{}{}），还可以是一个表达式。注意，如果是表达式，那么该表达式的结果只能是一个值，而不能是多个值。</p>
<p>在这个上下文中，x可以被叫做源值，它的类型就是源类型，而那个T代表的类型就是目标类型。如果从源类型到目标类型的转换是不合法的，那么就会引发一个编译错误。</p>
<p>2、三个注意点</p>
<ul>
<li>1、<strong>对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。</strong></li>
</ul>
<p>比如，之所以uint8(255)可以把无类型的常量255转换为uint8类型的值，是因为255在[0, 255]的范围内。</p>
<p>但需要特别注意的是，源整数类型的可表示范围较大，而目标类型的可表示范围较小的情况，比如把值的类型从int16转换为int8。请看下面这段代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> srcInt = <span class="keyword">int16</span>(<span class="number">-255</span>)</span><br><span class="line">dstInt := <span class="keyword">int8</span>(srcInt)<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>变量srcInt的值是int16类型的-255，而变量dstInt的值是由前者转换而来的，类型是int8。int16类型的可表示范围可比int8类型大了不少。</p>
<p>问题是，dstInt的值是多少？<br>首先你要知道，整数在 Go 语言以及计算机中都是以补码的形式存储的。这主要是为了简化计算机对整数的运算过程。补码其实就是原码各位求反再加 1。</p>
<p>比如，int16类型的值-255的补码是1111111100000001。如果我们把该值转换为int8类型的值，那么 Go 语言会把在较高位置（或者说最左边位置）上的 8 位二进制数直接截掉，从而得到00000001。又由于其最左边一位是0，表示它是个正整数，以及正整数的补码就等于其原码，所以<strong>dstInt的值就是1</strong>。</p>
<p>一定要记住，当整数值的类型的有效范围由宽变窄时，只需在补码形式下截掉一定数量的高位二进制数即可。</p>
<p>类似的快刀斩乱麻规则还有：当把一个浮点数类型的值转换为整数类型值时，前者的小数部分会被全部截掉。</p>
<ul>
<li>2、<strong>虽然直接把一个整数值转换为一个string类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的 Unicode 代码点，否则转换的结果将会是”�”（仅由高亮的问号组成的字符串值）。</strong><br>字符’�’的 Unicode 代码点是U+FFFD。它是 Unicode 标准中定义的 Replacement Character，专用于替换那些未知的、不被认可的以及无法展示的字符。<br>如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>(<span class="number">-1</span>)  <span class="comment">//�"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于-1肯定无法代表一个有效的 Unicode 代码点，所以得到的总会是”�”。</p>
<ul>
<li>3、string类型与各种切片类型之间的互转<br><strong>一个值在从string类型向[]byte类型转换时代表着以 UTF-8 编码的字符串会被拆分成零散、独立的字节。</strong></li>
</ul>
<p>除了与 ASCII 编码兼容的那部分字符集，以 UTF-8 编码的某个单一字节是无法代表一个字符的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>([]<span class="keyword">byte</span>&#123;<span class="string">'\xe4'</span>, <span class="string">'\xbd'</span>, <span class="string">'\xa0'</span>, <span class="string">'\xe5'</span>, <span class="string">'\xa5'</span>, <span class="string">'\xbd'</span>&#125;) <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure></p>
<p>比如，UTF-8 编码的三个字节\xe4、\xbd和\xa0合在一起才能代表字符’你’，而\xe5、\xa5和\xbd合在一起才能代表字符’好’。</p>
<p><strong>一个值在从string类型向[]rune类型转换时代表着字符串会被拆分成一个个 Unicode 字符。</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>([]<span class="keyword">rune</span>&#123;<span class="string">'\u4F60'</span>, <span class="string">'\u597D'</span>&#125;) <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure></p>
<h4 id="7、什么是别名类型？什么是潜在类型？"><a href="#7、什么是别名类型？什么是潜在类型？" class="headerlink" title="7、什么是别名类型？什么是潜在类型？"></a>7、什么是别名类型？什么是潜在类型？</h4><p>我们可以用关键字type声明自定义的各种类型。这些类型必须在 Go 语言基本类型和高级类型的范畴之内。在它们当中，有一种被叫做“别名类型”的类型。我们可以像下面这样声明它：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString = <span class="keyword">string</span></span><br></pre></td></tr></table></figure></p>
<p>这条声明语句表示，MyString是string类型的别名类型。顾名思义，别名类型与其源类型的区别只是在名称上，它们是完全相同的。</p>
<p><strong>源类型与别名类型是一对概念</strong>，是两个对立的称呼。别名类型主要是为了代码重构而存在的。</p>
<p>Go 语言内建的基本类型中就存在两个别名类型<strong>。byte是uint8的别名类型，而rune是int32的别名类型。</strong></p>
<p>一定要注意，如果我这样声明：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="keyword">string</span>  <span class="comment">// 注意，这里没有等号。</span></span><br></pre></td></tr></table></figure></p>
<p>MyString2和string就是两个不同的类型了。这里的MyString2是一个新的类型，不同于其他任何类型。</p>
<p>这种方式也可以被叫做对<strong>类型的再定义</strong>。我们刚刚把string类型再定义成了另外一个类型MyString2。<br><img src="/2020/07/13/GO：1-4-程序实体/app4.png" alt="app4.png"></p>
<p>对于这里的类型再定义来说，string可以被称为MyString2的潜在类型。<strong>潜在类型</strong>的含义是，<strong>某个类型在本质上是哪个类型。</strong></p>
<p><strong>潜在类型相同的不同类型的值之间是可以进行类型转换的</strong>。因此，<strong>MyString2类型的值与string类型的值可以使用类型转换表达式进行互转</strong>。</p>
<p><strong>但对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，因为[]MyString2与[]string的潜在类型不同，分别是[]MyString2和[]string。</strong></p>
<p>另外，<strong>即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/13/GO：1-4-程序实体/" data-id="ckcukir620002h8vi2acxe801" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：1-3-库源码文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/12/GO：1-3-库源码文件/" class="article-date">
  <time datetime="2020-07-12T08:01:56.000Z" itemprop="datePublished">2020-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/12/GO：1-3-库源码文件/">GO：1.3 库源码文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、什么是库源码文件？"><a href="#1、什么是库源码文件？" class="headerlink" title="1、什么是库源码文件？"></a>1、什么是库源码文件？</h3><p>1、<strong>库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体</strong>，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）。</p>
<p>2、这里的“其他代码”可以与被使用的程序实体在同一个源码文件内，也可以在其他源码文件，甚至其他代码包中。</p>
<p>3、程序实体是什么？<br>在 Go 语言中，<strong>程序实体是变量、常量、函数、结构体和接口的统称</strong>。</p>
<ul>
<li>我们总是会先声明（或者说定义）程序实体，然后再去使用。</li>
<li>程序实体的名字被统称为标识符。标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。</li>
<li>从规则上说，我们可以用中文作为变量的名字。但是不建议这样做。</li>
</ul>
<h3 id="2、怎样把命令源码文件中的代码拆分到其他库源码文件？"><a href="#2、怎样把命令源码文件中的代码拆分到其他库源码文件？" class="headerlink" title="2、怎样把命令源码文件中的代码拆分到其他库源码文件？"></a>2、怎样把命令源码文件中的代码拆分到其他库源码文件？</h3><p>如果在某个目录下有一个命令源码文件 demo4.go，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  hello(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>demo4.go 在调用了hello函数，函数hello被声明在了另外一个源码文件中，我把它命名为 demo4_lib.go，并且放在与 demo4.go 相同的目录main下（在同一个目录下的源码文件都需要被声明为属于同一个代码包。）。如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：如果该目录下有一个命令源码文件，那么为了让同在一个目录下的文件都通过编译，其他源码文件应该也声明属于main包。</p>
<p>现在运行它们，比如，我们可以在这些文件所在的目录下运行如下命令并得到相应的结果。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run demo4.<span class="keyword">go</span> demo4_lib.<span class="keyword">go</span> </span><br><span class="line">Hello, everyone!</span><br></pre></td></tr></table></figure></p>
<p>或者，像下面这样先构建当前的代码包再运行。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build puzzlers/article3/q1</span><br><span class="line">$ ./q1            </span><br><span class="line">Hello, everyone!</span><br></pre></td></tr></table></figure></p>
<p>1、在这里，我把 demo4.go 和 demo4_lib.go 都放在了一个相对路径为puzzlers/article3/q1的目录中。</p>
<p>2、在默认情况下，相应的代码包的导入路径会与此一致。我们可以通过代码包的导入路径引用其中声明的程序实体。但是，这里的情况是不同的。</p>
<p>3、注意，demo4.go 和 demo4_lib.go 都声明自己属于main包。我在前面讲 Go 语言源码的组织方式的时候提到过这种用法，即：源码文件声明的包名可以与其所在目录的名称不同，只要这些文件声明的包名一致就可以。</p>
<p>4、代码包声明的基本规则：</p>
<ul>
<li>同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。如果目录中有命令源码文件，那么其他种类的源码文件也应该声明属于main包。这也是我们能够成功构建和运行它们的前提。</li>
<li>源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。对于命令源码文件而言，构建生成的可执行文件的主名称会与其父目录的名称相同</li>
</ul>
<p>###3、怎样把命令源码文件中的代码拆分到其他代码包？<br>1、把 demo4.go 另存为 demo5.go，并放到一个相对路径为puzzlers/article3/q2的目录中。</p>
<p>2、然后再创建一个相对路径为puzzlers/article3/q2/lib的目录，再把 demo4_lib.go 复制一份并改名为 demo5_lib.go 放到该目录中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lib5</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里修改了两个地方。</p>
<ul>
<li>第一个改动是，把代码包声明语句由package main改为了package lib5。注意，故意让声明的包名与其所在的目录的名称不同。</li>
<li><p>第二个改动是，把全小写的函数名hello改为首字母大写的Hello。</p>
<p>基于以上改动，我们再来看下面的几个问题。</p>
</li>
</ul>
<h4 id="1、代码包的导入路径总会与其所在目录的相对路径一致吗？"><a href="#1、代码包的导入路径总会与其所在目录的相对路径一致吗？" class="headerlink" title="1、代码包的导入路径总会与其所在目录的相对路径一致吗？"></a>1、代码包的导入路径总会与其所在目录的相对路径一致吗？</h4><p>库源码文件 demo5_lib.go 所在目录的相对路径是puzzlers/article3/q2/lib，而它却声明自己属于lib5包。在这种情况下，该包的导入路径是puzzlers/article3/q2/lib，还是puzzlers/article3/q2/lib5？<br>1、首先，我们在构建或者安装这个代码包的时候，提供给go命令的路径应该是目录的相对路径，就像这样：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> install puzzlers/article3/q2/lib</span><br></pre></td></tr></table></figure></p>
<p>该命令会成功完成。之后，当前工作区的 pkg 子目录下会产生相应的归档文件，具体的相对路径是:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg/darwin_amd64/puzzlers/article3/q2/lib.a</span><br></pre></td></tr></table></figure></p>
<p>其中的darwin_amd64就是我在讲工作区时提到的平台相关目录。可以看到，这里与源码文件所在目录的相对路径是对应的。</p>
<p>2、为了进一步说明问题，需要先对 demo5.go 做两个改动。</p>
<ul>
<li>第一个改动是，在以import为前导的代码包导入语句中加入puzzlers/article3/q2/lib，也就是试图导入这个代码包。</li>
<li>第二个改动是，把对hello函数的调用改为对lib.Hello函数的调用。其中的lib.叫做限定符，旨在指明右边的程序实体所在的代码包。不过这里与代码包导入路径的完整写法不同，只包含了路径中的最后一级lib，这与代码包声明语句中的规则一致。</li>
</ul>
<p>现在，通过运行go run demo5.go命令试一试。错误提示会类似于下面这种。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./demo5.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">2</span>: imported and not used: <span class="string">"puzzlers/article3/q2/lib"</span> as lib5</span><br><span class="line">./demo5.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">2</span>: undefined: lib</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一个错误提示的意思是，我们导入了puzzlers/article3/q2/lib包，但没有实际使用其中的任何程序实体。这在 Go 语言中是不被允许的，在编译时就会导致失败。</li>
<li>这里还有另外一个线索，那就是“as lib5”。这说明虽然导入了代码包puzzlers/article3/q2/lib，但是使用其中的程序实体的时候应该以lib5.为限定符。这也就是第二个错误提示的原因了。Go 命令找不到lib.这个限定符对应的代码包。</li>
</ul>
<p>3、为什么会是这样？<br>根本原因就是，我们在源码文件中声明所属的代码包与其所在目录的名称不同。请记住，源码文件所在的目录相对于 src 目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符要与它声明所属的代码包名称对应。</p>
<p>有两个方式可以使上述构建成功完成。我在这里选择把 demo5_lib.go 文件中的代码包声明语句改为package lib。理由是，为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。</p>
<h4 id="2、什么样的程序实体才可以被当前包外的代码引用？"><a href="#2、什么样的程序实体才可以被当前包外的代码引用？" class="headerlink" title="2、什么样的程序实体才可以被当前包外的代码引用？"></a>2、什么样的程序实体才可以被当前包外的代码引用？</h4><p>1、为什么要把 demo5_lib.go 文件中的那个函数名称hello的首字母大写？<br>实际上这涉及了 Go 语言中对于程序实体访问权限的规则。超级简单，<strong>名称的首字母为大写的程序实体才可以被当前包外的代码引用</strong>，否则它就只能被当前包内的其他代码引用。通过名称，Go 语言自然地把程序实体的访问权限划分为了<strong>包级私有的和公开的</strong>。<strong>对于包级私有的程序实体，即使你导入了它所在的代码包也无法引用到它。</strong></p>
<h4 id="3、对于程序实体，还有其他的访问权限规则吗？"><a href="#3、对于程序实体，还有其他的访问权限规则吗？" class="headerlink" title="3、对于程序实体，还有其他的访问权限规则吗？"></a>3、对于程序实体，还有其他的访问权限规则吗？</h4><p>1、答案是肯定的。在 Go 1.5 及后续版本中，我们可以通过创建internal代码包让一些程序实体仅仅能被当前模块中的其他代码引用。这被称为 Go 程序实体的第三种访问权限：<strong>模块级私有</strong>。</p>
<p>2、具体规则是，<strong>internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用</strong>。当然，引用前需要先导入这个internal包。<strong>对于其他代码包，导入该internal包都是非法的，无法通过编译</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/12/GO：1-3-库源码文件/" data-id="ckcukir600001h8vidfrvfpyg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：1-2-命令源码文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/GO：1-2-命令源码文件/" class="article-date">
  <time datetime="2020-07-10T11:25:13.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/GO：1-2-命令源码文件/">GO：1.2 命令源码文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们已经知道，环境变量 GOPATH 指向的是一个或多个工作区，每个工作区中都会有以代码包为基本组织形式的源码文件。</p>
<p>这里的源码文件又分为三种，即：<strong>命令源码文件、库源码文件和测试源码文件</strong>，它们都有着不同的用途和编写规则。<br><img src="/2020/07/10/GO：1-2-命令源码文件/command1.png" alt="command1.png"></p>
<h3 id="1、命令源码文件的用途是什么，怎样编写它？"><a href="#1、命令源码文件的用途是什么，怎样编写它？" class="headerlink" title="1、命令源码文件的用途是什么，怎样编写它？"></a>1、命令源码文件的用途是什么，怎样编写它？</h3><p>1、命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。</p>
<p>2、如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么它就是命令源码文件。 就像下面这段代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello, world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你把这段代码存成 demo1.go 文件，那么运行go run demo1.go命令后就会在屏幕（标准输出）中看到Hello, world!</p>
<p>注：<br>1、当需要模块化编程时，我们往往会将代码拆分到多个文件，甚至拆分到不同的代码包中。但无论怎样，对于一个独立的程序来说，<strong>命令源码文件永远只会也只能有一个</strong>。如果有与命令源码文件同包的源码文件，那么它们也应该声明属于main包。</p>
<p>2、通过构建或安装命令源码文件，<strong>生成的可执行文件就可以被视为“命令”</strong>，既然是命令，那么就应该具备接收参数的能力。</p>
<h3 id="2、命令源码文件怎样接收参数"><a href="#2、命令源码文件怎样接收参数" class="headerlink" title="2、命令源码文件怎样接收参数"></a>2、命令源码文件怎样接收参数</h3><p>先看下面代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span><span class="comment">//1步</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//2步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、函数flag.StringVar接受 4 个参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、第 1 个参数是用于存储该命令参数值的地址，具体到这里就是在前面声明的变量name的地址了，由表达式&amp;name表示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、第 2 个参数是为了指定该命令参数的名称，这里是name。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、第 3 个参数是为了指定在未追加该命令参数时的默认值，这里是everyone。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、第 4 个函数参数，即是该命令参数的简短说明了，这在打印命令说明时会用到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()<span class="comment">//函数flag.Parse用于真正解析命令参数，并把它们的值赋给相应的变量。</span></span><br><span class="line">  <span class="comment">//3步</span></span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对该函数的调用必须在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是在[2]处对flag.StringVar函数的调用）之后，并且在读取任何命令参数值之前进行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">正因为如此，我们最好把flag.Parse()放在main函数的函数体的第一行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>注：还有一个与flag.StringVar函数类似的函数，叫flag.String。这两个函数的区别是，后者会直接返回一个已经分配好的用于存储命令参数值的地址。如果使用它的话，我们就需要把“var name string”改为<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明"><a href="#3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明" class="headerlink" title="3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明"></a>3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明</h3><p>我们把上述代码存成名为 demo2.go 的文件，那么运行如下命令就可以为参数name传值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run demo2.<span class="keyword">go</span> -name=<span class="string">"Robert"</span></span><br></pre></td></tr></table></figure></p>
<p>运行后，打印到标准输出（stdout）的内容会是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Robert!</span><br></pre></td></tr></table></figure></p>
<p>另外，如果想查看该命令源码文件的参数说明，可以这样做：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run demo2.<span class="keyword">go</span> --help</span><br></pre></td></tr></table></figure></p>
<p>其中的$表示我们是在命令提示符后运行go run命令的。运行后输出的内容会类似：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage of /<span class="keyword">var</span>/folders/ts/<span class="number">7</span>lg_tl_x2gd_k1lm5g_48c7w0000gn/T/<span class="keyword">go</span>-build155438482/b001/exe/demo2:</span><br><span class="line"> -name <span class="keyword">string</span></span><br><span class="line">    The greeting object. (<span class="keyword">default</span> <span class="string">"everyone"</span>)</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>以下是go run命令构建上述命令源码文件时临时生成的可执行文件的完整路径<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">var</span>/folders/ts/<span class="number">7</span>lg_tl_x2gd_k1lm5g_48c7w0000gn/T/<span class="keyword">go</span>-build155438482/b001/exe/demo2</span><br></pre></td></tr></table></figure></p>
<p>如果我们先构建这个命令源码文件再运行生成的可执行文件，像这样：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build demo2.<span class="keyword">go</span></span><br><span class="line">$ ./demo2 --help</span><br></pre></td></tr></table></figure></p>
<p>那么输出就会是<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage of ./demo2:</span><br><span class="line"> -name <span class="keyword">string</span></span><br><span class="line">    The greeting object. (<span class="keyword">default</span> <span class="string">"everyone"</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="4、怎样自定义命令源码文件的参数使用说明"><a href="#4、怎样自定义命令源码文件的参数使用说明" class="headerlink" title="4、怎样自定义命令源码文件的参数使用说明"></a>4、怎样自定义命令源码文件的参数使用说明</h3><p>1、最简单的一种方式就是对变量flag.Usage重新赋值。</p>
<p>flag.Usage的类型是func()，即一种无参数声明且无结果声明的函数类型。flag.Usage变量在声明时就已经被赋值了，所以我们才能够在运行命令go run demo2.go –help时看到正确的结果。注意，对flag.Usage的赋值必须在调用flag.Parse函数之前。现在，我们把 demo2.go 另存为 demo3.go，然后在main函数体的开始处加入如下代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span><span class="comment">//1步</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//2步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     fmt.Fprintf(os.Stderr, <span class="string">"Usage of %s:\n"</span>, <span class="string">"question"</span>)</span><br><span class="line">     flag.PrintDefaults()</span><br><span class="line">    &#125;</span><br><span class="line">  flag.Parse()<span class="comment">//函数flag.Parse用于真正解析命令参数，并把它们的值赋给相应的变量。</span></span><br><span class="line">  <span class="comment">//3步</span></span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run demo3.<span class="keyword">go</span> --help</span><br></pre></td></tr></table></figure></p>
<p>后，就会看到<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage of question:</span><br><span class="line"> -name <span class="keyword">string</span></span><br><span class="line">    The greeting object. (<span class="keyword">default</span> <span class="string">"everyone"</span>)</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>2、现在再深入一层，我们在调用flag包中的一些函数（比如StringVar、Parse等等）的时候，实际上是在调用flag.CommandLine变量的对应方法。</p>
<p><strong>flag.CommandLine相当于默认情况下的命令参数容器</strong>。所以，通过对flag.CommandLine重新赋值，我们可以更深层次地定制当前命令源码文件的参数使用说明。</p>
<p>现在我们把main函数体中的那条对flag.Usage变量的赋值语句注销掉，然后在init函数体的开始处添加如下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span><span class="comment">//1步</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.CommandLine = flag.NewFlagSet(<span class="string">""</span>, flag.ExitOnError)</span><br><span class="line">  flag.CommandLine.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Fprintf(os.Stderr, <span class="string">"Usage of %s:\n"</span>, <span class="string">"question"</span>)</span><br><span class="line">  flag.PrintDefaults()</span><br><span class="line">&#125;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//2步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()<span class="comment">//函数flag.Parse用于真正解析命令参数，并把它们的值赋给相应的变量。</span></span><br><span class="line">  <span class="comment">//3步</span></span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再运行命令go run demo3.go –help后，其输出会与上一次的输出的一致。不过后面这种定制的方法更加灵活。比如，当我们把为flag.CommandLine赋值的那条语句改为<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.CommandLine = flag.NewFlagSet(<span class="string">""</span>, flag.PanicOnError)</span><br></pre></td></tr></table></figure></p>
<p>后，再运行go run demo3.go –help命令就会产生另一种输出效果。这是由于我们在这里传给flag.NewFlagSet函数的第二个参数值是flag.PanicOnError。</p>
<ul>
<li>1、flag.PanicOnError和flag.ExitOnError都是预定义在flag包中的常量。</li>
<li>2、flag.ExitOnError的含义是，告诉命令参数容器，当命令后跟–help或者参数设置的不正确的时候，在打印命令参数使用说明后以状态码2结束当前程序。</li>
<li>状态码2代表用户错误地使用了命令，而flag.PanicOnError与之的区别是在最后抛出“运行时恐慌（panic）”。</li>
<li>上述两种情况都会在我们调用flag.Parse函数时被触发。</li>
</ul>
<p>3、下面再进一步，我们索性不用全局的flag.CommandLine变量，转而自己创建一个私有的命令参数容器。我们在函数外再添加一个变量声明：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cmdLine = flag.NewFlagSet(<span class="string">"question"</span>, flag.ExitOnError)</span><br></pre></td></tr></table></figure></p>
<p>然后，我们把对flag.StringVar的调用替换为对cmdLine.StringVar调用，再把flag.Parse()替换为cmdLine.Parse(os.Args[1:])。</p>
<p>其中的os.Args[1:]指的就是我们给定的那些命令参数。这样做就完全脱离了flag.CommandLine。</p>
<p>这样做的好处依然是更灵活地定制命令参数容器。但更重要的是，你的定制完全不会影响到那个全局变量flag.CommandLine。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/10/GO：1-2-命令源码文件/" data-id="ckcukir5w0000h8vicv7tszib" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：工作区和GOPATH" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/GO：工作区和GOPATH/" class="article-date">
  <time datetime="2020-07-10T06:27:34.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/GO：工作区和GOPATH/">GO：工作区和GOPATH</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、Go基础知识导图"><a href="#1、Go基础知识导图" class="headerlink" title="1、Go基础知识导图"></a>1、Go基础知识导图</h3><p><img src="/2020/07/10/GO：工作区和GOPATH/go1.jpg" alt="go1.jpg"></p>
<h3 id="2、工作区和GOPATH"><a href="#2、工作区和GOPATH" class="headerlink" title="2、工作区和GOPATH"></a>2、工作区和GOPATH</h3><h4 id="1、Go-3个环境变量"><a href="#1、Go-3个环境变量" class="headerlink" title="1、Go 3个环境变量"></a>1、Go 3个环境变量</h4><ul>
<li>GOROOT：Go语言安装根目录的路径，也就是GO语言的安装路径</li>
<li>GOPATH：若干工作区目录的路径，是我们自己定义的工作空间</li>
<li>GOBIN：Go程序生成的可执行文件的路径</li>
</ul>
<h4 id="2、GOPATH有什么意义"><a href="#2、GOPATH有什么意义" class="headerlink" title="2、GOPATH有什么意义"></a>2、GOPATH有什么意义</h4><ol>
<li><p>可以把GOPATH简单理解成Go语言的工作目录，它的值是一个目录的路径，也可以是多个目录的路径，每个目录都代表Go语言的一个工作区。</p>
</li>
<li><p>我们需要利用这些工作区去放置Go语言的源码文件，以及安装（install）后的归档文件（archive file，也就是以.a为扩展名的文件）和可执行文件。</p>
</li>
<li><p>Go语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本都是围绕GOPATH和工作区进行的。</p>
</li>
</ol>
<p>go build 命令一些可选项的用途和用法</p>
<h4 id="1、Go-语言源码的组织方式是怎样的？"><a href="#1、Go-语言源码的组织方式是怎样的？" class="headerlink" title="1、Go 语言源码的组织方式是怎样的？"></a>1、Go 语言源码的组织方式是怎样的？</h4><p>1、Go语言的源码也是以代码包为基本组织单位的。在文件系统中，这些代码包与目录一一对应。目录有子目录，代码包也可以有子包。</p>
<p>2、一个代码包可以包含任意个以.go为扩展名的原码文件，这些源码文件都需要被声明属于同一个代码包。</p>
<p>3、代码包的名称一般会与源码文件所在目录同名。如果不同名，在构建、安装时会以代码包名称为准。</p>
<p>4、每个代码包都有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/labstack/echo"</span></span><br></pre></td></tr></table></figure></p>
<p>5、在工作区中，一个代码包的导入路径实际上就是从src子目录到该包的实际存储位置的相对路径。</p>
<p>6、所以说，Go语言源码的组织方式就是以环境变量GOPATH、工作区、src目录个代码包为主线的。一般情况下，Go语言的源码文件都需要存放在环境变量GOPATH包含的某个工作区（目录）中的src目录下的某个代码包（目录）中。</p>
<h4 id="2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）"><a href="#2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）" class="headerlink" title="2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）"></a>2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）</h4><p>1、源码文件通常会被放在某个工作区的src子目录下</p>
<p>2、安装后如果产生了归档文件（以.a为扩展名的文件）会被放进该工作区的pkg子目录</p>
<p>3、如果产生了可执行文件，就可能会被放在该工作区的bin子目录下。</p>
<p><strong>归档文件存放具体位置和规则：</strong><br>1、源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件就是与这个代码包同名的。</p>
<p>2、放置它的相对目录就是该代码包的导入路径的直接父级。比如，一个已存在的代码包的导入路径是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com/labstack/echo</span><br></pre></td></tr></table></figure></p>
<p>那么执行命令<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> insatll github.com/labstack/echo</span><br></pre></td></tr></table></figure></p>
<p>生成的归档文件的相对目录就是github.com/labstack，文件名为echo.a。</p>
<p>3、上面这个代码包导入路径还有一层含义，即：该代码包的源码文件存在于github网站的labstack组的代码仓库echo中</p>
<p>4、归档文件的相对目录与pkg目录之间还有一级目录，称为平台相关目录。平台相关目录的名称是由“build”的目标操作系统、下划线和目标计算架构的代号组成的。比如，构建某个代码包的目标擦欧总系统时Linux，目标计算架构是64位，对应的平台相关目录就是linux_amd64。<br>因此，上述代码包的归档文件就会被放置在当前工作区的子目录<br>pkg/linux_amd64/github.com/labstack中。<br>gopath与工作区：<br><img src="/2020/07/10/GO：工作区和GOPATH/gopath1.png" alt="gopath1.png"></p>
<p>5、某个工作区的src子目录下的源码文件在安装后一般会被放置到当前工作区的pkg子目录下对应的目录中，或者直接被放置到该工作区的bin子目录中。</p>
<h4 id="3、理解构建和安装Go程序的过程"><a href="#3、理解构建和安装Go程序的过程" class="headerlink" title="3、理解构建和安装Go程序的过程"></a>3、理解构建和安装Go程序的过程</h4><p>构建与安装的异同：<br>1、构建使用命令go build，安装使用命令go install。构建和安装代码包的时候都会执行编译、打包等操作，并且，这些操作生成的任何文件都会先被保存到某个临时的目录中。</p>
<p>2、构建源码文件</p>
<ul>
<li>如果构建的是库源码文件</li>
</ul>
<p>那么操作后产生的结果只会存在于临时目录中，这里构建的主要意义在于检查和验证；</p>
<ul>
<li>如果构建的是命令源码文件</li>
</ul>
<p>操作的结果文件会被搬运到源码文件所在的目录中。</p>
<p>3、安装过程会先执行构建、然后还会进行你链接操作，并且把结果文件搬运到指定目录。如：</p>
<ul>
<li>安装库源码文件，结果文件被搬运到他所在工作区的pkg目录下的某个子目录中；</li>
<li>安装命令源码文件，结果文件被搬运到他所在工作区的bin目录中，或者环境变量GOBIN指向的目录中。</li>
</ul>
<h3 id="4、go-build-命令一些可选项的用途和用法"><a href="#4、go-build-命令一些可选项的用途和用法" class="headerlink" title="4、go build 命令一些可选项的用途和用法"></a>4、go build 命令一些可选项的用途和用法</h3><p>1、在运行go build命令的时候，默认不会编译目标代码包所依赖的那些代码包。</p>
<p>2、如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。</p>
<p>3、如果要强制编译它们，可以在执行命令的时候加入标记-a。此时，不但目标代码包总是会被编译，它依赖的代码包也总会被编译，即使依赖的是标准库中的代码包也是如此。</p>
<p>5、另外，如果不但要编译依赖的代码包，还要安装它们的归档文件，那么可以加入标记-i。</p>
<p>6、那么我们怎么确定哪些代码包被编译了呢？有两种方法。</p>
<ul>
<li>运行go build命令时加入标记-x，这样可以看到go build命令具体都执行了哪些操作。另外也可以加入标记-n，这样可以只查看具体操作而不执行它们。</li>
<li>运行go build命令时加入标记-v，这样可以看到go build命令编译的代码包的名称。它在与-a标记搭配使用时很有用。</li>
</ul>
<p>7、下面再说一说与 Go 源码的安装联系很紧密的一个命令：go get。<br>命令go get会自动从一些主流公用代码仓库（比如 GitHub）下载目标代码包，并把它们安装到环境变量GOPATH包含的第 1 工作区的相应目录中。如果存在环境变量GOBIN，那么仅包含命令源码文件的代码包会被安装到GOBIN指向的那个目录。</p>
<p>最常用的几个标记有下面几种。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-u：下载并安装代码包，不论工作区中是否已存在它们。</span><br><span class="line"></span><br><span class="line">-d：只下载代码包，不安装代码包。</span><br><span class="line"></span><br><span class="line">-fix：在下载代码包后先运行一个用于根据当前 Go 语言版本修正代码的工具，然后再安装代码包。</span><br><span class="line"></span><br><span class="line">-t：同时下载测试所需的代码包。</span><br><span class="line"></span><br><span class="line">-insecure：允许通过非安全的网络协议下载和安装代码包。HTTP 就是这样的协议。</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/10/GO：工作区和GOPATH/" data-id="ckcukir650006h8vigex3k6q9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hexo博客迁移" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/02/hexo博客迁移/" class="article-date">
  <time datetime="2020-07-02T07:53:23.000Z" itemprop="datePublished">2020-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/02/hexo博客迁移/">hexo博客迁移</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、安装hexo博客必要的软件"><a href="#1、安装hexo博客必要的软件" class="headerlink" title="1、安装hexo博客必要的软件"></a>1、安装hexo博客必要的软件</h4><p>1、下载安装Git客户端<br>2、安装node js</p>
<h4 id="2、Github添加新电脑生成的密钥"><a href="#2、Github添加新电脑生成的密钥" class="headerlink" title="2、Github添加新电脑生成的密钥"></a>2、Github添加新电脑生成的密钥</h4><p>打开git bash输入如下命令：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"xxxxx@xxx.com"</span></span><br></pre></td></tr></table></figure></p>
<p>邮箱为GitHub注册邮箱，输入命令后直接回车，生成密钥对。根据提示找到密钥对所在位置，将id_rsa.pub公钥内容复制粘贴到Github-settings-‘SSH and GPG keys’-‘SSH keys’中。</p>
<p>使用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com   测试公钥是否添加成功</span><br></pre></td></tr></table></figure></p>
<h4 id="3、备份原文件"><a href="#3、备份原文件" class="headerlink" title="3、备份原文件"></a>3、备份原文件</h4><p>需要转移的文件有：<br><img src="/2020/07/02/hexo博客迁移/hexo1.png" alt="hexo1"><br>由于配置文件和主题文件需要经常更改，采用github创建博客分支的方式进行备份。</p>
<p><strong>1、创建分支</strong><br> 克隆github上上生成的静态文件到hexo文件夹中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/yourname/xxxx.github.io.git hexo</span></span><br></pre></td></tr></table></figure></p>
<p>克隆后将除.git文件外其他所有文件删除。主要是为了得到版本管理文件夹.git（.git文件为隐藏文件，可直接将可见文件全部删除）。</p>
<p><strong>2、将备份的原文件复制到此文件夹</strong><br>若文件夹是从github克隆，则需要删除主题文件中的版本控制文件夹,以next主题为例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf thems/next/.git*</span><br></pre></td></tr></table></figure></p>
<p>创建名为hexo的分支<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hexo</span><br></pre></td></tr></table></figure></p>
<p>保存所有文件到暂存区<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all</span><br></pre></td></tr></table></figure></p>
<p>提交变更<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"hexo-2"</span></span><br></pre></td></tr></table></figure></p>
<p>提交变更时报错：<br><img src="/2020/07/02/hexo博客迁移/hexo2.png" alt="hexo2"><br>根据提示配置。<br>推送分支到github,并用–set-upstream与origin创建关联，将hexo设置为默认分支<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --set-upstream origin hexo</span><br></pre></td></tr></table></figure></p>
<h4 id="4、迁移"><a href="#4、迁移" class="headerlink" title="4、迁移"></a>4、迁移</h4><p>以后在其他电脑上写博客，直接将分支克隆下来。再使用npm install安装依赖。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b hexo https:<span class="comment">//github.com/yourname/xxx.github.io.git</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<h4 id="5、发表文章"><a href="#5、发表文章" class="headerlink" title="5、发表文章"></a>5、发表文章</h4><p>1、新建文章<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure></p>
<p>2、注意：需要使用git push把源文件推到分支上<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"xxxx"</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p>
<p>3、部署文章<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p>
<p>参考：<br>1、<a href="https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/" target="_blank" rel="noopener">https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/</a></p>
<p>2、<a href="https://blog.csdn.net/white_idiot/article/details/80685990" target="_blank" rel="noopener">https://blog.csdn.net/white_idiot/article/details/80685990</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/02/hexo博客迁移/" data-id="ckcukir6w0010h8vik3985ke7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-测试驱动开发TDD" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/15/测试驱动开发TDD/" class="article-date">
  <time datetime="2020-06-15T06:27:12.000Z" itemprop="datePublished">2020-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/15/测试驱动开发TDD/">测试驱动开发TDD</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="测试驱动开发TDD（Test-Driven-Development）"><a href="#测试驱动开发TDD（Test-Driven-Development）" class="headerlink" title="测试驱动开发TDD（Test Driven Development）"></a>测试驱动开发TDD（Test Driven Development）</h2><h3 id="1、什么是-TDD"><a href="#1、什么是-TDD" class="headerlink" title="1、什么是 TDD"></a>1、什么是 TDD</h3><h4 id="1、TDD-有广义和狭义之分"><a href="#1、TDD-有广义和狭义之分" class="headerlink" title="1、TDD 有广义和狭义之分"></a>1、TDD 有广义和狭义之分</h4><p>1、常说的是狭义的TDD，也就是单元测试驱动开发UTDD（Unit Test Driven Development）；</p>
<p>2、广义的TDD：是验收测试驱动开发ATDD（Acceptance Test Driven Development），<br>包括行为驱动开发BDD（Behavior Driven Development）和消费者驱动契约开发Consumer-Driven Contracts Development 等。</p>
<h4 id="2、TDD-有三层含义："><a href="#2、TDD-有三层含义：" class="headerlink" title="2、TDD 有三层含义："></a>2、TDD 有三层含义：</h4><ul>
<li>Test-Driven Development，测试驱动开发。</li>
<li>Task-Driven Development，任务驱动开发，要对问题进行分析并进行任务分解。</li>
<li>Test-Driven Design，测试保护下的设计改善。TDD 并不能直接提高设计能力，它只是给你更多机会和保障去改善设计。</li>
</ul>
<h4 id="3、TDD-流程"><a href="#3、TDD-流程" class="headerlink" title="3、TDD 流程"></a>3、TDD 流程</h4><p>TDD 的基本流程是：红，绿，重构。<br><img src="/2020/06/15/测试驱动开发TDD/tdd2.jpg" alt="tdd2"></p>
<p>更详细的流程是：<br><img src="/2020/06/15/测试驱动开发TDD/tdd1.jpg" alt="tdd1"></p>
<p>1、编写测试<br>2、运行测试，观察测试结果是否如期失败（变红）<br>3、测试结果不如期失败，返回第1步修改测试<br>4、测试结果如期失败，编写刚好能够让测试通过的产品代码实现<br>5、运行测试，观察测试结果是否如期成功（变绿）<br>6、测试结果不如期成功，返回第4步修改实现<br>7、测试结果如期成功，分析代码是否需要重构<br>8、需要重构，返回第4步修改实现<br>9、不需要重构，编写下一个测试</p>
<h4 id="4、TDD-优点"><a href="#4、TDD-优点" class="headerlink" title="4、TDD 优点"></a>4、TDD 优点</h4><p>1、降低开发者负担<br>通过明确的流程，让我们一次只关注一个点，思维负担更小。</p>
<p>2、保护网<br>TDD 的好处是覆盖完全的单元测试，对产品代码提供了一个保护网，让我们可以轻松地迎接需求变化或改善代码的设计。<br>所以如果你的项目需求稳定，一次性做完，后续没有任何改动的话，能享受到 TDD 的好处就比较少了。</p>
<p>3、提前澄清需求<br>先写测试可以帮助我们去思考需求，并提前澄清需求细节，而不是代码写到一半才发现不明确的需求。</p>
<p>4、快速反馈<br>有很多人说 TDD 时，我的代码量增加了，所以开发效率降低了。但是，如果没有单元测试，你就要手工测试，你要花很多时间去准备数据，启动应用，跳转界面等，反馈是很慢的。准确说，快速反馈是单元测试的好处。</p>
<h4 id="5、TDD-的三条规则"><a href="#5、TDD-的三条规则" class="headerlink" title="5、TDD 的三条规则"></a>5、TDD 的三条规则</h4><p>1、除非是为了使一个失败的 unit test 通过，否则不允许编写任何产品代码</p>
<p>2、在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）</p>
<p>3、只允许编写刚好能够使一个失败的 unit test 通过的产品代码</p>
<p>如果违反了会怎么样呢？<br>1、违反第一条，先编写了产品代码，那这段代码是为了实现什么需求呢？怎么确保它真的实现了呢？<br>2、违反第二条，写了多个失败的测试，如果测试长时间不能通过，会增加开发者的压力，另外，测试可能会被重构，这时会增加测试的修改成本。<br>3、违反第三条，产品代码实现了超出当前测试的功能，那么这部分代码就没有测试的保护，不知道是否正确，需要手工测试。可能这是不存在的需求，那就凭空增加了代码的复杂性。如果是存在的需求，那后面的测试写出来就会直接通过，破坏了 TDD 的节奏感。</p>
<p>我认为它的本质是：<br>1、分离关注点，一次只戴一顶帽子<br>在我们编程的过程中，有几个关注点：需求，实现，设计。<br>TDD 给了我们明确的三个步骤，每个步骤关注一个方面。</p>
<ul>
<li>红：<br>写一个失败的测试，它是对一个小需求的描述，只需要关心输入输出，这个时候根本不用关心如何实现。</li>
<li>绿：<br>专注在用最快的方式实现当前这个小需求，不用关心其他需求，也不要管代码的质量多么惨不忍睹。</li>
<li>重构：<br>既不用思考需求，也没有实现的压力，只需要找出代码中的坏味道，并用一个手法消除它，让代码变成整洁的代码。</li>
</ul>
<p>2、注意力控制<br>人的注意力既可以主动控制，也会被被动吸引。注意力来回切换的话，就会消耗更多精力，思考也会不那么完整。<br>使用 TDD 开发，我们要主动去控制注意力，写测试的时候，发现一个类没有定义，IDE 提示编译错误，这时候你如果去创建这个类，你的注意力就不在需求上了，已经切换到了实现上，我们应该专注地写完这个测试，思考它是否表达了需求，确定无误后再开始去消除编译错误。</p>
<p>参考：<a href="https://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="noopener">https://www.jianshu.com/p/62f16cd4fef3</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/15/测试驱动开发TDD/" data-id="ckcukir7p001xh8vi63h6bbc9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go-goroutine、channel、反射" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-goroutine、channel、反射/" class="article-date">
  <time datetime="2020-06-11T07:58:15.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/go-goroutine、channel、反射/">go:goroutine、channel、反射</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、goroutine"><a href="#1、goroutine" class="headerlink" title="1、goroutine"></a>1、goroutine</h3><h4 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、Go协程和Go主线程</p>
<ul>
<li><strong>Go主线程</strong>（有的程序员直接成为线程/也可以理解成进程）：<strong>一个Go主线程上，可以起多个协程</strong>，即<strong>协程是轻量级的线程</strong>。</li>
</ul>
<p>2、Go协程的特点</p>
<ul>
<li>有独立的栈空间</li>
<li>共享程序堆空间</li>
<li>调度由用户控制</li>
<li>协程是轻量级的线程</li>
</ul>
<p>3、案例<br>1）在主线程（可以理解成进程），开启一个goroutine，该协程每隔一秒输出“hello world”<br>2）在主线程中也每隔一秒输出“hello world”，输出10次后，退出程序<br>3）要求主线程和goroutine同时执行<br>4）主线程和协程执行流程图</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>    </span><br><span class="line">    <span class="string">"strconv"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个函数，每隔1秒输出“hello world”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span> ;i++  &#123;   </span><br><span class="line">        fmt.Println(<span class="string">"test() hello world"</span>+strconv.Itoa(i))     </span><br><span class="line">        </span><br><span class="line">        time.Sleep(time.Second)  <span class="comment">//休眠一秒  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">go</span> test()<span class="comment">//开启一个协程    </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span> ;i++  &#123;    </span><br><span class="line">        fmt.Println(<span class="string">"main() hello world"</span>+strconv.Itoa(i))      </span><br><span class="line">        </span><br><span class="line">        time.Sleep(time.Second)     <span class="comment">//休眠一秒  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main() hello world1</span><br><span class="line">test() hello world1</span><br><span class="line">main() hello world2</span><br><span class="line">test() hello world2</span><br><span class="line">test() hello world3</span><br><span class="line">main() hello world3</span><br><span class="line">main() hello world4</span><br><span class="line">test() hello world4</span><br><span class="line">test() hello world5</span><br><span class="line">main() hello world5</span><br><span class="line">test() hello world6</span><br><span class="line">main() hello world6</span><br><span class="line">main() hello world7</span><br><span class="line">test() hello world7</span><br><span class="line">test() hello world8</span><br><span class="line">main() hello world8</span><br><span class="line">main() hello world9</span><br><span class="line">test() hello world9</span><br></pre></td></tr></table></figure></p>
<p>由输出看出，<strong>主线程main和协程test同时执行</strong></p>
<ul>
<li><p>主线程和协程执行流程图<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine1.jpg" alt="goroutine1"></p>
</li>
<li><p>程序开始执行，main主线程开始执行</p>
</li>
<li>go test()开启协程，<strong>主线程main和协程test同时执行</strong></li>
<li>程序退出以<strong>主线程</strong>为主：<pre><code>1） 如果主线程退出了，则协程即使还没有执行完毕也会退出
2）当然协程可以在主线程没有退出前，就执行完毕退出协程
</code></pre></li>
</ul>
<p>4、总结</p>
<ul>
<li><p>1）<strong>主线程</strong>是一个<strong>物理线程</strong>，<strong>直接作用在CPU上</strong>。是重量级的，非常耗费CPU资源。</p>
</li>
<li><p>2）<strong>协程从主线程开启的</strong>，是轻量级的线程，是<strong>逻辑态的</strong>。对资源消耗相对小</p>
</li>
<li><p>3）Go的协程机制是重要特点，可以轻松的开启上万个协程。（其他编程语言的开发机制一般是基于线程的，开启过多的线程，资源消耗大）</p>
</li>
</ul>
<h4 id="2、goroutine的调度模型"><a href="#2、goroutine的调度模型" class="headerlink" title="2、goroutine的调度模型"></a>2、goroutine的调度模型</h4><p>1、MPG模式基本介绍</p>
<ul>
<li>M：操作系统的主线程（是物理线程，真正干活的人）</li>
<li>P：协程执行需要的上下文环境（运行时需要的资源和运行时的状态）</li>
<li>G：协程（逻辑态的）</li>
</ul>
<p>2、MPG模式运行的状态</p>
<p>1）MPG模式运行的状态1<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine2.jpg" alt="goroutine2"></p>
<p>2）MPG模式运行的状态2<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine3.jpg" alt="goroutine3"></p>
<h4 id="3、设置运行CPU数目"><a href="#3、设置运行CPU数目" class="headerlink" title="3、设置运行CPU数目"></a>3、设置运行CPU数目</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="comment">//runtime.NumCPU()   查询系统的CPU数目</span></span><br><span class="line">    cpuNum := runtime.NumCPU()   </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"cpuNum="</span>,cpuNum)     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置使用多个CPU     </span></span><br><span class="line">    runtime.GOMAXPROCS(cpuNum<span class="number">-1</span>)     </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"ok"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、管道channel"><a href="#2、管道channel" class="headerlink" title="2、管道channel"></a>2、管道channel</h3><p>案例：计算1-20的各个数的阶乘，并且把各个数放入map中并打印，使用goroutine完成</p>
<p>思路：</p>
<ul>
<li>1、编写一个函数，计算各个数的阶乘并放入map中</li>
<li>2、启动多个协程，统计的结果放入map中</li>
<li>3、map应该做全局的</li>
</ul>
<p>解法一：使用全局变量加锁同步<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (     </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"sync"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(  </span><br><span class="line">    myMap =<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//全局资源不加锁，会发生资源竞争，同时写会报错   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以声明一个全局互斥锁解决    </span></span><br><span class="line">    <span class="comment">//sync是一个包，synchornized 同步    </span></span><br><span class="line">    <span class="comment">//Mutex 互斥      </span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//test函数计算n的阶乘，将结果放入myMap中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="keyword">int</span>)</span></span>&#123;    </span><br><span class="line">    res:=<span class="number">1</span>    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++&#123;      </span><br><span class="line">    res*=i  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入map前加锁    </span></span><br><span class="line">    lock.Lock()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//把结果放入myMap     </span></span><br><span class="line">    myMap[n]=res    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//写完map后解锁    </span></span><br><span class="line">    lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//这里开启20个协程，</span></span><br><span class="line">    <span class="comment">//20个协程同时向map写数据，会发生 并发map写 错误    </span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++&#123;         </span><br><span class="line">        <span class="keyword">go</span> test(i)    </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//休眠5秒钟（人为估算），让主线程等待所有的协程执行完   </span></span><br><span class="line">    time.Sleep(<span class="number">5</span>*time.Second)   </span><br><span class="line">    <span class="comment">//如果不休眠，可能main主线程已经结束退出，但是test协程还没写入map     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//互斥性资源读写都要加锁     </span></span><br><span class="line">    lock.Lock()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出结果，对map进行读操作     </span></span><br><span class="line">    <span class="keyword">for</span> i,v :=<span class="keyword">range</span> myMap&#123;           </span><br><span class="line">        fmt.Printf(<span class="string">"map[%d]=%d\n"</span>,i,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    lock.Unlock()&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="number">17</span>]=<span class="number">355687428096000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">16</span>]=<span class="number">20922789888000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">20</span>]=<span class="number">2432902008176640000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">9</span>]=<span class="number">362880</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">10</span>]=<span class="number">3628800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">12</span>]=<span class="number">479001600</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">3</span>]=<span class="number">6</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">19</span>]=<span class="number">121645100408832000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">11</span>]=<span class="number">39916800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">15</span>]=<span class="number">1307674368000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">18</span>]=<span class="number">6402373705728000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">8</span>]=<span class="number">40320</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">5</span>]=<span class="number">120</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">7</span>]=<span class="number">5040</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">14</span>]=<span class="number">87178291200</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">13</span>]=<span class="number">6227020800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">4</span>]=<span class="number">24</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">6</span>]=<span class="number">720</span></span><br></pre></td></tr></table></figure></p>
<p>因为map的key是无序的，所以未按递增顺序执行，而且并发执行的顺序也可能不是递增得到结果的</p>
<p>上面的解法中</p>
<ul>
<li>主线程等待所有goroutine全部完成时间很难确定，这里设置为5秒，是为估算</li>
<li>如果主线程休眠时间长了，会加长等待时间；如果等待时间短了，可能还有goroutine处于工作状态（没有执行完），这时也会随主线程的退出二销毁</li>
<li>通过全局变量加锁同步来实现协程间通讯，并不利于多个协程对全局变量的读写操作</li>
</ul>
<p>综上，我们引出一种新的通讯机制channel</p>
<p>解法二：使用channel</p>
<h4 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、channel本质上就是一个数据结构-队列</p>
<p>2、数据先进先出</p>
<p>3、<strong>线程安全</strong>，多个goroutine访问时，自己不需要再加锁，即：<strong>channel本身就是线程安全的</strong></p>
<p>4、<strong>channel是有类型的</strong>，一个string的channel只能存放string类型数据<br><img src="/2020/06/11/go-goroutine、channel、反射/channel1.jpg" alt="channel1"></p>
<h4 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h4><h5 id="1、定义-声明"><a href="#1、定义-声明" class="headerlink" title="1、定义/声明"></a>1、定义/声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 数据类型</span><br><span class="line"></span><br><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//intChan类型为int，只能存放int型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//mapChan类型为map[int]string，只能存放map[int]string型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> perChan <span class="keyword">chan</span> Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> perChan2 <span class="keyword">chan</span> *Person</span><br></pre></td></tr></table></figure>
<p>2、注意</p>
<ul>
<li>channel是<strong>引用类型</strong></li>
<li><strong>channel必须初始化后才能写入数据，即make后才能使用</strong></li>
<li>channel是由类型的，如intChan类型为int，只能存放int型数据</li>
</ul>
<h5 id="3、管道的初始化、从管道读写数据以及注意事项"><a href="#3、管道的初始化、从管道读写数据以及注意事项" class="headerlink" title="3、管道的初始化、从管道读写数据以及注意事项"></a>3、管道的初始化、从管道读写数据以及注意事项</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">//1、创建一个可以存放3个int的管道   </span></span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span>    </span><br><span class="line">    intChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)  <span class="comment">//channel make后才能使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、intChan是什么     </span></span><br><span class="line">    fmt.Printf(<span class="string">"intChan的值=%v intChan本身的地址=%v\n"</span>,intChan,&amp;intChan)   </span><br><span class="line">    <span class="comment">//输出：intChan的值=0xc000092080 </span></span><br><span class="line">    <span class="comment">//intChan本身的地址=0xc00008c018      </span></span><br><span class="line">    <span class="comment">//可以看出intChan的值为一个地址，所以channel是引用类型。    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、向管道写入数据     </span></span><br><span class="line">    intChan&lt;<span class="number">-10</span><span class="comment">//直接写入常量   </span></span><br><span class="line">    num:=<span class="number">211</span>     </span><br><span class="line">    intChan&lt;-num<span class="comment">//写入变量    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、看看管道的长度和容量    </span></span><br><span class="line">    <span class="comment">//容量是make时传入的，这里传入的是3，容量不能自动增长，和slice、map不一样    </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))     </span><br><span class="line">    <span class="comment">//channel len=2 cap=3    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、注意：给管道写入数据时不能超过容量     </span></span><br><span class="line">    intChan&lt;<span class="number">-50</span>      <span class="comment">//intChan&lt;-98     </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))   </span><br><span class="line">    <span class="comment">//fatal error: all goroutines are asleep - deadlock!   </span></span><br><span class="line">    <span class="comment">//报告死锁deadlock错误     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、从管道中读取数据     </span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">int</span>     </span><br><span class="line">    num2 = &lt;-intChan  </span><br><span class="line">    fmt.Println(<span class="string">"num2="</span>,num2)<span class="comment">//num2= 10，从队列头开始取     </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))    </span><br><span class="line">    <span class="comment">//channel len=2 cap=3     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、在没有使用协程的情况下，如果管道中的数据已经全部取出，再取数据就会报告死锁deadlock错误     </span></span><br><span class="line">    num3 := &lt;-intChan    </span><br><span class="line">    num4 := &lt;-intChan     </span><br><span class="line">    num5 := &lt;-intChan   </span><br><span class="line">    fmt.Println(<span class="string">"num3="</span>,num3,<span class="string">"num4="</span>,num4,<span class="string">"num5="</span>,num5)   </span><br><span class="line">    <span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<ul>
<li>channel中只能存放指定的数据类型</li>
<li>channel的数据放满后，就不能再放入了，否则报告死锁deadlock错误</li>
<li>当 channel的数据放满后，如果从channel中取出数据，可以再次放入数据</li>
<li>在没有使用协程的情况下，如果channel中的数据取完了，再次取数据，会报告死锁deadlock错误</li>
</ul>
<p>一个例子，当管道是空接口interface{}类型时，可以存放任意数据类型的值，取出管道中的值对象的的字段值时，需要类型断言<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123; </span><br><span class="line">    Name <span class="keyword">string</span>     </span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    allChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">3</span>)<span class="comment">//定义一个空接口类型，容量为3的管道allChan      </span></span><br><span class="line"></span><br><span class="line">    allChan&lt;<span class="number">-10</span><span class="comment">//往管道写入int类型的值     </span></span><br><span class="line">    allChan&lt;-<span class="string">"tom"</span><span class="comment">//往管道写入string类型的值    </span></span><br><span class="line"></span><br><span class="line">    cat:=Cat&#123;<span class="string">"小花猫"</span>,<span class="number">4</span>&#125;<span class="comment">//实例化一个Cat    </span></span><br><span class="line">    allChan&lt;-cat<span class="comment">////往管道写入Cat类型的值    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//想要取出管道中的第三个值，需要丢弃第一个和第二个    </span></span><br><span class="line">    &lt;-allChan    </span><br><span class="line">    &lt;-allChan    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//取到第三个   </span></span><br><span class="line">    newCat:=&lt;-allChan   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//newCat从编译层面看是空接口类型,接口类型本身没有字段    </span></span><br><span class="line">    <span class="comment">//但在运行时可动态指向结构体Cat，</span></span><br><span class="line">    <span class="comment">//下面写法语法上没错，运行时可动态指向Cat     </span></span><br><span class="line">    fmt.Printf(<span class="string">"newCat的类型=%T newCat的值=%v\n"</span>,newCat,newCat)   </span><br><span class="line">    <span class="comment">//输出：newCat的类型=main.Cat newCat的值=&#123;小花猫 4&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//newCat从编译层面看是空接口类型，接口类型本身没有字段，</span></span><br><span class="line">    <span class="comment">//直接写编译不通过，需要类型断言      </span></span><br><span class="line">    aNewCat:=newCat.(Cat)     </span><br><span class="line">    fmt.Printf(<span class="string">"newCat.Name=%v"</span>,aNewCat.Name)</span><br><span class="line">    <span class="comment">//输出：newCat.Name=小花猫</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4、管道的遍历和关闭"><a href="#4、管道的遍历和关闭" class="headerlink" title="4、管道的遍历和关闭"></a>4、管道的遍历和关闭</h5><p> 1、管道的关闭</p>
<p>使用内置函数<strong>close()可以关闭管道</strong>，当管道关闭后，就不能再向管道写数据了，但是仍然可以从管道中读取数据<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)  </span><br><span class="line">    intChan&lt;<span class="number">-100</span>   </span><br><span class="line">    intChan&lt;<span class="number">-200</span>    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、关闭管道    </span></span><br><span class="line">    <span class="built_in">close</span>(intChan)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、关闭管道后，不能再写入数据   </span></span><br><span class="line">    <span class="comment">//intChan&lt;-300    </span></span><br><span class="line">    <span class="comment">//panic: send on closed channel     </span></span><br><span class="line">    <span class="comment">//向一个关闭的通道中发送数据，panic终止程序    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、关闭管道后，可以再读取数据   </span></span><br><span class="line">    n1:=&lt;-intChan    </span><br><span class="line">    fmt.Println(<span class="string">"n1="</span>,n1)<span class="comment">//n1= 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、管道的遍历<br>channel支持for-range的方式进行遍历，有两个细节注意：</p>
<ul>
<li>在遍历时，如果channel没有关闭，则会出现死锁deadlock错误</li>
<li>在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历</li>
</ul>
<p>在遍历时不能使用普通for循环遍历，因为管道的长度（len(intChan)）是随数据出管道-1动态变化的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环往管道中写入100个数据      </span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">100</span> ;i++  &#123;       </span><br><span class="line">        intChan&lt;-i*<span class="number">2</span>   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历，一定要先关闭管道,如果不关闭管道，会出现死锁deadlock错误     </span></span><br><span class="line">    <span class="built_in">close</span>(intChan)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//管道没有下标，for-range只返回一个值    </span></span><br><span class="line">    <span class="keyword">for</span> v:= <span class="keyword">range</span> intChan&#123;         </span><br><span class="line">        fmt.Println(<span class="string">"v="</span>,v)     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、goroutine和管道channel结合使用"><a href="#3、goroutine和管道channel结合使用" class="headerlink" title="3、goroutine和管道channel结合使用"></a>3、goroutine和管道channel结合使用</h3><h4 id="1、案例："><a href="#1、案例：" class="headerlink" title="1、案例："></a>1、案例：</h4><p>案例：<br>goroutine和管道channel协同工作<br>1）开启一个wiiteData协程，向管道写入50个整数<br>2）开启一个readData协程，从管道中读取wiiteData写入的数据<br>3）注意：wiiteData和readData操作的是同一个管道<br>4）主线程需要等待wiiteData和readData协程完成工作后才能退出<br>思路图解：<br><img src="/2020/06/11/go-goroutine、channel、反射/goandchan1.jpg" alt="goandchan1"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++  &#123;   </span><br><span class="line">        intChan&lt;-i         </span><br><span class="line">        fmt.Println(<span class="string">"writeData "</span>,i)    </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(intChan)<span class="comment">//关闭intChan，后面intChan仍然可读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//readData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>,exitChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">for</span>&#123;         </span><br><span class="line">        v,ok:=&lt;-intChan      </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;       </span><br><span class="line">          <span class="keyword">break</span>     </span><br><span class="line">         &#125;         </span><br><span class="line">        fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//readData读取数据完后，    </span></span><br><span class="line">    <span class="comment">//往exitChan写入数据true，告知主线程readData执行完毕    </span></span><br><span class="line">    exitChan&lt;-<span class="literal">true</span>   </span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//创建两个管道  </span></span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">50</span>)  </span><br><span class="line">    exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)  <span class="comment">//该管道用于等到intChan管道的读取协程工作完毕后，往exitChan写入数据，标识主线程可退出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> writeData(intChan) <span class="comment">//向管道写入50个整数</span></span><br><span class="line">    <span class="keyword">go</span> readData(intChan,exitChan)   <span class="comment">//从管道中读取wiiteData写入的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>&#123;      </span><br><span class="line">        _,ok:=&lt;-exitChan    </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;            </span><br><span class="line">             <span class="keyword">break</span>       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、管道阻塞机制"><a href="#2、管道阻塞机制" class="headerlink" title="2、管道阻塞机制"></a>2、管道阻塞机制</h4><p>如果<strong>只向管道里写数据，而没有读取</strong>，就会出现<strong>阻塞而死锁</strong>deadlock。<br>注意：如果<strong>有向管道读取数据，但读取比写数据慢得多</strong>，也不会发生死锁，只要编译器检测到数据在管道中是流动的，即有读取也有写入，那么就不会发生死锁</p>
<p>下面例子中，intChan容量改为10<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++  &#123;   </span><br><span class="line">        intChan&lt;-i     <span class="comment">//数据一下就放入，但下面readData读取慢慢读</span></span><br><span class="line">    </span><br><span class="line">        fmt.Println(<span class="string">"writeData "</span>,i)    </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(intChan)<span class="comment">//关闭intChan，后面intChan仍然可读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//readData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>,exitChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">for</span>&#123;         </span><br><span class="line">        v,ok:=&lt;-intChan      </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;       </span><br><span class="line">          <span class="keyword">break</span>     </span><br><span class="line">         &#125;         </span><br><span class="line">       time.Sleep(time.Second)<span class="comment">//慢慢读，每隔一秒读一次</span></span><br><span class="line">       </span><br><span class="line">      fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//readData读取数据完后，    </span></span><br><span class="line">    <span class="comment">//往exitChan写入数据true，告知主线程readData执行完毕    </span></span><br><span class="line">    exitChan&lt;-<span class="literal">true</span>   </span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//创建两个管道  </span></span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)<span class="comment">//容量10</span></span><br><span class="line">    exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)  <span class="comment">//该管道用于等到intChan管道的读取协程工作完毕后，往exitChan写入数据，标识主线程可退出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> writeData(intChan) <span class="comment">//向管道写入50个整数</span></span><br><span class="line">    <span class="keyword">go</span> readData(intChan,exitChan)   <span class="comment">//从管道中读取wiiteData写入的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>&#123;      </span><br><span class="line">        _,ok:=&lt;-exitChan    </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;            </span><br><span class="line">             <span class="keyword">break</span>       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">writeData  <span class="number">1</span></span><br><span class="line">writeData  <span class="number">2</span></span><br><span class="line">writeData  <span class="number">3</span></span><br><span class="line">writeData  <span class="number">4</span></span><br><span class="line">writeData  <span class="number">5</span></span><br><span class="line">writeData  <span class="number">6</span></span><br><span class="line">writeData  <span class="number">7</span></span><br><span class="line">writeData  <span class="number">8</span></span><br><span class="line">writeData  <span class="number">9</span></span><br><span class="line">writeData  <span class="number">10</span></span><br><span class="line">writeData  <span class="number">11</span></span><br><span class="line">readData 读到数据=<span class="number">1</span></span><br><span class="line">writeData  <span class="number">12</span></span><br><span class="line">readData 读到数据=<span class="number">2</span></span><br><span class="line">writeData  <span class="number">13</span></span><br><span class="line">readData 读到数据=<span class="number">3</span></span><br><span class="line">writeData  <span class="number">14</span></span><br><span class="line">readData 读到数据=<span class="number">4</span></span><br><span class="line">writeData  <span class="number">15</span></span><br><span class="line">readData 读到数据=<span class="number">5</span></span><br><span class="line">writeData  <span class="number">16</span></span><br><span class="line">readData 读到数据=<span class="number">6</span></span><br><span class="line">writeData  <span class="number">17</span></span><br><span class="line">readData 读到数据=<span class="number">7</span></span><br><span class="line">writeData  <span class="number">18</span></span><br><span class="line">readData 读到数据=<span class="number">8</span></span><br><span class="line">writeData  <span class="number">19</span></span><br><span class="line">readData 读到数据=<span class="number">9</span></span><br><span class="line">writeData  <span class="number">20</span></span><br><span class="line">readData 读到数据=<span class="number">10</span></span><br><span class="line">writeData  <span class="number">21</span></span><br><span class="line">readData 读到数据=<span class="number">11</span></span><br><span class="line">writeData  <span class="number">22</span></span><br><span class="line">readData 读到数据=<span class="number">12</span></span><br><span class="line">writeData  <span class="number">23</span></span><br><span class="line">readData 读到数据=<span class="number">13</span></span><br><span class="line">writeData  <span class="number">24</span></span><br><span class="line">readData 读到数据=<span class="number">14</span></span><br><span class="line">writeData  <span class="number">25</span></span><br><span class="line">readData 读到数据=<span class="number">15</span></span><br><span class="line">writeData  <span class="number">26</span></span><br><span class="line">readData 读到数据=<span class="number">16</span></span><br><span class="line">writeData  <span class="number">27</span></span><br><span class="line">readData 读到数据=<span class="number">17</span></span><br><span class="line">writeData  <span class="number">28</span></span><br><span class="line">readData 读到数据=<span class="number">18</span></span><br><span class="line">writeData  <span class="number">29</span></span><br><span class="line">readData 读到数据=<span class="number">19</span></span><br><span class="line">writeData  <span class="number">30</span></span><br><span class="line">readData 读到数据=<span class="number">20</span></span><br><span class="line">writeData  <span class="number">31</span></span><br><span class="line">readData 读到数据=<span class="number">21</span></span><br><span class="line">writeData  <span class="number">32</span></span><br><span class="line">readData 读到数据=<span class="number">22</span></span><br><span class="line">writeData  <span class="number">33</span></span><br><span class="line">readData 读到数据=<span class="number">23</span></span><br><span class="line">writeData  <span class="number">34</span></span><br><span class="line">readData 读到数据=<span class="number">24</span></span><br><span class="line">writeData  <span class="number">35</span></span><br><span class="line">readData 读到数据=<span class="number">25</span></span><br><span class="line">writeData  <span class="number">36</span></span><br><span class="line">readData 读到数据=<span class="number">26</span></span><br><span class="line">writeData  <span class="number">37</span></span><br><span class="line">readData 读到数据=<span class="number">27</span></span><br><span class="line">writeData  <span class="number">38</span></span><br><span class="line">readData 读到数据=<span class="number">28</span></span><br><span class="line">writeData  <span class="number">39</span></span><br><span class="line">readData 读到数据=<span class="number">29</span></span><br><span class="line">writeData  <span class="number">40</span></span><br><span class="line">readData 读到数据=<span class="number">30</span></span><br><span class="line">writeData  <span class="number">41</span></span><br><span class="line">readData 读到数据=<span class="number">31</span></span><br><span class="line">writeData  <span class="number">42</span></span><br><span class="line">readData 读到数据=<span class="number">32</span></span><br><span class="line">writeData  <span class="number">43</span></span><br><span class="line">readData 读到数据=<span class="number">33</span></span><br><span class="line">writeData  <span class="number">44</span></span><br><span class="line">readData 读到数据=<span class="number">34</span></span><br><span class="line">writeData  <span class="number">45</span></span><br><span class="line">readData 读到数据=<span class="number">35</span></span><br><span class="line">writeData  <span class="number">46</span></span><br><span class="line">readData 读到数据=<span class="number">36</span></span><br><span class="line">writeData  <span class="number">47</span></span><br><span class="line">readData 读到数据=<span class="number">37</span></span><br><span class="line">writeData  <span class="number">48</span></span><br><span class="line">readData 读到数据=<span class="number">38</span></span><br><span class="line">writeData  <span class="number">49</span></span><br><span class="line">readData 读到数据=<span class="number">39</span></span><br><span class="line">writeData  <span class="number">50</span></span><br><span class="line">readData 读到数据=<span class="number">40</span></span><br><span class="line">readData 读到数据=<span class="number">41</span></span><br><span class="line">readData 读到数据=<span class="number">42</span></span><br><span class="line">readData 读到数据=<span class="number">43</span></span><br><span class="line">readData 读到数据=<span class="number">44</span></span><br><span class="line">readData 读到数据=<span class="number">45</span></span><br><span class="line">readData 读到数据=<span class="number">46</span></span><br><span class="line">readData 读到数据=<span class="number">47</span></span><br><span class="line">readData 读到数据=<span class="number">48</span></span><br><span class="line">readData 读到数据=<span class="number">49</span></span><br><span class="line">readData 读到数据=<span class="number">50</span></span><br></pre></td></tr></table></figure></p>
<p>因为管道容量为10，所以写到11的时候，需要等待数据被读出才能写入，所以写数据12-50与读取是交错的，读取数据每隔一秒读取一次。最后数据全部写完，只需要读取数据。</p>
<h4 id="3、细节"><a href="#3、细节" class="headerlink" title="3、细节"></a>3、细节</h4><p>1、在默认情况下，管道是双向的，即可读可写<br>2、管道可以声明为只读或只写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管道声明为只写</span></span><br><span class="line"><span class="keyword">var</span> chan1 <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">chan1 &lt;- <span class="number">1</span> <span class="comment">//ok</span></span><br><span class="line">num1 := &lt;-chan1 <span class="comment">//error，无效的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管道声明为只读</span></span><br><span class="line"><span class="keyword">var</span> chan2 &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">num2 := &lt;-chan2 <span class="comment">//ok</span></span><br><span class="line">chan2 &lt;- <span class="number">2</span> <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>管道声明为只读或只写的应用场景：</p>
<ul>
<li>先声明一个双向管道intChan</li>
<li>声明两个函数，一个往intChan只写数据的send函数，一个往intChan只读数据的recv函数，防止误操作</li>
<li>可以将双向管道intChan作为实参，传给只写数据的send函数，send函数形参为<strong>ch chan&lt;- int</strong></li>
<li>可以将双向管道intChan作为实参，传给只读数据的recv函数，re函数形参为<strong>ch &lt;-chan int</strong></li>
<li>上面所述中，将双向管道作为实参传给单向管道（只读或只写）并不会报错。</li>
<li>管道的双向和单向只是管道的性质，但是管道的类型都是chan int，所以不会报错</li>
</ul>
<p>3、使用<strong>select</strong>可以解决<strong>从管道取数据的阻塞问题</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">//使用select可以解决从管道取数据的阻塞问题     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、定义一个管道 10个数据 int     </span></span><br><span class="line">    intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++  &#123;     </span><br><span class="line">         intChan&lt;-i     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、定义一个管道 5个数据，string     </span></span><br><span class="line">    stringChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">5</span>)    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span> ;i++  &#123;   </span><br><span class="line">         stringChan&lt;-<span class="string">"hello"</span>+fmt.Sprintf(<span class="string">"%d"</span>,i)  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统方法在遍历管道时，如果不关闭会阻塞并死锁deadlock   </span></span><br><span class="line">    <span class="comment">//但在实际开发中，我们往往不确定关闭管道的时机    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由此我们使用select解决      </span></span><br><span class="line">    <span class="keyword">for</span>&#123;          </span><br><span class="line">        <span class="keyword">select</span> &#123;          </span><br><span class="line">        <span class="comment">//重点：这里如果intChan一直没有关闭，不会一直阻塞而死锁，                </span></span><br><span class="line">        <span class="comment">//会自动到下一个case匹配         </span></span><br><span class="line">            <span class="keyword">case</span> v:=&lt;-intChan:              </span><br><span class="line">            fmt.Printf(<span class="string">"从intChan读取了数据%d\n"</span>,v)         </span><br><span class="line">            <span class="keyword">case</span> v:=&lt;-stringChan:                   </span><br><span class="line">            fmt.Printf(<span class="string">"从stringChan读取了数据%s\n"</span>,v)              </span><br><span class="line">            <span class="keyword">default</span>:                     </span><br><span class="line">            fmt.Printf(<span class="string">"都取不到了，加入处理逻辑\n"</span>)                    </span><br><span class="line">            <span class="keyword">return</span>        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">从stringChan读取了数据hello0</span><br><span class="line">从intChan读取了数据<span class="number">0</span></span><br><span class="line">从stringChan读取了数据hello1</span><br><span class="line">从stringChan读取了数据hello2</span><br><span class="line">从stringChan读取了数据hello3</span><br><span class="line">从intChan读取了数据<span class="number">1</span></span><br><span class="line">从intChan读取了数据<span class="number">2</span></span><br><span class="line">从stringChan读取了数据hello4</span><br><span class="line">从intChan读取了数据<span class="number">3</span></span><br><span class="line">从intChan读取了数据<span class="number">4</span></span><br><span class="line">从intChan读取了数据<span class="number">5</span></span><br><span class="line">从intChan读取了数据<span class="number">6</span></span><br><span class="line">从intChan读取了数据<span class="number">7</span></span><br><span class="line">从intChan读取了数据<span class="number">8</span></span><br><span class="line">从intChan读取了数据<span class="number">9</span></span><br><span class="line">都取不到了，加入处理逻辑</span><br></pre></td></tr></table></figure></p>
<p>4、<strong>goroutine中使用recover，解决协程中出现panic</strong>，导致程序崩溃问题</p>
<ul>
<li><p>如果我们起了一个协程，但是这个协程出现了panic，如果我们没有捕获这个panic，就会造成成哥程序的崩溃，</p>
</li>
<li><p>这时可以在该协程中使用recover来捕获panic进行处理。这样即使这个协程发生问题，主线程仍然不受影响，继续执行。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数sayHello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;           </span><br><span class="line">        time.Sleep(time.Second)    </span><br><span class="line">        fmt.Println(<span class="string">"hello world"</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="comment">//这里使用defer+recover解决panic终止程序    </span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;           </span><br><span class="line">    <span class="comment">//捕获test抛出的panic         </span></span><br><span class="line">        <span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span> &#123;            </span><br><span class="line">              fmt.Println(<span class="string">"test() 发生错误"</span>)   </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个map  </span></span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>     </span><br><span class="line">    myMap[<span class="number">0</span>]=<span class="string">"golang"</span><span class="comment">//空map直接赋值，报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="keyword">go</span> sayHello()    </span><br><span class="line">    <span class="keyword">go</span> test()   <span class="comment">//这个协程会panic 使用defer+recover解决</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;       </span><br><span class="line">        time.Sleep(time.Second)       </span><br><span class="line">        fmt.Println(<span class="string">"main() ok="</span>,i)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">test() 发生错误</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">0</span></span><br><span class="line">main() ok= <span class="number">1</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">2</span></span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">3</span></span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">4</span></span><br><span class="line">main() ok= <span class="number">5</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">6</span></span><br><span class="line">main() ok= <span class="number">7</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">8</span></span><br><span class="line">main() ok= <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>由输出看出，test协程出错，但是主线程和sayHello协程继续执行</p>
<h3 id="4、反射"><a href="#4、反射" class="headerlink" title="4、反射"></a>4、反射</h3><h4 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、反射的作用：</p>
<ul>
<li><p>1）、反射可以在运行时动态获取变量的各种信息，如变量的类型（type）、类别（kind）</p>
</li>
<li><p>2）、如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段、方法）</p>
</li>
<li><p>3）、通过反射，可以修改变量的值，可以调用关联的方法</p>
</li>
<li><p>4）、使用反射，需要import（“reflect”）</p>
</li>
</ul>
<p>reflect实现了运行时反射，允许程序操作任意类型的对象，典型用法是用静态类型interface{}保存一个值，通过<strong>调用TypeOf获取类型信息</strong>，该函数返回一个Type类型值，<strong>调用ValueOf函数返回一个value类型值</strong>，该值代表运行时数据，Zero接受一个Type类型参数并返回该类型零值的value类型值。</p>
<ul>
<li>5）、反射示意图</li>
</ul>
<p><img src="/2020/06/11/go-goroutine、channel、反射/reflect1.png" alt="reflect1"></p>
<p><strong>reflect.Type是一个接口</strong>，定义了非常多方法，通过这些方法可以反向操作变量，获取变量的各种信息</p>
<p><strong>reflect.Value是一个结构体</strong>，包含了非常多方法，可通过Type()方法将Value转换为Type、返回变量的字段和方法等等</p>
<ul>
<li>6）、变量、interface{}和reflect.Value是可以相互转换的<br><img src="/2020/06/11/go-goroutine、channel、反射/reflect2.png" alt="reflect2"></li>
</ul>
<h4 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h4><p>1、对基本数据类型、interface{}、reflect.Value进行反射的基本操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (     </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//通过反射获取传入变量的type、kind、值     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、先获取到reflect.Type     </span></span><br><span class="line">    rTyp := reflect.TypeOf(b)     </span><br><span class="line">    fmt.Println(<span class="string">"rTyp="</span>,rTyp)     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取到reflect.Value     </span></span><br><span class="line">    rVal := reflect.ValueOf(b)<span class="comment">//rVal=100      </span></span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)     </span><br><span class="line">    <span class="comment">//n:=rVal+2 </span></span><br><span class="line">    <span class="comment">//error，rVal的类型不是int，是reflect.Value，不能做运算    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、如果要做运算，如下      </span></span><br><span class="line">    n:=rVal.Int()+<span class="number">2</span>     </span><br><span class="line">    fmt.Println(<span class="string">"n="</span>,n)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、将rval转成interface&#123;&#125;      </span></span><br><span class="line">    iv:=rVal.Interface()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、将interface&#123;&#125;通过断言转成int(对应的类型)    </span></span><br><span class="line">    num2:=iv.(<span class="keyword">int</span>)     </span><br><span class="line">    fmt.Printf(<span class="string">"num2=%v num2的type=%T\n"</span>,num2,num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//1、定义一个int     </span></span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span>     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、反射</span></span><br><span class="line">    reflectTest01(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rTyp= <span class="keyword">int</span></span><br><span class="line">rVal=<span class="number">100</span> rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">n= <span class="number">102</span></span><br><span class="line">num2=<span class="number">100</span> num2的<span class="keyword">type</span>=<span class="keyword">int</span></span><br></pre></td></tr></table></figure></p>
<p>2、对结构体、interface{}、reflect.Value进行反射的基本操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Name <span class="keyword">string</span>     </span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对结构体反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest02</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//通过反射获取传入变量的type、kind、值     </span></span><br><span class="line">    <span class="comment">//1、先获取到reflect.Type   </span></span><br><span class="line">    rTyp := reflect.TypeOf(b)    </span><br><span class="line">    fmt.Println(<span class="string">"rTyp="</span>,rTyp)   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取到reflect.Value     </span></span><br><span class="line">    rVal := reflect.ValueOf(b)   </span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、获取变量对应的kind，两种方式等价</span></span><br><span class="line">    <span class="comment">//(1)通过获取到的reflect.Type来获取 =》rTyp.Kind()</span></span><br><span class="line">    kind1:=rTyp.Kind()</span><br><span class="line">    <span class="comment">//(2)通过获取到的reflect.Value来获取 =》rVal.Kind()</span></span><br><span class="line">   kind2:=rVal.Kind()</span><br><span class="line">   fmt.Printf(<span class="string">"kind1=%v kind2=%v\n"</span>,kind1,kind2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、将rval转成interface&#123;&#125;     </span></span><br><span class="line">    iv:=rVal.Interface()     </span><br><span class="line">    fmt.Printf(<span class="string">"iv=%v iv的type=%T\n"</span>,iv,iv)  </span><br><span class="line">    <span class="comment">//输出：iv=&#123;tom 20&#125; iv的type=main.Student   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、iv的type=main.Student，但是通过iv取字段会报错     </span></span><br><span class="line">    <span class="comment">//iv.Name     </span></span><br><span class="line">    <span class="comment">//error 因为编译器在编译阶段无法知道iv的类型是main.Student，只有运行时才知道     </span></span><br><span class="line">    <span class="comment">//所以这里直接编译报错    </span></span><br><span class="line">    <span class="comment">//反射是在程序运行时工作的    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、将interface&#123;&#125;通过断言转成int(对应的类型)    </span></span><br><span class="line">    stu:=iv.(Student)    </span><br><span class="line">    <span class="keyword">if</span> ok &#123;     </span><br><span class="line">        fmt.Printf(<span class="string">"stu=%v stu的type=%T\n"</span>,stu,stu)    </span><br><span class="line">        fmt.Printf(<span class="string">"stu.Name=%v stu.Age=%v\n"</span>,stu.Name,stu.Age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//1、定义一个student实例   </span></span><br><span class="line">    stu:=Student&#123;<span class="string">"tom"</span>,<span class="number">20</span>&#125;     </span><br><span class="line">    <span class="comment">//2、反射   </span></span><br><span class="line">    reflectTest02(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rTyp= main.Student</span><br><span class="line">rVal=&#123;tom <span class="number">20</span>&#125; rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">kind1=<span class="keyword">struct</span> kind2=<span class="keyword">struct</span></span><br><span class="line">iv=&#123;tom <span class="number">20</span>&#125; iv的<span class="keyword">type</span>=main.Student</span><br><span class="line">stu=&#123;tom <span class="number">20</span>&#125; stu的<span class="keyword">type</span>=main.Student</span><br><span class="line">stu.Name=tom stu.Age=<span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h4><p>1、reflect.Value.Kind()，获取变量的类别，返回一个常量。type是一个大范畴，kind在type上细分（如type只返回int，kind返回具体的int32，int64的常量定义的值等）<br>在上面的例子中有：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、获取变量对应的kind，两种方式等价</span></span><br><span class="line">    <span class="comment">//(1)通过获取到的reflect.Type来获取 =》rTyp.Kind()</span></span><br><span class="line">    kind1:=rTyp.Kind()</span><br><span class="line">    <span class="comment">//(2)通过获取到的reflect.Value来获取 =》rVal.Kind()</span></span><br><span class="line">   kind2:=rVal.Kind()</span><br><span class="line">   fmt.Printf(<span class="string">"kind1=%v kind2=%v\n"</span>,kind1,kind2)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kind1=<span class="keyword">struct</span> kind2=<span class="keyword">struct</span></span><br></pre></td></tr></table></figure></p>
<p>2、Type和Kind的区别：Type是类型，Kind是类别，<strong>Type和Kind可能相同也可能不同</strong></p>
<ul>
<li>var num int = 10 num的Type是int，Kind也是int</li>
<li>var stu Student   stu的Type是<strong>包名.Student</strong>，Kind是struct</li>
</ul>
<p>3、变量、interface{}和reflect.Value是可以相互转换的</p>
<p>4、使用反射的方式来获取变量的值（并返回对应的类型），要求数据类型匹配，如x是int，那么就应该用reflect.ValueOf(x).Int()，不能使用其他，否则panic</p>
<p>5、通过反射修改变量的值，注意当使用SetXXX方法来修改变量的值，需要通过变量对应的指针来修改，这时需要使用reflect.Value.Elem()方法</p>
<ul>
<li><p>func (v Value) SetXXX(x XXX)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">SetXXX</span><span class="params">(x XXX)</span></span> </span><br><span class="line"><span class="comment">//SetXXX方法是和Value类型绑定的方法，不能用指针类型去调用它，只能把指针类型再转为Value类型，使用Elem函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>func (v Value) Elem() Value   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"> <span class="comment">//重点：Elem返回v持有的接口保管的值的Value类型封装，或持有的指针指向的值的Value类型封装</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line"><span class="string">"fmt"</span>    </span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改反射变量的值    </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;    </span><br><span class="line">    <span class="comment">//1、获取到reflect.Value  </span></span><br><span class="line">    rVal := reflect.ValueOf(b)<span class="comment">//rVal=100    </span></span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)  </span><br><span class="line">    <span class="comment">//main函数中调用函数时传的是地址，rVal的值为一个地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取rVal的Kind    </span></span><br><span class="line">    rKind:=rVal.Kind()  </span><br><span class="line">    fmt.Printf(<span class="string">"rVal Kind=%v\n"</span>,rKind)   </span><br><span class="line">    <span class="comment">//输出：rVal Kind=ptr，</span></span><br><span class="line">    <span class="comment">//rVal的Kind是指针，因为main函数中调用函数时传的是地址     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、通过SetXXX修改变量的值    </span></span><br><span class="line">    <span class="comment">//rVal.SetInt(20) //error   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//func (v Value) SetXXX(x XXX)，  </span></span><br><span class="line">    <span class="comment">//SetXXX方法是和Value类型绑定的方法，不能用指针类型去调用它    </span></span><br><span class="line">    <span class="comment">//只能把指针类型再转为Value类型，使用Elem函数    </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//func (v Value) Elem() Value   </span></span><br><span class="line">    <span class="comment">//Elem返回v持有的接口保管的值的Value类型封装，或持有的指针指向的值的Value类型封装     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、通过Elem()获取到指针指向的值，再通过SetXXX修改变量的值     </span></span><br><span class="line">    rVal.Elem().SetInt(<span class="number">20</span>)    <span class="comment">//值修改为20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;     </span><br><span class="line">    <span class="comment">//1、定义一个int    </span></span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span>     </span><br><span class="line">    <span class="comment">//2、反射    </span></span><br><span class="line">    reflectTest01(&amp;num)<span class="comment">//修改变量num的值，所以要穿num的地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、打印修改后的num</span></span><br><span class="line">    fmt.Println(<span class="string">"num="</span>,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rVal=<span class="number">0xc000060058</span> rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">rVal Kind=ptr</span><br><span class="line">num= <span class="number">20</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/" data-id="ckcukir6r000uh8viirg844bf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/20/GO：2-3-字典的操作和约束/">GO：2.3 字典的操作和约束</a>
          </li>
        
          <li>
            <a href="/2020/07/17/GO：2-2-container包中的容器/">GO：2.2 container包中的容器</a>
          </li>
        
          <li>
            <a href="/2020/07/16/GO：2-1-数组和切片/">GO：2.1 数组和切片</a>
          </li>
        
          <li>
            <a href="/2020/07/13/GO：1-4-程序实体/">GO：1.4 程序实体</a>
          </li>
        
          <li>
            <a href="/2020/07/12/GO：1-3-库源码文件/">GO：1.3 库源码文件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>