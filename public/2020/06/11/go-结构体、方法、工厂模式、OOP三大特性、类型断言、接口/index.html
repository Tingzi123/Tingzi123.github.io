<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>go:结构体、方法、工厂模式、OOP三大特性、类型断言、接口 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="面向对象-结构体1、GO支持面向对象编程（OOP），但不是纯粹的面向对象编程语言，更准确地说是GO支持面向对象编程特性2、GO没有类的概念，结构体（struct）来实现OOP3、GO面向对象编程非常简洁，去掉传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等4、Go仍然有面向对象编程的继承、封装和多态的特性，只是实现方式不一样。5、GO面向对象（OOP）很优雅，OOP本身就是">
<meta property="og:type" content="article">
<meta property="og:title" content="go:结构体、方法、工厂模式、OOP三大特性、类型断言、接口">
<meta property="og:url" content="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="面向对象-结构体1、GO支持面向对象编程（OOP），但不是纯粹的面向对象编程语言，更准确地说是GO支持面向对象编程特性2、GO没有类的概念，结构体（struct）来实现OOP3、GO面向对象编程非常简洁，去掉传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等4、Go仍然有面向对象编程的继承、封装和多态的特性，只是实现方式不一样。5、GO面向对象（OOP）很优雅，OOP本身就是">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/struct1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/struct2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method1.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method2.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method3.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/oop1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/assert1.png">
<meta property="og:updated_time" content="2020-06-11T07:57:30.730Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go:结构体、方法、工厂模式、OOP三大特性、类型断言、接口">
<meta name="twitter:description" content="面向对象-结构体1、GO支持面向对象编程（OOP），但不是纯粹的面向对象编程语言，更准确地说是GO支持面向对象编程特性2、GO没有类的概念，结构体（struct）来实现OOP3、GO面向对象编程非常简洁，去掉传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等4、Go仍然有面向对象编程的继承、封装和多态的特性，只是实现方式不一样。5、GO面向对象（OOP）很优雅，OOP本身就是">
<meta name="twitter:image" content="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/struct1.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/" class="article-date">
  <time datetime="2020-06-11T07:35:04.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      go:结构体、方法、工厂模式、OOP三大特性、类型断言、接口
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="面向对象-结构体"><a href="#面向对象-结构体" class="headerlink" title="面向对象-结构体"></a>面向对象-结构体</h3><p>1、GO支持面向对象编程（OOP），但不是纯粹的面向对象编程语言，更准确地说是<strong>GO支持面向对象编程特性</strong><br>2、GO没有类的概念，结构体（struct）来实现OOP<br>3、GO面向对象编程非常简洁，去掉传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等<br>4、Go仍然有面向对象编程的继承、封装和多态的特性，只是实现方式不一样。<br>5、GO面向对象（OOP）很优雅，OOP本身就是语言类型系统的一部分（Go天然支持OOP），通过接口（interface）关联，耦合性低，非常灵活。<br>6、GO更准确的说是<strong>面向接口编程</strong></p>
<h5 id="1、结构体变量在内存中的布局"><a href="#1、结构体变量在内存中的布局" class="headerlink" title="1、结构体变量在内存中的布局"></a>1、结构体变量在内存中的布局</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Color <span class="keyword">string</span></span><br><span class="line">    Hobby <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个结构体cat变量</span></span><br><span class="line">vat cat1 Cat</span><br><span class="line">cat.Name = <span class="string">"小白"</span></span><br><span class="line">cat.Age = <span class="number">3</span></span><br><span class="line">cat.Color = <span class="string">"白色"</span></span><br><span class="line">cat.Hobby = <span class="string">"吃鱼"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"cat1="</span>,cat1)</span><br></pre></td></tr></table></figure>
<p>结构体是自定义的数据类型(如Cat)，结构体变量（实例）是具体的、实际的一个变量(如cat1)</p>
<p>结构体实例在内存中的布局，以cat1为例<br>1、当代码执行到“var cat1 Cat”时，cat1指向一个结构体，这时还没有给结构体的各个字段赋值，所以各个字段为默认值<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/struct1.jpg" alt="struct1"></p>
<p>2、结构体有一个自己的地址，cat1直接指向一个结构体的数据空间，而不是结构体的地址，所以<strong>结构体是值类型</strong></p>
<p>3、赋值语句为结构体的字段赋值<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/struct2.jpg" alt="struct2"></p>
<p>总结：</p>
<ul>
<li>当我们声明一个结构体变量时，结构体的数据空间已经有了，且结构体的每个字段已有<strong>默认值</strong></li>
<li>声明结构体变量后，该变量指向一个结构体的数据空间，而不是该结构体数据空间的地址，所以结构体是<strong>值类型</strong></li>
</ul>
<h5 id="2、结构体声明"><a href="#2、结构体声明" class="headerlink" title="2、结构体声明"></a>2、结构体声明</h5><p>1、在创建一个变量后，如果没有给字段赋值，系统会赋零值</p>
<ul>
<li>基本数据类型赋零值</li>
<li><strong>引用类型：slice、map、指针的零值是nil，即没有分配内存空间</strong></li>
<li>数组类型的默认值与元素相关</li>
</ul>
<p>2、不同结构体变量的字段你是独立的，互不影响。因为结构体是值类型、默认是值拷贝</p>
<h5 id="3、创建结构体实例的4种方式"><a href="#3、创建结构体实例的4种方式" class="headerlink" title="3、创建结构体实例的4种方式"></a>3、创建结构体实例的4种方式</h5><p>1、直接声明<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vat person Person</span><br><span class="line">person.field1 = value1</span><br><span class="line">person.field2 = value2</span><br><span class="line">person.field3 = value3</span><br></pre></td></tr></table></figure></p>
<p>2、声明时直接为字段赋值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vat person Person = Person&#123;</span><br><span class="line">    field1:value1</span><br><span class="line">    field2:value2</span><br><span class="line">    field3:value3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、通过new函数创建，创建对象是一个指向该结构体的指针<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vat person *Person = <span class="built_in">new</span>(Person)</span><br><span class="line"><span class="comment">//person是一个指针，标准赋值方式如下</span></span><br><span class="line">(*person).field1 = value1  </span><br><span class="line">(*person).field2 = value2</span><br><span class="line">(*person).field3 = value3</span><br><span class="line"><span class="comment">//运算符优先级："." &gt; "*"，所以需要括号(*person).field1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可简写为</span></span><br><span class="line">person.field1 = value1</span><br><span class="line">person.field2 = value2</span><br><span class="line">person.field3 = value3</span><br><span class="line"></span><br><span class="line"><span class="comment">//GO的设计者为了使用方便，底层会对简写写法person.field1 = value1进行处理，会给person加上取值运算 (*person).field1 = value1</span></span><br></pre></td></tr></table></figure></p>
<p>4、vat person *Person = &amp;Person{}，可以直接再{}中赋值，如方式2，也可如下赋值，如方式3<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    vat person *Person = &amp;Person&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person是一个指针，标准赋值方式如下</span></span><br><span class="line">    (*person).field1 = value1</span><br><span class="line">    (*person).field2 = value2</span><br><span class="line">    (*person).field3 = value3</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可简写为</span></span><br><span class="line">    person.field1 = value1</span><br><span class="line">    person.field2 = value2</span><br><span class="line">    person.field3 = value3</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GO的设计者为了使用方便，底层会对简写写法person.field1 = value1进行处理，会给person加上取值运算 (*person).field1 = value1</span></span><br></pre></td></tr></table></figure></p>
<p>总结:</p>
<ul>
<li>方式3和方式4返回的是一个<strong>结构体指针</strong></li>
</ul>
<h5 id="4、结构体内细节"><a href="#4、结构体内细节" class="headerlink" title="4、结构体内细节"></a>4、结构体内细节</h5><p>1、<strong>结构体中所有字段在内存中是连续分布的</strong><br>2、当结构体的字段是指针时，指针本身的地址是连续的，但是指针指向的地址指值不一定连续<br>3、结构体使用户单独定义的类型，和其它类型转换时，需要有完全相同的字段（名字、个数和累型）<br>4、结构体进行type重新定义（相当于取别名），Go认为是<strong>新的数据类型</strong>，但是相互间可以强转<br>5、在结构体的每个字段上，可以写上一个<strong>tag</strong>，该tag可以通过<strong>反射机制</strong>获取，常见的使用场景就是<strong>序列化</strong>和<strong>反序列化</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age <span class="keyword">int</span> <span class="string">`json:"age"`</span></span><br><span class="line">    Skill <span class="keyword">string</span> <span class="string">`json:"skill"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">monster := Monster&#123;</span><br><span class="line">    <span class="string">"牛魔王"</span>，</span><br><span class="line">    <span class="number">500</span>，</span><br><span class="line">    “牛头拳”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将monster变量序列化为json字符串（反射机制）</span></span><br><span class="line">jsonStr,err := json.Marshal(monster)<span class="comment">//返回值为[]byte切片</span></span><br><span class="line"><span class="comment">//这里json包去访问monster中的字段，如果字段小写则访问不到，字段小写表示只能当前包内访问，则只能大写。但是大写，json格式化后json串中也是大写，与前端命名习惯不一致，所以可以用tag为字段取别名成小写形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"json处理错误"</span>，err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"jsonStr"</span>,<span class="keyword">string</span>(jsonStr))</span><br></pre></td></tr></table></figure></p>
<h3 id="方法method"><a href="#方法method" class="headerlink" title="方法method"></a>方法method</h3><p>1、Go中方法是<strong>作用在指定的数据类型上</strong>的（和指定数据类型绑定），因此自定义类型，都可以有方法（不仅是struct）。</p>
<p>2、方法的声明与调用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="comment">//A结构体有一个方法test，说明test方法和结构体（类型）A绑定，test方法只能被A的对象来调用</span></span><br><span class="line"></span><br><span class="line">    a.Num=<span class="number">2</span> <span class="comment">//这里的改变不会影响main函数中的赋值输出，因为struct是值类型，func (a A)这里不是指针。</span></span><br><span class="line">    fmt.Println(a.Num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a A </span><br><span class="line">    a.Num=<span class="number">1</span></span><br><span class="line">    a.test()<span class="comment">//调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   由上述代码有：</p>
<ul>
<li>1、test方法和A类型绑定</li>
<li>2、test方法只能通过A的实例来调用，<strong>不能直接调用</strong>，也不能用其他类型调用</li>
<li><strong>3</strong>、func (a A) test()，<strong>a表示哪个A实例调用，他就是该实例的副本</strong>，和函数传参类似，由于<strong>struct是值类型</strong>，func (a A)这里不是指针，所以方法中对字段重新赋值不会影响main函数中的值</li>
</ul>
<h4 id="方法的调用和传参机制"><a href="#方法的调用和传参机制" class="headerlink" title="方法的调用和传参机制"></a>方法的调用和传参机制</h4><p><strong>重点</strong>：方法的调用和传参机制和函数基本一样，不一样的地方是方法调用时，<strong>会将调用方法的实例变量，当作实参也传递给方法</strong></p>
<p>示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">getSum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p Person </span><br><span class="line">    p.Name = <span class="string">"tom"</span></span><br><span class="line">    </span><br><span class="line">    n1 := <span class="number">10</span></span><br><span class="line">    n2 := <span class="number">20</span></span><br><span class="line">    res := p.getSum(n1,n2)<span class="comment">//调用方法</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1、main函数中执行“n1 := 10 n2 := 20”时，内存中开辟main栈并压入变量n1和n2<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method1.png" alt="method1"></p>
<p>2、main函数执行 “ res := p.getSum(n1,n2)”时：</p>
<ul>
<li>先执行“p.getSum(n1,n2)”，内存中开辟getSum栈，并将n1和n2的值拷贝到getSum栈中，同时将结构体实例p值拷贝到getSum栈中（因为结构体实例p调用方法getSum），因为这里传的是“func (p Person)”，所以是值拷贝，所以main栈和getSum栈是完全独立的数据空间。若传指针则为引用传递<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method2.png" alt="method2"></li>
</ul>
<ul>
<li>然后执行赋值给res变量“res := p.getSum(n1,n2)”，main栈中压入res变量，res变量的值有函数getSum返回<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method3.png" alt="method3"></li>
</ul>
<p>注意：<strong>如果一个类型（结构体）实现了String()这个方法，fmt.Println默认会调用这个结构体变量的String()方法输出</strong></p>
<h4 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h4><p>1、调用方式不一样</p>
<ul>
<li>函数的调用方式：函数名（实参列表）</li>
<li>方法的调用方式：绑定类型变量.方法名（实参列表）</li>
</ul>
<p>2、对于普通函数，接收者为值类型时，不能将指针类型数据直接传递，反之亦然</p>
<p>3、对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反之亦然<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">       Name <span class="keyword">string</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">       p.Name = <span class="string">"jack"</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//jack</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">test01</span><span class="params">()</span></span> &#123;</span><br><span class="line">       p.Name = <span class="string">"marry"</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//marry</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">var</span> p Person </span><br><span class="line">       p.Name = <span class="string">"tom"</span></span><br><span class="line">       </span><br><span class="line">       p.test() <span class="comment">//ok</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//tom</span></span><br><span class="line">       </span><br><span class="line">       (&amp;p).test()  <span class="comment">//用p的地址（指针）调也可以，但仍然是值拷贝，只是形式上看是引用拷贝，但是接受的地方“func (p Person)”是传值，所以底层会处理为“p.test()”，只有接受的地方为传地址（如 func (p *Person)），才是引用传递</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//tom</span></span><br><span class="line">       </span><br><span class="line">       (&amp;p).test01()<span class="comment">//ok</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name)<span class="comment">//marry</span></span><br><span class="line">       </span><br><span class="line">       p.test01()<span class="comment">//ok，等价于(&amp;p).test01()，底层处理，形式上传值，实际传地址，因为接受的地方为传地址（如 func (p *Person)）</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name)<span class="comment">//marry </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>针对第3条总结</strong>：<strong>重点重点</strong><br>不管调用的形式如何，真正决定是值拷贝还是地址拷贝，看定义这个方法时跟哪个类型绑定，若跟指针（如 p *Person）绑定则为地址拷贝，若跟值类型（如 p Person）绑定则为值拷贝</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>1、GO的结构体没有<strong>构造函数</strong>，通常使用工厂模式来解决</p>
<ul>
<li>使用工厂模式实现跨包创建结构体实例</li>
</ul>
<p>1）model包下有结构体Student<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model </span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> student <span class="keyword">struct</span>&#123;</span><br><span class="line"> <span class="comment">//这里结构体定义为小写student，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Score <span class="keyword">float64</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//使用工厂模式</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>,score <span class="keyword">float64</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">          Name : name,</span><br><span class="line">          Score : score,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>2）main包下使用工厂模式创建结构体student实例<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"factory/model"</span></span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用工厂模式创建student实例</span></span><br><span class="line">    <span class="keyword">var</span> stu = model.NewStudent(<span class="string">"tom"</span>,<span class="number">88.8</span>)<span class="comment">//返回值为一个指针</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu) <span class="comment">//输出&amp;&#123;tom 88.8&#125;</span></span><br><span class="line">   fmt.Println(*stu) <span class="comment">//输出&#123;tom 88.8&#125;</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu.Name) <span class="comment">//等价于(*stu).Name 输出tom</span></span><br><span class="line">   fmt.Println(stu.Score) <span class="comment">//等价于(*stu).Score 输出88.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果结构体中的字段也是小写，只能在定义结构体的包中使用，其他包不可访问，同理可以为结构体绑定一个公有方法，用于返回字段<br>1）model包下有结构体Student<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model </span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> student <span class="keyword">struct</span>&#123;</span><br><span class="line"> <span class="comment">//这里结构体定义为小写student，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        score <span class="keyword">float64</span></span><br><span class="line"> <span class="comment">//这里字段score定义为小写，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//使用工厂模式</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>,score <span class="keyword">float64</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">          Name : name,</span><br><span class="line">          score : score,<span class="comment">//该包内可以访问小写字段，其他包不可以</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//GetScore方法绑定结构体，返回字段score</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">GetScore</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.score</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2）main包下使用工厂模式创建结构体student实例<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"factory/model"</span></span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用工厂模式创建student实例</span></span><br><span class="line">    <span class="keyword">var</span> stu = model.NewStudent(<span class="string">"tom"</span>,<span class="number">88.8</span>)<span class="comment">//返回值为一个指针</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu) <span class="comment">//输出&amp;&#123;tom 88.8&#125;</span></span><br><span class="line">   fmt.Println(*stu) <span class="comment">//输出&#123;tom 88.8&#125;</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu.Name) <span class="comment">//等价于(*stu).Name 输出tom</span></span><br><span class="line">   fmt.Println(stu.GetScore()) <span class="comment">//输出88.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="面向对象编程三大特性"><a href="#面向对象编程三大特性" class="headerlink" title="面向对象编程三大特性"></a>面向对象编程三大特性</h3><p>面向对象编程三大特性：<strong>封装、继承、多态</strong>。</p>
<h4 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h4><p>1、封装：把<strong>抽象出来的字段和对字段的操作封装在一起</strong>，数据就被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作</p>
<p>2、封装的优点</p>
<ul>
<li>隐藏实现的细节</li>
<li>提供方法可以对数据进行验证、保证安全合理</li>
</ul>
<p>3、如何体现封装</p>
<ul>
<li>对结构体中的属性进行封装</li>
<li>通过方法、包实现封装</li>
</ul>
<p>4、封装的实现<br>参考上一个笔记，工厂模式（将结构体、属性定义为包私有，通过公有方法访问）</p>
<h4 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h4><p>继承可以<strong>解决代码复用</strong>，提高扩展性、可维护性<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/oop1.jpg" alt="oop1"><br>GO使用在一个结构体中<strong>嵌套匿名结构体</strong>的方式来实现继承<br>案例：<br>1、抽取共有字段和方法，创建一个结构体Student<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">      Name <span class="keyword">string</span></span><br><span class="line">      Age <span class="keyword">int</span></span><br><span class="line">      Score <span class="keyword">float64</span>     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//共有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">ShowInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"学生名=%v年龄=%v 成绩=%v           \n"</span>,stu.Name,stu.Age,stu.Score)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">SetScore</span><span class="params">(score <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">       stu.Score = score</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>2、创建结构体Pupil<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pupil <span class="keyword">struct</span>&#123;</span><br><span class="line">      Student    <span class="comment">//嵌入Student匿名结构体</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Pupil特有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(p *Pupil)</span> <span class="title">testing</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"小学生正在考试中"</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>3、创建结构体Graduate<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Graduate <span class="keyword">struct</span>&#123;</span><br><span class="line">      Student    <span class="comment">//嵌入Student匿名结构体</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Graduate特有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(g *Graduate)</span> <span class="title">testing</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"大学生正在考试中"</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>4、main创建实例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//当我们对结构体嵌入了匿名结构体后，使用方法发生了变化</span></span><br><span class="line">     <span class="comment">//创建一个Pupil实例</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Student.Name = <span class="string">"tom"</span></span><br><span class="line">     pupil.Student.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.Student.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//创建一个Graduate实例</span></span><br><span class="line">     graduate := &amp;Graduate&#123;&#125;</span><br><span class="line">     graduate.Student.Name = <span class="string">"marry"</span></span><br><span class="line">     graduate.Student.Age = <span class="number">8</span></span><br><span class="line">     graduate.testing()</span><br><span class="line">     graduate.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     graduate.Student.ShowInfo()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="继承细节"><a href="#继承细节" class="headerlink" title="继承细节"></a>继承细节</h5><p>1、结构体可以使用嵌套匿名结构体的<strong>所有字段和方法</strong>，即：首字母大写和小写的字段和方法都可以使用</p>
<p>2、访问匿名结构体字段可以简化<br>在上述案例中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//当我们对结构体嵌入了匿名结构体后，使用方法发生了变化</span></span><br><span class="line">     <span class="comment">//创建一个Pupil实例</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Student.Name = <span class="string">"tom"</span></span><br><span class="line">     pupil.Student.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.Student.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//创建Pupil实例，访问Pupil结构体中的匿名结构体Student的字段和方法可以简化为</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Name = <span class="string">"tom"</span></span><br><span class="line">     pupi.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//pupil.Student.Name = "tom" 等价于pupil.Name = "tom"，</span></span><br><span class="line">    <span class="comment">// pupil.Name 先去pupil找Name字段，如果没有，再去Pupil结构体中的匿名结构体Student找字段Name</span></span><br><span class="line">    <span class="comment">//如果找到则访问，否则报错</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>3、当结构体和匿名结构体有相同的字段或方法时，编译器采用<strong>就近访问原则</strong>访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体来区分<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">SayOk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"A SayOK"</span>,a.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"A hello"</span>,a.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    A</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SayOk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"b SayOK"</span>,b.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    </span><br><span class="line">    b.Name = <span class="string">"jack"</span><span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//去结构体B中找字段Name，找到并赋值jack，则b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.SayOK() <span class="comment">//b SayOK jack</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法SayOK ，找到并执行fmt.Println("b SayOK",b.Name)，这里b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.hello() <span class="comment">//A hello ""空串</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法hello，没有找到，再去匿名结构体A中找，找到并执行fmt.Println("A hello"，a.Name)，前面的语句并没有为a.Name赋值，则为默认值空串，a.Name就近等于空串</span></span><br><span class="line">    </span><br><span class="line">    b.A.Name = <span class="string">"tom"</span><span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//去结构体B的匿名结构体A中找字段Name，找到并赋值tom，则b.Name= "tom"</span></span><br><span class="line">    </span><br><span class="line">    b.SayOK() <span class="comment">//b SayOK jack</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法SayOK ，找到并执行fmt.Println("b SayOK",b.Name)，这里b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.A.SayOK() <span class="comment">//A SayOK tom</span></span><br><span class="line">    <span class="comment">//去结构体B的匿名结构体A中找方法SayOK ，找到并执行fmt.Println("A hello",a.Name)，这里a.Name= "tom"</span></span><br><span class="line">    </span><br><span class="line">    b.hello() <span class="comment">//A hello tom</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法hello，没有找到，再去匿名结构体A中找，找到并执行fmt.Println("A hello"，a.Name)，前面的语句为a.Name赋值tom，则a.Name就近等于tom</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、当结构体嵌入两个（或多个）匿名结构体，如<strong>两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的字段和方法）</strong>，在访问时，就必须要明确指定匿名结构体的名字，否则编译报错</p>
<p>5、如果一个struct嵌套了一个有名字的结构体，这种模式就是<strong>组合</strong>，如果是组合关系，那么在访问组合的结构体的字段和方法时，就必须带上结构体的名字，<strong>不能简写</strong>。<br>Go中层级关系明确，如果是组合关系，例：一个结构体A嵌套了一个有名结构体B，B的名字为b,B有字段Name，现创建A的实例a,访问字段Name时，只能a.b.Name，不能a.Name，编译器会报错。看到a.Name时，编译器会去A中找字段Name，没有就立马报错（嵌套匿名结构体时会继续在匿名结构体中找）</p>
<p>6、嵌套匿名结构体后，也可以创建结构体变量时，直接指定各个匿名结构体字段的值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pupil := &amp;Pupil&#123;Student&#123;<span class="string">"tom"</span>，<span class="number">15</span>，<span class="number">78.5</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">pupil := &amp;Pupil&#123;</span><br><span class="line">    Student&#123;</span><br><span class="line">        Name:<span class="string">"tom"</span>，</span><br><span class="line">        Age:<span class="number">15</span>，</span><br><span class="line">        Score:<span class="number">78.5</span>，</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>7、在结构体中嵌入匿名结构体时，也可以直接嵌入匿名结构体的指针，这样效率更高</p>
<p>8、在结构体中嵌入匿名结构体时，也可以直接嵌入匿名基本数据类型。<br>如嵌入匿名int，访问时直接通过 “外层结构体实例名.int = 20”这种形式。但是不能同时侵入两个同样的匿名基本数据类型，因为无法区分，如嵌入两个匿名int，这是不允许的。</p>
<h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>一个struct嵌套了多个匿名结构体，那么该结构体可以直接访问所有嵌套的匿名结构体的字段和方法，从而实现多重继承<br>1、当结构体嵌入两个（或多个）匿名结构体，如<strong>两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的字段和方法）</strong>，在访问时，就必须要明确指定匿名结构体的名字，否则编译报错</p>
<p>2、为了代码简洁性，建议尽量不适用多重继承</p>
<h4 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a>3、多态</h4><h5 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、变量（实例）具有多种形态，在GO中，多态特征是通过接口实现的。可以按照统一的接口来调用不同的实现，这时<strong>接口变量就呈现不同的形态</strong>。<br>案例说明：<br>1、定义一个接口Usb<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span>&#123;</span><br><span class="line">    <span class="comment">//声明两个没有实现的方法</span></span><br><span class="line">    Start()</span><br><span class="line">    Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、定义一个结构体Phone<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">type</span> Stu <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让Phone实现接口Usb的所有方法，即实现了接口Usb</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机开始工作。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机停止工作。。。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、再定义一个结构体Camera<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> Stu Camera&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//让Camera实现接口Usb的所有方法，即实现了接口Usb</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">     fmt.Println(<span class="string">"相机开始工作。。。"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">     fmt.Println(<span class="string">"相机停止工作。。。"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>4、再定义一个结构体Computer<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu Computer&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个方法Working，接收一个Usb接口类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">Working</span><span class="params">(usb Usb)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过usb接口变量来调用Start和Stop方法</span></span><br><span class="line">    usb.Start()</span><br><span class="line">    usb.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5、在main函数中使用接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建结构体Computer变量</span></span><br><span class="line">    computer := Computer&#123;&#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//创建结构体Phone变量</span></span><br><span class="line">    phone := Phone&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建结构体Camera变量</span></span><br><span class="line">    camera := Camera&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关键点</span></span><br><span class="line">    computer.Working(phone)</span><br><span class="line">    <span class="comment">//手机开始工作。。。</span></span><br><span class="line">    <span class="comment">//手机停止工作。。。</span></span><br><span class="line">    </span><br><span class="line">    computer.Working(camera)</span><br><span class="line">     <span class="comment">//相机开始工作。。。</span></span><br><span class="line">    <span class="comment">//相机停止工作。。。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结构体Computer的Working函数接收的是一个Usb接口变量，因为结构体Phone和Camera都实现了这个接口，所以可以传入，并且当传Phone时，可以动态的调用phone.Start()和phone.Stop()，传入camera时同理。Usb接口变量体现出多态。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2、接口体现多态的特征"><a href="#2、接口体现多态的特征" class="headerlink" title="2、接口体现多态的特征"></a>2、接口体现多态的特征</h5><p>1、多态参数<br>在前面的Usb接口案例中，Computer的Working函数接收的是一个Usb接口变量，Phone和Camera都实现了这个接口，所以既可以接收Phone变量，又可以接收Camera变量，体现出多态。</p>
<p>2、多态数组<br>在上述Usb案例中，我们可以定义一个Usb接口数组<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个Usb接口数组，可以存放Phone和Camera的结构体变量</span></span><br><span class="line">    <span class="keyword">var</span> usbArr [<span class="number">3</span>]Usb</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;nil&gt;&lt;nil&gt;&lt;nil&gt;]</span></span><br><span class="line">    </span><br><span class="line">    usbArr[<span class="number">0</span>] = Phone&#123;&#125;</span><br><span class="line">    usbArr[<span class="number">1</span>] = Phone&#123;&#125;</span><br><span class="line">    usbArr[<span class="number">2</span>] = Camera&#123;&#125;</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;&gt;&lt;&gt;&lt;&gt;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上述的案例中的结构体都没有字段，这里都加上Name字段，然后创建结构体变量</span></span><br><span class="line">    usbArr[<span class="number">0</span>] = Phone&#123;<span class="string">"华为"</span>&#125;</span><br><span class="line">    usbArr[<span class="number">1</span>] = Phone&#123;<span class="string">"小米"</span>&#125;</span><br><span class="line">    usbArr[<span class="number">2</span>] = Camera&#123;<span class="string">"索尼"</span>&#125;</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;华为&gt;&lt;小米&gt;&lt;索尼&gt;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Usb接口数组usbArr，可以存放Phone和Camera的结构体变量，体现出多态数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><h5 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、<strong>类型断言</strong>，由于<strong>接口</strong>是一般类型，<strong>不知道具体类型</strong>。如果要转成具体类型，就需要使用类型断言。</p>
<h5 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h5><p>1、定义结构体Point<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">    y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、main函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; <span class="comment">//定义一个空接口类型变量a</span></span><br><span class="line">    <span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment">//定义Point类型变量point</span></span><br><span class="line">    </span><br><span class="line">    a = point <span class="comment">//ok，</span></span><br><span class="line">    <span class="comment">//将Point类型变量point赋给一个空接口类型变量a，</span></span><br><span class="line">    <span class="comment">//使空接口类型变量a指向Point类型的变量point</span></span><br><span class="line">    <span class="comment">//空接口变量可以接收任何数据类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b Point</span><br><span class="line">    <span class="comment">//b = a不可以，不可以将一个空接口类型变量a赋给其他数据类型</span></span><br><span class="line">    <span class="comment">//b = a.(Point)可以，a.(Point)称为类型断言</span></span><br><span class="line">    </span><br><span class="line">    b,ok = a.(Point) </span><br><span class="line">    <span class="comment">//判断空接口类型变量a是指向Point类型的变量</span></span><br><span class="line">    <span class="comment">//如果是就转成Point类型的变量并赋给b，否则报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类型断言检查，不要让断言失败直接panic终止程序</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(b)<span class="comment">//输出&lt;1，2&gt;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         fmt.Println(<span class="string">"转换失败"</span>)</span><br><span class="line">     &#125;       </span><br><span class="line">     </span><br><span class="line">     fmt.Println(<span class="string">"代码继续执行"</span>)<span class="comment">//类型断言检查，断言失败不会panic终止程序，这里还会执行到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>重点</strong>：</p>
<ul>
<li>在进行类型断言时，如果类型不匹配，就会报panic。因此进行类型断言时，要确保原来的空接口指向的就是要断言的类型</li>
<li>例：首先“a = point ”使空接口类型变量a指向Point类型的变量point，才可以类型断言“b = a.(Point) ”</li>
</ul>
<h5 id="3、类型断言最佳案例"><a href="#3、类型断言最佳案例" class="headerlink" title="3、类型断言最佳案例"></a>3、类型断言最佳案例</h5><p><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/assert1.png" alt="assert1"></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h5 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、interface类型可以定义一组方法但是不需要实现</p>
<p>2、interface中<strong>不能包含任何变量</strong></p>
<h5 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    method1(参数列表)返回值列表</span><br><span class="line">    method2(参数列表)返回值列表</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> 自定义类型名 <span class="keyword">struct</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s 自定义类型名)</span> <span class="title">method1</span><span class="params">(参数列表)</span>返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">//方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s 自定义类型名)</span> <span class="title">method2</span><span class="params">(参数列表)</span>返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">//方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意：<br>1）接口中的所有方法都没有方法体，即接口的方法都是没有实现的方法。体现<strong>多态</strong>、<strong>高内聚低耦合</strong></p>
<p>2）Go中的接口，不需要显示实现。只要一个结构体变量（实例）含有接口类型中的所有方法，则称这个结构体变量实现了这个接口（没有类似implement这样的关键字，GO是基于方法实现的多态，而不需显示指出接口名称）。</p>
<p>3）如果由接口a和接口b有完全一样的方法列表，那么有实例c如果实现了接口a，同时也就实现了接口b，即：同时实现两个或两个以上的接口（在其他语言中是做不到的，例如Java，必须显示implement实现a，再显示implement实现b）</p>
<p>4）特别指出，需要<strong>实现接口所有的方法</strong></p>
<h5 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h5><p>1、<strong>接口本身不能创建实例</strong>，但是可以指向一个实现了该接口的自定义类型（如struct）的变量（实例）</p>
<p>2、接口中的所有方法都没有方法体，即接口的方法都是没有实现的方法</p>
<p>3、Go中，一个自定义类型需要将某个接口的<strong>所有方法都实现</strong>，才能称这个自定义类型实现了该接口</p>
<p>4、只要是自定义类型，都可以实现接口，不仅仅是结构体类型。如自定义一个int类型“type integer int”，这个自定义的类型integer也可以实现接口</p>
<p>5、一个自定义类型可以<strong>实现多个</strong>接口。（只要把多个接口的方法都实现就可以）</p>
<p>6、Go接口中不能有任何变量（常量也不可以）</p>
<p>7、一个接口（如接口A）可以<strong>继承多个</strong>别的接口（如接口B和C），这时如果要实现接口A，也必须要将接口B和C的方法全部实现，但是<strong>接口B和C中不能有完全相同的方法</strong>，编译器会报错重复定义，因为无法区分。</p>
<p>8、interface类型默认是一个<strong>指针</strong>（<strong>引用类型</strong>），如果没有对interface初始化就使用，那么会输出nil</p>
<p>9、空接口interface{}，没有任何方法，所以<strong>所有类型都默认实现了空接口</strong>（即空接口可以接收任何数据类型，可以把任何数据类型变量赋给空接口）。</p>
<p>10、<strong>空接口也是一种数据类型</strong><br>例：可以声明一个空接口类型变量<br>“vat t interface{}”</p>
<p>该空接口类型变量可以接收任何数据类型的值<br>“t = student”//接收一个Student类型的变量student<br>“t = 8.8”//接收一个float类型的值8.8</p>
<h5 id="4、接口使用案例"><a href="#4、接口使用案例" class="headerlink" title="4、接口使用案例"></a>4、接口使用案例</h5><p>1、定义一个接口AInteger<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AInteger <span class="keyword">interface</span>&#123;</span><br><span class="line">    Test01()</span><br><span class="line">    Test02()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、再定义一个接口BInteger<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AInteger <span class="keyword">interface</span>&#123;</span><br><span class="line">    Test01()</span><br><span class="line">    Test03()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、定义一个结构体Stu<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test01</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test02</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test03</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4、在main函数中使用接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stu := Stu&#123;&#125;<span class="comment">//创建一个Stu实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> a AInteger =stu </span><br><span class="line">    <span class="comment">//ok，将实例stu赋给接口AInteger的变量a，因为stu实现了接口AInteger中的所有方法（ Test01和Test02）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b BInteger =stu</span><br><span class="line">    <span class="comment">//ok，将实例stu赋给接口BInteger的变量b，因为stu实现了接口BInteger中的所有方法（ Test01和Test03）</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"ok"</span>,a,b)<span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5、接口与继承比较"><a href="#5、接口与继承比较" class="headerlink" title="5、接口与继承比较"></a>5、接口与继承比较</h5><p>1、当B结构体继承了A结构体，那么B结构体就自动的继承了A结构体的字段和方法，并且可以直接使用</p>
<p>2、B结构体需要扩展功能，同时不希望破坏继承关系，可以去实现某个接口，因此，可以认为：实现<strong>接口是对继承机制的一种补充</strong></p>
<p>3、接口与继承解决的问题不同</p>
<ul>
<li>继承的价值：解决代码的<strong>复用性</strong>和<strong>可维护性</strong></li>
<li>接口的价值：<strong>设计</strong>，设计好各种规范（方法），让其他自定义类型去实现这些方法来增强功能</li>
</ul>
<p>4、接口比继承更加灵活。<strong>继承</strong>是满足 <strong>is - a</strong> 的关系，<strong>接口</strong>只需要满足 <strong>like - a</strong> 的关系</p>
<p>5、接口在一定程度上实现代码解耦，尤其在GO中更加松散</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/" data-id="ckcivu88p000wa0vij3dbn6x1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/11/go-文件操作、json/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          go:文件操作、json
        
      </div>
    </a>
  
  
    <a href="/2020/06/11/go-错误处理机制、数组、切片、map/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">go:错误处理机制、数组、切片、map</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/12/GO：1-3-库源码文件/">GO：1.3 库源码文件</a>
          </li>
        
          <li>
            <a href="/2020/07/10/GO：1-2-命令源码文件/">GO：1.2 命令源码文件</a>
          </li>
        
          <li>
            <a href="/2020/07/10/GO：工作区和GOPATH/">GO：工作区和GOPATH</a>
          </li>
        
          <li>
            <a href="/2020/07/02/hexo博客迁移/">hexo博客迁移</a>
          </li>
        
          <li>
            <a href="/2020/06/15/测试驱动开发TDD/">测试驱动开发TDD</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>