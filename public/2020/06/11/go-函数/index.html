<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>go:函数 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1、函数1、函数调用底层机制有如下示例下图中的内存空间划分均为逻辑划分  从main函数入口开始执行程序在内存中会为main函数在栈上开辟一个空间，并为变量n1赋值10  2、调用函数test()逻辑上内存会为函数test()在栈上另外开辟一个空间（逻辑上），用于存放test（）函数中的数据 3、调用函数test()，并传入参数n1test（）函数接受main（）函数传过来的参数n1，在test栈">
<meta property="og:type" content="article">
<meta property="og:title" content="go:函数">
<meta property="og:url" content="http://yoursite.com/2020/06/11/go-函数/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1、函数1、函数调用底层机制有如下示例下图中的内存空间划分均为逻辑划分  从main函数入口开始执行程序在内存中会为main函数在栈上开辟一个空间，并为变量n1赋值10  2、调用函数test()逻辑上内存会为函数test()在栈上另外开辟一个空间（逻辑上），用于存放test（）函数中的数据 3、调用函数test()，并传入参数n1test（）函数接受main（）函数传过来的参数n1，在test栈">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func3.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func4.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func5.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func6.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func7.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func9.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func10.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func11.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-函数/func12.jpg">
<meta property="og:updated_time" content="2020-06-11T08:13:42.277Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go:函数">
<meta name="twitter:description" content="1、函数1、函数调用底层机制有如下示例下图中的内存空间划分均为逻辑划分  从main函数入口开始执行程序在内存中会为main函数在栈上开辟一个空间，并为变量n1赋值10  2、调用函数test()逻辑上内存会为函数test()在栈上另外开辟一个空间（逻辑上），用于存放test（）函数中的数据 3、调用函数test()，并传入参数n1test（）函数接受main（）函数传过来的参数n1，在test栈">
<meta name="twitter:image" content="http://yoursite.com/2020/06/11/go-函数/func1.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-go-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-函数/" class="article-date">
  <time datetime="2020-06-11T07:19:21.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      go:函数
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、函数"><a href="#1、函数" class="headerlink" title="1、函数"></a>1、函数</h3><h4 id="1、函数调用底层机制"><a href="#1、函数调用底层机制" class="headerlink" title="1、函数调用底层机制"></a>1、函数调用底层机制</h4><p>有如下示例<br>下图中的内存空间划分均为逻辑划分</p>
<ol>
<li>从main函数入口开始执行程序<br><img src="/2020/06/11/go-函数/func1.jpg" alt="func1"><br>在内存中会为main函数在栈上开辟一个空间，并为变量n1赋值10</li>
</ol>
<p>2、调用函数test()<br><img src="/2020/06/11/go-函数/func2.jpg" alt="func2"><br>逻辑上内存会为函数test()在栈上另外开辟一个空间（逻辑上），用于存放test（）函数中的数据</p>
<p>3、调用函数test()，并传入参数n1<br><img src="/2020/06/11/go-函数/func3.jpg" alt="func3"><br>test（）函数接受main（）函数传过来的参数n1，<strong>在test栈区中另开辟一个空间存放传过来的参数</strong>，此时，<strong>main栈区和test栈区的n1已经没有关系了（引用类型除外）</strong>，所以test栈区中n1的改变不影响main栈区中的n1</p>
<p>4、test()函数执行n1=n1+1<br><img src="/2020/06/11/go-函数/func4.jpg" alt="func4"><br>test栈区中n1的改变不影响main栈区中的n1</p>
<p>5、test()函数执行打印n1语句，终端输出test栈区中的n1<br><img src="/2020/06/11/go-函数/func5.jpg" alt="func5"></p>
<p>6、test（）函数执行完之后，内存回收test栈区，<strong>test栈区中数据全部被清除</strong>，程序回到main（）函数调用test（）函数的地方<br><img src="/2020/06/11/go-函数/func6.jpg" alt="func6"></p>
<p>7、main()函数执行打印n1语句，终端输出main栈区中的n1<br><img src="/2020/06/11/go-函数/func7.jpg" alt="func7"></p>
<p>8、main（）函数执行完之后，内存回收main栈区，<strong>main栈区中数据全部被清除</strong>，程序结束<br><img src="/2020/06/11/go-函数/func8.jpg" alt="func8"></p>
<p>9、<strong>总结</strong></p>
<ul>
<li>在调用一个函数时，会为该函数分配一个新的栈空间，编译器会通过自身的处理让这个新的空间和其他的栈区空间区分开来</li>
<li>在每个函数对应的栈中，数据空间是独立的，不会混淆</li>
<li>当一个函数调用（执行）完毕后，程序会销毁这个函数对应的栈空间</li>
</ul>
<p>10、注意事项</p>
<ul>
<li>Go不支持传统的函数重载</li>
</ul>
<ul>
<li><p>Go中，<strong>函数本身也是一种数据类型</strong>。可以赋值给一个变量，则该变量就是一个函数类型的变量，<strong>通过该变量可以对函数调用</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">       <span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a:=getSum   <span class="comment">//把函数getSum赋给变量a</span></span><br><span class="line">    fmt.Println(<span class="string">"a的类型是%T,getSum的类型是%T\n"</span>,a,getSum)</span><br><span class="line">    </span><br><span class="line">    res := a(<span class="number">10</span>,<span class="number">40</span>)<span class="comment">//等价于 res := getSum(10,40)</span></span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为函数是一种数据类型，所以在Go中，<strong>函数可以作为形参并调用</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure>
</li>
<li><p>Go支持对函数返回值命名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSub</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>, sub <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">       <span class="comment">///返回值命名sum和sub</span></span><br><span class="line">       sub = n1 - n2</span><br><span class="line">       sum = n1 + n2</span><br><span class="line">       <span class="comment">//为sum和sub赋值，顺序无所谓，可与返回值列表顺序不同</span></span><br><span class="line">       <span class="keyword">return</span>      </span><br><span class="line">       <span class="comment">//等价于return sum , sub ，由于已为返回值命名sum和sub，函数体中已为sum和sub赋值，return时可省略不写返回值，再写上反而显得冗余  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Go支持可变参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//支持0到多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(args... <span class="keyword">int</span>)</span> <span class="title">sum</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//支持1到多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span> , args... <span class="keyword">int</span>)</span> <span class="title">sum</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>args是切片slice，通过args[index]可以访问多个值</p>
<h4 id="2、init函数"><a href="#2、init函数" class="headerlink" title="2、init函数"></a>2、init函数</h4><p>1、<strong>每一个源文件中都可以包含init函数</strong>，该函数会在main函数执行之前，被Go运行框架调用，即init函数在main函数之前被调用。该函数通常用作初始化工作</p>
<p>2、如果一个文件同时包含全局变量定义，init函数和main函数，则执行的流程是：<strong>全局变量定义-&gt;init函数-&gt;main函数</strong></p>
<p>3、如果包含main函数的包里import了其他包，执行流程如下<br><img src="/2020/06/11/go-函数/func9.jpg" alt="func9"></p>
<h4 id="3、匿名函数"><a href="#3、匿名函数" class="headerlink" title="3、匿名函数"></a>3、匿名函数</h4><p>1、如果某个函数我们只是希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用</p>
<p>2、匿名函数的三种使用方式</p>
<ul>
<li>在定义匿名函数时就直接调用，且只能调用一次</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res1 := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1 + n2</span><br><span class="line">     &#125;(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">     <span class="comment">//在定义匿名函数的同时就调用它</span></span><br><span class="line">     </span><br><span class="line">      fmt.Println(<span class="string">"res1="</span>,res1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在紧跟匿名函数定义的后面传入参数调用<br><img src="/2020/06/11/go-函数/func10.png" alt="func10"></p>
<ul>
<li>将匿名函数赋给一个变量（函数变量），再通过该变量来调用匿名函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将匿名函数func(n1 int, n2 int) int 赋值给变量a</span></span><br><span class="line">    <span class="comment">//则a的数据类型就是函数类型，可以通过变量a完成调用</span></span><br><span class="line">    a := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1 + n2</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    res2 := a(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">    res3 := a(<span class="number">90</span>,<span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line">     fmt.Println(<span class="string">"res2="</span>,res2)</span><br><span class="line">     fmt.Println(<span class="string">"res3="</span>,res3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将匿名函数赋给一个全局变量，则这个匿名函数成为一个全局匿名函数，可以在整个程序有效</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    Func1 = <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> n1 + n2</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//这时func1即是一个全局匿名函数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res4 := Func1(<span class="number">4</span>,<span class="number">9</span>)</span><br><span class="line">    fmt.Println(<span class="string">"res4="</span>,res4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h4><p>1、闭包：就是<strong>一个函数</strong>和<strong>与其相关的引用环境</strong>组合的一个整体（实体）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        n = n + x</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f := AddUpper()</span><br><span class="line">    fmt.Println(f(<span class="number">1</span>)) <span class="comment">//输出11</span></span><br><span class="line">    fmt.Println(f(<span class="number">2</span>)) <span class="comment">//输出11+2=13</span></span><br><span class="line">    fmt.Println(f(<span class="number">3</span>)) <span class="comment">//输出13+3=16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对上面代码的说明</p>
<ul>
<li>AddUpper是一个函数，处于外层，返回数据类型时func(int) int</li>
<li><strong>闭包</strong>的说明</li>
</ul>
<p><img src="/2020/06/11/go-函数/func11.png" alt="func11"></p>
<p>在上图红框中可以看到，return返回一个匿名函数，处于内层，这个匿名函数<strong>引用到外层函数的变量n</strong>，因此这个<strong>匿名函数和变量n形成一个整体</strong>，构成<strong>闭包</strong></p>
<ul>
<li><p>可以理解成：闭包是一个类，函数是操作，变量n是字段。函数和它使用到的字段n构成闭包</p>
</li>
<li><p>在main函数中，外层函数AddUpper只被调用一次，所以AddUpper函数中的n只被初始化一次</p>
</li>
<li><p>当我们反复调用内层函数f时，因为外层函数中的变量n只初始化一次，因此每次调用进行累计，而不会重新初始化</p>
</li>
<li><p>闭包的关键，是要分析出返回的内层函数它所引用到的外层函数中的变量，因为函数和它所引用到的变量构成闭包</p>
</li>
</ul>
<h4 id="5、函数中的defer"><a href="#5、函数中的defer" class="headerlink" title="5、函数中的defer"></a>5、函数中的defer</h4><p>1、为什么需要defer<br>    在函数中，经常需要创建资源（如数据库连接、文件句柄、锁等），<strong>为了在函数执行完毕后，及时的释放资源</strong>，Go提供defer（延迟机制）</p>
<p> 2、defer使用案例<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//当执行到defer时，暂时不执行defer后的语句，会将defer后的语句压入独立的栈（这个栈和main函数及sum函数的栈不一样，这里称为defer栈）中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当函数执行完毕后，再从defer栈中，按先入后出顺序出栈执行</span></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n1="</span>,n1)<span class="comment">//3 n1=10</span></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n2="</span>,n2)<span class="comment">//2 n2=20</span></span><br><span class="line">   </span><br><span class="line">   res := n1+n2</span><br><span class="line">   fmt.Println(<span class="string">"n1+n2="</span>,res)<span class="comment">//1 n1+n2=30</span></span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res := sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)<span class="comment">//4 res=30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出顺序：<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n1+n2=<span class="number">30</span></span><br><span class="line">n2=<span class="number">20</span></span><br><span class="line">n1=<span class="number">10</span></span><br><span class="line">res=<span class="number">30</span></span><br></pre></td></tr></table></figure></p>
<p> 3、当执行到defer时，暂时不执行defer后的语句，会将defer后的语句压入独立的栈中，然后执行函数的下一条语句</p>
<p> 4、当函数执行完毕后，再从defer栈中，按先入后出顺序出栈执行</p>
<p> 5、将defer后的语句放入栈时，也会<strong>将相关的值拷贝同时入栈</strong><br>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n1="</span>,n1)<span class="comment">//defer  3 n1=10</span></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n2="</span>,n2)<span class="comment">//defer  2 n2=20</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//增加两条语句</span></span><br><span class="line">  n1++ <span class="comment">//n1=11</span></span><br><span class="line">  n2++ <span class="comment">//n2=21</span></span><br><span class="line">  <span class="comment">//这里n1、n2自增后，并不影响defer栈中的值，因为defer之后的语句入栈时，同时将值拷贝入栈，所以defer中的n1、n2值仍是入栈时候的值</span></span><br><span class="line">  </span><br><span class="line">   res := n1+n2</span><br><span class="line">   fmt.Println(<span class="string">"n1+n2="</span>,res)<span class="comment">//1 n1+n2=32</span></span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res := sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)<span class="comment">//4 res=32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出顺序：<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n1+n2=<span class="number">32</span></span><br><span class="line">n2=<span class="number">20</span></span><br><span class="line">n1=<span class="number">10</span></span><br><span class="line">res=<span class="number">32</span></span><br></pre></td></tr></table></figure></p>
<h4 id="6、函数参数传递的方式"><a href="#6、函数参数传递的方式" class="headerlink" title="6、函数参数传递的方式"></a>6、函数参数传递的方式</h4><p>1、两种传递方式</p>
<ul>
<li><strong>值传递</strong></li>
<li><strong>引用传递</strong></li>
</ul>
<p>不管是值传递还是引用传递，<strong>传递给函数的都是变量的副本</strong>。不同的是：<strong>值传递</strong>传递的是<strong>值的拷贝</strong>，<strong>引用传递</strong>传递的是<strong>地址的拷贝</strong>。</p>
<p>一般来说，地址拷贝效率高，因为数据量小，而值拷贝的效率由传递的数据大小决定，数据越大，效率越低。</p>
<p>2、值类型和引用类型</p>
<ul>
<li>值类型：<strong>基本数据类型（int系列、float系列、bool、string）、数组、结构体</strong></li>
<li>引用类型：<strong>指针、slice切片、map、管道channel、interface</strong>等</li>
</ul>
<h4 id="7、字符串中常用系统函数"><a href="#7、字符串中常用系统函数" class="headerlink" title="7、字符串中常用系统函数"></a>7、字符串中常用系统函数</h4><p>1、统计字符串的长度，按<strong>字节</strong>：<strong>len(str)</strong><br>是一个内置（内建）函数，不属于任何包，可直接使用</p>
<p>2、字符串遍历，同时处理 有中文的问题：<strong>r := []rune(str)</strong><br>遍历字符串时，可先将string类型的字符串str转成rune的切片：[]rune(str)，再进行遍历，因为string类型按字节遍历，[]rune按字符遍历，一个中文占三个字节。（for循环按字节遍历，for … range 按字符遍历）</p>
<p>3、字符串转整数：<strong>n,err := strconv.Atoi(“12”)</strong></p>
<p>4、整数转字符串：<strong>str = strconv.Itoa(12345)</strong></p>
<p>5、字符串转[]byte：<strong>var bytes = []byte(“hello go”)</strong></p>
<p>6、[]byte转字符串：<strong>str = string([]byte{97,98,99})</strong></p>
<p>7、十进制转二进制、八进制、十六进制</p>
<ul>
<li>十进制转二进制:</li>
</ul>
<p><strong>str = strconv.FormatInt(123,2)</strong></p>
<ul>
<li>十进制转八进制:</li>
</ul>
<p>str = strconv.FormatInt(123,<strong>8</strong>)</p>
<ul>
<li>十进制转十六进制:</li>
</ul>
<p>str = strconv.FormatInt(123,<strong>16</strong>)</p>
<p>8、查找子串是否在指定的串中：<strong>strings.Contains(“seafood”,”foo”)</strong>//true</p>
<p>9、统计一个字符串中有几个指定的子串：strings.Count(“ceheese”,”e”)//4</p>
<p>10、不区分大小写的字符串比较（用“==”比较区分大小写）：<strong>strings.EqualFold(“abc”,”Abc”)</strong>//true</p>
<p>11、返回子串在字符串中第一次出现的index值，如果没有返回-1：<strong>strings.Index(“NLT_abc”,”abc”)</strong>//4  下标从0开始索引</p>
<p>12、返回子串在字符串中最后一次出现的index值，如果没有返回-1：<strong>strings.LastIndex(“go go hello”,”go”)</strong>//3  下标从0开始索引</p>
<p>13、将指定的子串替换成另外一个子串：<strong>strings.Replace(“go go hello”,”go”,”go语言”，n)</strong><br>n可以指定你希望替换几个，n=-1表示全部替换</p>
<p>14、按照指定的某个字符为分割标识，将一个字符串拆分成字符串数组：<strong>strings.Split(“hello,world,ok”,”,”)</strong></p>
<p>15、将字符串的字母进行大小写转换：</p>
<p>大写转小写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.ToLower(<span class="string">"Go"</span>)<span class="comment">//go</span></span><br></pre></td></tr></table></figure></p>
<p>小写转大写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.ToUpper(<span class="string">"Go"</span>)<span class="comment">//GO</span></span><br></pre></td></tr></table></figure></p>
<p>16、将字符串的左右两边空格去掉：<strong>strings.TrimSpace(“  go hello    “)</strong></p>
<p>17、将字符串左右两边指定的字符去掉：<strong>strings.Trim(“! hello!”,” !”)</strong><br>//将【hello】左右两边的！和空格去掉</p>
<p>18、将字符串左边指定的字符去掉：<strong>strings.TrimLeft(“! hello!”,” !”)</strong><br>//将【hello】左边的！和空格去掉</p>
<p>19、将字符串右边指定的字符去掉：<strong>strings.TrimRight(“! hello!”,” !”)</strong><br>//将【hello】右边的！和空格去掉</p>
<p>20、判断字符串是否以指定的字符串开头：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.HasPrefix(<span class="string">"ftp://192.168.10.1"</span>,<span class="string">"ftp"</span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>21、判断字符串是否以指定的字符串结束：<strong>strings.HasSuffix(“go_var.jpg”,”jpg”)</strong>//true</p>
<h4 id="8、日期和时间相关函数"><a href="#8、日期和时间相关函数" class="headerlink" title="8、日期和时间相关函数"></a>8、日期和时间相关函数</h4><p>使用时间和日期函数需要引入<strong>time包</strong><br>1、<strong>time.Time</strong>类型，用于表示时间</p>
<p>2、获取当前时间<br><strong>now := time.Now()</strong>//now类型是time.Time</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过变量now获取年月日、时分秒</span><br><span class="line">now.Year()</span><br><span class="line">now.Month()<span class="comment">//英文月份</span></span><br><span class="line"><span class="keyword">int</span>（now.Month()）<span class="comment">//int强转为数字月份</span></span><br><span class="line">now.Day()</span><br><span class="line">now.Hour()</span><br><span class="line">now.Minute()</span><br><span class="line">now.Second()</span><br></pre></td></tr></table></figure>
<p>3、格式化日期</p>
<h5 id="1）方式1使用Printf或者Sprintf"><a href="#1）方式1使用Printf或者Sprintf" class="headerlink" title="1）方式1使用Printf或者Sprintf"></a>1）方式1使用Printf或者Sprintf</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">"当前年月日时分秒 %02d-%02d-%02d %02d-%02d-%02d \n"</span>,now.Year(),now.Month(),now.Day(),now.Hour(),now.Minute(),now.Second())</span><br></pre></td></tr></table></figure>
<p>或者Sprintf，Sprintf会返回一个字符串<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">dateStr := fmt.Sprintf(<span class="string">"当前年月日时分秒 %02d-%02d-%02d %02d-%02d-%02d \n"</span>,now.Year(),now.Month(),now.Day(),now.Hour(),now.Minute(),now.Second())</span><br><span class="line"><span class="comment">//fmt.Sprintf返回一个时间日期字符串赋给变量dateStr，可对变量dateStr进行操作(输出或保存等)</span></span><br><span class="line">fmt.Printf(<span class="string">"dateStr=%v\n"</span>,dateStr)</span><br></pre></td></tr></table></figure></p>
<h5 id="2）方式2使用Format"><a href="#2）方式2使用Format" class="headerlink" title="2）方式2使用Format"></a>2）方式2使用Format</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.printf(now.Format(<span class="string">"2006/01/02 15:04:05"</span>))<span class="comment">//年月日时分秒</span></span><br><span class="line">fmt.printf(now.Format(<span class="string">"2006/01/02))//年月日</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">15</span>:<span class="number">04</span>:<span class="number">05</span><span class="string">"))//时分秒</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">2006</span><span class="string">"))//年</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">01</span><span class="string">"))//月</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">02</span><span class="string">"))//日</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">2006</span><span class="number">-01</span><span class="number">-02</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">05</span><span class="string">"))</span></span><br></pre></td></tr></table></figure>
<p><strong>“2006/01/02 15:04:05”这一串数字是固定的，不能更改</strong>，但格式和组合可以改（传说这串数字是Go开发者脑海中萌生GoLang的时刻）。</p>
<p>4、时间的常量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    Nanosecond Duration = <span class="number">1</span>                             <span class="comment">//纳秒</span></span><br><span class="line">    Microsecond             = <span class="number">1000</span> * Nanosecond     <span class="comment">//微秒</span></span><br><span class="line">    Millisecond                = <span class="number">1000</span> * Microsecond     <span class="comment">//毫秒</span></span><br><span class="line">    Second                     = <span class="number">1000</span> * Millsecond      <span class="comment">//秒</span></span><br><span class="line">    Minute                     = <span class="number">60</span> * Second            <span class="comment">//分钟</span></span><br><span class="line">    Hour                        = <span class="number">60</span> * Minute           <span class="comment">//小时</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>常量的作用：在程序中可用于获取指定时间单位的时间，比如想得到100毫秒 100 * time.Millisecond</p>
<p>可用于休眠<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time.Sleep(time.Second)<span class="comment">//休眠1秒</span></span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">100</span>)<span class="comment">//休眠0.1秒</span></span><br><span class="line"><span class="comment">//只能传入整数，不能传小数</span></span><br><span class="line"><span class="comment">//休眠0.1秒不能这么写time.Sleep(time.Second * 0.1)</span></span><br></pre></td></tr></table></figure></p>
<p>5、时间戳</p>
<ul>
<li><p>unix时间戳<br>返回1970年1月1日0时0分0秒 到当前时间的秒数</p>
</li>
<li><p>unixnano时间戳(unix纳秒时间戳)<br>返回1970年1月1日0时0分0秒 到当前时间的纳秒数</p>
</li>
</ul>
<p>可以用于<strong>获取随机的数字</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了每次生成的随机数不一样，需要设定一个种子seed</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">num := rand.Intn(<span class="number">100</span>)<span class="comment">//0&lt;=n&lt;100</span></span><br><span class="line"><span class="comment">//如果不设置种子，会有一个默认值，但每次随机出来的数都一样</span></span><br></pre></td></tr></table></figure></p>
<h4 id="9、内置（buildin）函数"><a href="#9、内置（buildin）函数" class="headerlink" title="9、内置（buildin）函数"></a>9、内置（buildin）函数</h4><p>1、len()：求长度，比如string、array、slice、map、channel</p>
<p>2、func new<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure></p>
<p>new分配分存，第一个实参为类型而非值，new函数返回值为<strong>指向该类型</strong>的<strong>新分配</strong>的<strong>零值</strong>的<strong>指针</strong>，主要为<strong>值类型</strong>分配内存<br>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num1 := <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"num1的类型%T，num1的值%v，num1的地址%v"</span>，num1，num1，&amp;num1)</span><br><span class="line"><span class="comment">//num1的类型int，num1的值100，num1的地址0xcXXXXXXXX</span></span><br><span class="line"></span><br><span class="line">num2 := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"num2的类型%T，num2的值%v，num2的地址%v，num2指针指向的值"</span>，num2，num2，&amp;num2，*num2)</span><br><span class="line"><span class="comment">//num2的类型*int，</span></span><br><span class="line"><span class="comment">//num2的值0xcXXXXXXXX，num2的地址0xcXXXXXXXX，num2指针指向的值0,（这两个地址在程序运行时，系统动态分配）</span></span><br><span class="line"><span class="comment">//num2的值是一个地址，该地址指向int类型的零值0</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/2020/06/11/go-函数/func12.jpg" alt="func12"></p>
<p>3、make：分配内存，主要用来分配<strong>引用类型</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-函数/" data-id="ckcw0o372000vigvigv2g0lmp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/11/go-错误处理机制、数组、切片、map/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          go:错误处理机制、数组、切片、map
        
      </div>
    </a>
  
  
    <a href="/2020/06/11/go-基本数据类型、运算符/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">go:基本数据类型、运算符</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/21/GO：2-5-使用函数的正确姿势/">GO：2.5 使用函数的正确姿势</a>
          </li>
        
          <li>
            <a href="/2020/07/20/GO：2-4-通道channel/">GO：2.4 通道channel</a>
          </li>
        
          <li>
            <a href="/2020/07/20/GO：2-3-字典的操作和约束/">GO：2.3 字典的操作和约束</a>
          </li>
        
          <li>
            <a href="/2020/07/17/GO：2-2-container包中的容器/">GO：2.2 container包中的容器</a>
          </li>
        
          <li>
            <a href="/2020/07/16/GO：2-1-数组和切片/">GO：2.1 数组和切片</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>