<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java面试知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/java面试知识点/" class="article-date">
  <time datetime="2020-06-07T07:38:06.467Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/java面试知识点/">java面试知识点总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一，java中各种集合的关系图"><a href="#一，java中各种集合的关系图" class="headerlink" title="一，java中各种集合的关系图"></a>一，java中各种集合的关系图</h2><p>1、<br>Collection 接口的接口 对象的集合<br>├ List 子接口 按进入先后有序保存 可重复<br>│├ LinkedList 接口实现类 链表 插入删除 没有同步 线程不安全<br>│├ ArrayList 接口实现类 数组 随机访问 没有同步 线程不安全<br>│└ Vector 接口实现类 数组 同步 线程安全<br>│ 　 └ Stack<br>└ Set 子接口 仅接收一次，并做内部排序</p>
<p>├ HashSet</p>
<p>│ 　 └ LinkedHashSet<br>└ TreeSet</p>
<p>1）对于 List ，关心的是顺序，它保证维护元素特定的顺序（允许有相同元素），使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素。</p>
<p>2）对于 Set ，只关心某元素是否属于 Set （不 允许有相同元素 ），而不关心它的顺序。</p>
<p>2、<br>Map 接口 键值对的集合<br>├ Hashtable 接口实现类 同步 线程安全<br>├ HashMap 接口实现类 没有同步 线程不安全</p>
<p>│├ LinkedHashMap</p>
<p>│└ WeakHashMap</p>
<p>├ TreeMap<br>└ IdentifyHashMap</p>
<p>1）对于 Map ，最大的特点是键值映射，且为一一映射，键不能重复，值可以，所以是用键来索引值。 方法 put(Object key, Object value) 添加一个“值” ( 想要得东西 ) 和与“值”相关联的“键” (key) ( 使用它来查找 ) 。方法 get(Object key) 返回与给定“键”相关联的“值”。</p>
<p>2）Map 同样对每个元素保存一份，但这是基于 ” 键 ” 的， Map 也有内置的排序，因而不关心元素添加的顺序。如果添加元素的顺序对你很重要，应该使用 LinkedHashSet 或者 LinkedHashMap.</p>
<p>3）对于效率， Map 由于采用了哈希散列，查找元素时明显比 ArrayList 快。</p>
<h3 id="简单的总结如下"><a href="#简单的总结如下" class="headerlink" title="简单的总结如下"></a>简单的总结如下</h3><p>1、Collection 是对象集合， Collection 有两个子接口 List 和 Set,List 可以通过下标 (1,2..) 来取得值，值可以重复,而 Set 只能通过游标来取值，并且值是不能重复的</p>
<p>1）ArrayList ， Vector ， LinkedList 是 List 的实现类</p>
<p>2）ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的</p>
<p>3）LinkedList 是线程不安全的，底层是由链表实现的</p>
<p>2、Map 是键值对集合</p>
<p>HashTable 和 HashMap 是 Map 的实现类<br>HashTable 是线程安全的，不能存储 null 值<br>HashMap 不是线程安全的，可以存储 null 值</p>
<h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><p>1 ， List 接口<br>　　 1）List 是有序的 Collection ，次序是 List 最重要的特点：它保证维护元素特定的顺序。使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，这类似于 Java 的数组。和下面要提到的 Set 不同， List 允许有相同的元素。<br>　 　除了具有 Collection 接口必备的 iterator() 方法外， List 还提供一个 listIterator() 方法，返回一个 ListIterator 接口，和标准的 Iterator 接口相比， ListIterator 多了一些 add() 之类的方法，允许添加，删除，设定元素， 还能向前或向后遍历。<br>　　实现 List 接口的常用类有 LinkedList ， ArrayList ， Vector 和 Stack 。其中，最常用的是 LinkedList 和 ArrayList 两个。<br>LinkedList 类<br>　 　2） LinkedList 实现了 List 接口，允许 null 元素。此外 LinkedList 提供额外的 addFirst(), addLast(), getFirst(), getLast(), removeFirst(), removeLast(), insertFirst(), insertLast() 方法在 LinkedList 的首部或尾部，这些方法（没有在任何接口或基类中定义过）使 LinkedList 可被用作堆栈（ stack ），队列（ queue ）或双向队列（ deque ）。</p>
<p>注意 LinkedList 没有同步方法。如果多个线程同时访问一个 List ，则必须自己实现访问同步。一种解决方法是在创建 List 时构造一个同步的 List ：<br>　　　　 List list = Collections.synchronizedList(new LinkedList(…));</p>
<p>特点：对顺序访问进行了优化，向 List 中间插入与删除的开销并不大。随机访问则相对较慢。 ( 使用 ArrayList 代替。 )</p>
<p>3）ArrayList 类<br>　　 ArrayList 是由数组实现的 List ，并且实现了可变大小的数组。它允许所有元素，包括 null 。 ArrayList 没有同步。 size ， isEmpty ， get ， set 方法运行时间为常数。但是 add 方法开销为分摊的常数，添加 n 个元素需要 O(n) 的时间。其他的方法运行时间为线性。<br>　 　每个 ArrayList 实例都有一个容量（ Capacity ），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用 ensureCapacity 方法来增加 ArrayList 的容量以提高插入效率。<br>　　和 LinkedList 一样， ArrayList 也是非同步的（ unsynchronized ）。</p>
<p>特点：允许对元素进行快速随机访问，但是向 List 中间插入与移除元素的速度很慢。 ListIterator 只应该用来由后向前遍历 ArrayList, 而不是用来插入和移除元素。因为那比 LinkedList 开销要大很多。</p>
<p>4）Vector 类<br>　 　 Vector 非常类似 ArrayList ，但是 Vector 是同步的。由 Vector 创建的 Iterator ，虽然和 ArrayList 创建的 Iterator 是同一接口，但是，因为 Vector 是同步的，当一个 Iterator 被创建而且正在被使用，另一个线程改变了 Vector 的状态（例如，添加或删除了一些元素），这时调用 Iterator 的方法时将抛出 ConcurrentModificationException ，因此必须捕获该异常。</p>
<p> Stack 类： Stack 继承自 Vector ，实现一个后进先出的堆栈。 Stack 提供 5 个额外的方法使得 Vector 得以被当作堆栈使用。基本的 push 和 pop 方法，还有 peek 方法得到栈顶的元素， empty 方法测试堆栈是否为空， search 方法检测一个元素在堆栈中的位置。 Stack 刚创建后是空栈。 </p>
<p>2 ， Set 接口<br>　　 1）Set 具有与 Collection 完全一样的接口，因此没有任何额外的功能，不像前面有几个不同的 List 。实际上 Set 就是 Collection ，只是行为不同。（这是继承与多态思想的典型应用：表现不同的行为）。其次， Set 是一种不包含重复的元素的 Collection ，加入 Set 的元素必须定义 equals() 方法以确保对象的唯一性 （ 即任意的两个元素 e1 和 e2 都有 e1.equals(e2)=false ），与 List 不同的是， Set 接口不保证维护元素的次序。最后， Set 最多有一个 null 元素。<br>　　很明显， Set 的构造函数有一个约束条件，传入的 Collection 参数不能包含重复的元素。<br>　　请注意：必须小心操作可变对象（ Mutable Object ）。如果一个 Set 中的可变元素改变了自身状态导致 Object.equals(Object)=true 将导致一些问题。</p>
<p>2）HashSet 类</p>
<p>为快速查找设计的 Set 。存入 HashSet 的对象必须定义 hashCode() 。</p>
<p>3）LinkedHashSet 类：具有 HashSet 的查询速度，且内部使用链表维护元素的顺序 ( 插入的次序 ) 。于是在使用迭代器遍历 Set 时，结果会按元素插入的次序显示。</p>
<p>4）TreeSet 类</p>
<p>保存次序的 Set, 底层为树结构。使用它可以从 Set 中提取有序的序列。</p>
<p>3、 Map 接口<br>　 　请注意， Map 没有继承 Collection 接口， Map 提供 key 到 value 的映射，你可以通过“键”查找“值”。一个 Map 中不能包含相同的 key ，每个 key 只能映射一个 value 。 Map 接口提供 3 种集合的视图， Map 的内容可以被当作一组 key 集合，一组 value 集合，或者一组 key-value 映射。<br>方法 put(Object key, Object value) 添加一个“值” ( 想要得东西 ) 和与“值”相关联的“键” (key) ( 使用它来查找 ) 。方法 get(Object key) 返回与给定“键”相关联的“值”。可以用 containsKey() 和 containsValue() 测试 Map 中是否包含某个“键”或“值”。 标准的 Java 类库中包含了几种不同的 Map ： HashMap, TreeMap, LinkedHashMap, WeakHashMap, IdentityHashMap 。它们都有同样的基本接口 Map ，但是行为、效率、排序策略、保存对象的生命周期和判定“键”等价的策略等各不相同。</p>
<p>Map 同样对每个元素保存一份，但这是基于 ” 键 ” 的， Map 也有内置的排序，因而不关心元素添加的顺序。如果添加元素的顺序对你很重要，应该使用 LinkedHashSet 或者 LinkedHashMap.</p>
<p>执行效率是 Map 的一个大问题。看看 get() 要做哪些事，就会明白为什么在 ArrayList 中搜索“键”是相当慢的。而这正是 HashMap 提高速度的地方。 HashMap 使用了特殊的值，称为“散列码” (hash code) ，来取代对键的缓慢搜索。“散列码”是“相对唯一”用以代表对象的 int 值，它是通过将该对象的某些信息进行转换而生成的（在下面总结二：需要的注意的地方有更进一步探讨）。所有 Java 对象都能产生散列码，因为 hashCode() 是定义在基类 Object 中的方法 。 HashMap 就是使用对象的 hashCode() 进行快速查询的。此方法能够显著提高性能。</p>
<p>1）Hashtable 类<br>　　 Hashtable 继承 Map 接口，实现一个 key-value 映射的哈希表。任何非空（ non-null ）的对象都可作为 key 或者 value 。　　添加数据使用 put(key, value) ，取出数据使用 get(key) ，这两个基本操作的时间开销为常数。<br>Hashtable 通过初始化容量 (initial capacity) 和负载因子 (load factor) 两个参数调整性能。通常缺省的 load factor 0.75 较好地实现了时间和空间的均衡。增大 load factor 可以节省空间但相应的查找时间将增大，这会影响像 get 和 put 这样的操作。<br>使用 Hashtable 的简单示例如下，将 1 ， 2 ， 3 放到 Hashtable 中，他们的 key 分别是 ”one” ， ”two” ， ”three” ：<br>　　　　 Hashtable numbers = new Hashtable();<br>　　　　 numbers.put(“one”, new Integer(1));<br>　　　　 numbers.put(“two”, new Integer(2));<br>　　　　 numbers.put(“three”, new Integer(3));<br>　　要取出一个数，比如 2 ，用相应的 key ：<br>　　　　 Integer n = (Integer)numbers.get(“two”);<br>　　　　 System.out.println(“two = ” + n);<br>　 　由于作为 key 的对象将通过计算其散列函数来确定与之对应的 value 的位置，因此任何作为 key 的对象都必须实现 hashCode 方法和 equals 方法。 hashCode 方法和 equals 方法继承自根类 Object ，如果你用自定义的类当作 key 的话，要相当小心，按照散列函数的定义，如果两个对象相同，即 obj1.equals(obj2)=true ，则它们的 hashCode 必须相同，但如果两个对象不同，则它们的 hashCode 不一定不同，如果两个不同对象的 hashCode 相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的 hashCode() 方法，能加快哈希表的操作。<br>　　如果相同的对象有不同的 hashCode ，对哈希表的操作会出现意想不到的结果（期待的 get 方法返回 null ），要避免这种问题，只需要牢记一条：要同时复写 equals 方法和 hashCode 方法，而不要只写其中一个。<br>　　 Hashtable 是同步的。</p>
<p>2）HashMap 类<br>　 　 HashMap 和 Hashtable 类似，也是基于散列表的实现。不同之处在于 HashMap 是非同步的，并且允许 null ，即 null value 和 null key 。将 HashMap 视为 Collection 时（ values() 方法可返回 Collection ），插入和查询“键值对”的开销是固定的，但其迭代子操作时间开销和 HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将 HashMap 的初始化容量 (initial capacity) 设得过高，或者负载因子 (load factor) 过低。</p>
<p>　　3） LinkedHashMap 类：类似于 HashMap ，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用 (LRU) 的次序。只比 HashMap 慢一点。而在迭代访问时发而更快，因为它使用链表维护内部次序。</p>
<p>4）WeakHashMap 类：弱键（ weak key ） Map 是一种改进的 HashMap ，它是为解决特殊问题设计的，对 key 实行 “ 弱引用 ” ，如果一个 key 不再被外部所引用（没有 map 之外的引用），那么该 key 可以被垃圾收集器 (GC) 回收。</p>
<p>5）TreeMap 类</p>
<p>基于红黑树数据结构的实现。查看“键”或“键值对”时，它们会被排序 ( 次序由 Comparabel 或 Comparator 决定 ) 。 TreeMap 的特点在于，你得到的结果是经过排序的。 TreeMap 是唯一的带有 subMap() 方法的 Map ，它可以返回一个子树。</p>
<p>5）IdentifyHashMap 类</p>
<p>使用 == 代替 equals() 对“键”作比较的 hash map 。专为解决特殊问题而设计。</p>
<p>总结一：比较</p>
<p>1 ，数组 (Array) ，数组类 (Arrays)</p>
<p>Java 所有“存储及随机访问一连串对象”的做法， array 是最有效率的一种。但缺点是容量固定且无法动态改变。 array 还有一个缺点是，无法判断其中实际存有多少元素， length 只是告诉我们 array 的容量。</p>
<p>Java 中有一个数组类 (Arrays) ，专门用来操作 array 。数组类 (arrays) 中拥有一组 static 函数。</p>
<p>equals() ：比较两个 array 是否相等。 array 拥有相同元素个数，且所有对应元素两两相等。</p>
<p>fill() ：将值填入 array 中。</p>
<p>sort() ：用来对 array 进行排序。</p>
<p>binarySearch() ：在排好序的 array 中寻找元素。</p>
<p>System.arraycopy() ： array 的复制。</p>
<p>若编写程序时不知道究竟需要多少对象，需要在空间不足时自动扩增容量，则需要使用容器类库， array 不适用。</p>
<p>2 ，容器类与数组的区别</p>
<p>容器类仅能持有对象引用（指向对象的指针），而不是将对象信息 copy 一份至数列某位置。一旦将对象置入容器内，便损失了该对象的型别信息。</p>
<p>3 ，容器 (Collection) 与 Map 的联系与区别</p>
<p>Collection 类型，每个位置只有一个元素。</p>
<p>Map 类型，持有 key-value 对 (pair) ，像个小型数据库。</p>
<p>Collections 是针对集合类的一个帮助类。提供了一系列静态方法实现对各种集合的搜索、排序、线程完全化等操作。相当于对 Array 进行类似操作的类—— Arrays 。</p>
<p>如， Collections.max(Collection coll); 取 coll 中最大的元素。</p>
<p>Collections.sort(List list); 对 list 中元素排序<br>1<br>List ， Set ， Map 将持有对象一律视为 Object 型别。</p>
<p>Collection 、 List 、 Set 、 Map 都是接口，不能实例化。继承自它们的 ArrayList, Vector, HashTable, HashMap 是具象 class ，这些才可被实例化。</p>
<p>vector 容器确切知道它所持有的对象隶属什么型别。 vector 不进行边界检查。</p>
<p>总结二：需要注意的地方</p>
<p>1 、 Collection 只能通过 iterator() 遍历元素，没有 get() 方法来取得某个元素。</p>
<p>2 、 Set 和 Collection 拥有一模一样的接口。但排除掉传入的 Collection 参数重复的元素。</p>
<p>3 、 List ，可以通过 get() 方法来一次取出一个元素。使用数字来选择一堆对象中的一个， get(0)… 。 (add/get)</p>
<p>4 、 Map 用 put(k,v) / get(k) ，还可以使用 containsKey()/containsValue() 来检查其中是否含有某个 key/value 。</p>
<p>HashMap 会利用对象的 hashCode 来快速找到 key 。</p>
<p>哈希码 (hashing) 就是将对象的信息经过一些转变形成一个独一无二的 int 值，这个值存储在一个 array 中。我们都知道所有存储结构中， array 查找速度是最快的。所以，可以加速查找。发生碰撞时，让 array 指向多个 values 。即，数组每个位置上又生成一个梿表。</p>
<p>5 、 Map 中元素，可以将 key 序列、 value 序列单独抽取出来。</p>
<p>使用 keySet() 抽取 key 序列，将 map 中的所有 keys 生成一个 Set 。</p>
<p>使用 values() 抽取 value 序列，将 map 中的所有 values 生成一个 Collection 。</p>
<p>为什么一个生成 Set ，一个生成 Collection ？那是因为， key 总是独一无二的， value 允许重复。</p>
<p>总结三：如何选择</p>
<p>从效率角度：</p>
<p>在各种 Lists ，对于需要快速插入，删除元素，应该使用 LinkedList （可用 LinkedList 构造堆栈 stack 、队列 queue ），如果需要快速随机访问元素，应该使用 ArrayList 。最好的做法是以 ArrayList 作为缺省选择。 Vector 总是比 ArrayList 慢，所以要尽量避免使用。</p>
<p>在各种 Sets 中， HashSet 通常优于 HashTree （插入、查找）。只有当需要产生一个经过排序的序列，才用 TreeSet 。 HashTree 存在的唯一理由：能够维护其内元素的排序状态。</p>
<p>在各种 Maps 中 HashMap 用于快速查找。</p>
<p>最后，当元素个数固定，用 Array ，因为 Array 效率是最高的。</p>
<p>所以结论：最常用的是 ArrayList ， HashSet ， HashMap ， Array 。</p>
<p>更近一步分析：</p>
<p>如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。<br>要特别注意对哈希表的操作，作为 key 的对象要同时正确复写 equals 方法和 hashCode 方法。<br>尽量返回接口而非实际的类型，如返回 List 而非 ArrayList ，这样如果以后需要将 ArrayList 换成 LinkedList 时，客户端代码不用改变。这就是针对抽象编程。以上都是基础且非常重要,希望大家掌握。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>1、概述：<br>1）JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；<br>2）对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>2、反射的原理：<br>1）首先把Java文件保存到本地硬盘<br>2）编译Java文件成.class文件<br>3）用jvm把class文件加载到内存中，使用Class类来表示（一切皆对象）<br>4）当使用反射时，首先需要获取到class类，获取到class之后，就可以得到class文件中的所有内容，包括属性、构造方法、普通方法<br>5）属性通过Filed类表示<br>6）构造方法通过Constructor表示<br>7）普通方法通过Method表示</p>
<p>3、使用反射操作类里卖弄的属性<br>1）首先获取到class<br>三种方式：<br>（1）类名.class<br>（2）对象.class<br>（3）Class.forName(“全类名”)</p>
<p>2）对一个类实例化<br>（1）new()<br>（2）Class clazz=Class.forName(“com.Person”);Person p=clazz.newInstance();</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/java面试知识点/" data-id="ckb6cdhn7000p6svifksg1nxe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java集合总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/Java集合总结/" class="article-date">
  <time datetime="2020-06-07T07:38:06.452Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/Java集合总结/">Java集合总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>List<br>ArrayList</p>
<p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。<br>按数组下标访问元素–get(i)/set(i,e) 的性能很高，这是数组的基本优势。<br>直接在数组末尾加入元素–add(e)的性能也高，但如果按下标插入、删除元素–add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p>
<p>LinkedList</p>
<p>以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。<br>按下标访问元素–get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。<br>插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作–add(), addFirst(),removeLast()或用iterator()上的remove()能省掉指针的移动。</p>
<p>CopyOnWriteArrayList</p>
<p>并发优化的ArrayList。用CopyOnWrite策略，在修改时先复制一个快照来修改，改完再让内部指针指向新数组。<br>因为对快照的修改对读操作来说不可见，所以只有写锁没有读锁，加上复制的昂贵成本，典型的适合读多写少的场景。如果更新频率较高，或数组较大时，还是Collections.synchronizedList(list)，对所有操作用同一把锁来保证线程安全更好。<br>增加了addIfAbsent(e)方法，会遍历数组来检查元素是否已存在，性能可想像的不会太好。</p>
<p>补充</p>
<p>无论哪种实现，按值返回下标–contains(e), indexOf(e), remove(e) 都需遍历所有元素进行比较，性能可想像的不会太好。<br>没有按元素值排序的SortedList，在线程安全类中也没有无锁算法的ConcurrentLinkedList，凑合着用Set与Queue中的等价类时，会缺少一些List特有的方法。<br>Map<br>HashMap</p>
<p>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。</p>
<p>插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。</p>
<p>查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。</p>
<p>当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。</p>
<p>取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。</p>
<p>iterator()时顺着哈希桶数组来遍历，看起来是个乱序。</p>
<p>在JDK8里，新增默认为8的閥值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找速度。</p>
<p>LinkedHashMap</p>
<p>扩展HashMap增加双向链表的实现，号称是最占内存的数据结构。支持iterator()时按Entry的插入顺序来排序(但是更新不算， 如果设置accessOrder属性为true，则所有读写访问都算)。</p>
<p>实现上是在Entry上再增加属性before/after指针，插入时把自己加到Header Entry的前面去。如果所有读写访问都要排序，还要把前后Entry的before/after拼接起来以在链表中删除掉自己。</p>
<p>TreeMap</p>
<p>以红黑树实现，篇幅所限详见入门教程。支持iterator()时按Key值排序，可按实现了Comparable接口的Key的升序排序，或由传入的Comparator控制。可想象的，在树上插入/删除元素的代价一定比HashMap的大。</p>
<p>支持SortedMap接口，如firstKey()，lastKey()取得最大最小的key，或sub(fromKey, toKey), tailMap(fromKey)剪取Map的某一段。</p>
<p>ConcurrentHashMap</p>
<p>并发优化的HashMap，默认16把写锁(可以设置更多)，有效分散了阻塞的概率，而且没有读锁。</p>
<p>数据结构为Segment[]，Segment里面才是哈希桶数组，每个Segment一把锁。Key先算出它在哪个Segment里，再算出它在哪个哈希桶里。</p>
<p>支持ConcurrentMap接口，如putIfAbsent(key，value)与相反的replace(key，value)与以及实现CAS的replace(key, oldValue, newValue)。</p>
<p>没有读锁是因为put/remove动作是个原子动作(比如put是一个对数组元素/Entry 指针的赋值操作)，读操作不会看到一个更新动作的中间状态。</p>
<p>ConcurrentSkipListMap</p>
<p>JDK6新增的并发优化的SortedMap，以SkipList实现。SkipList是红黑树的一种简化替代方案，是个流行的有序集合算法，篇幅所限见入门教程。Concurrent包选用它是因为它支持基于CAS的无锁算法，而红黑树则没有好的无锁算法。<br>很特殊的，它的size()不能随便调，会遍历来统计。</p>
<p>补充</p>
<p>关于null，HashMap和LinkedHashMap是随意的，TreeMap没有设置Comparator时key不能为null；ConcurrentHashMap在JDK7里value不能为null(这是为什么呢？)，JDK8里key与value都不能为null；ConcurrentSkipListMap是所有JDK里key与value都不能为null。<br>Set<br>Set几乎都是内部用一个Map来实现, 因为Map里的KeySet就是一个Set，而value是假值，全部使用同一个Object。Set的特征也继承了那些内部Map实现的特征。<br>HashSet：内部是HashMap。<br>LinkedHashSet：内部是LinkedHashMap。<br>TreeSet：内部是TreeMap的SortedSet。<br>ConcurrentSkipListSet：内部是ConcurrentSkipListMap的并发优化的SortedSet。<br>CopyOnWriteArraySet：内部是CopyOnWriteArrayList的并发优化的Set，利用其addIfAbsent()方法实现元素去重，如前所述该方法的性能很一般。</p>
<p>补充：好像少了个ConcurrentHashSet，本来也该有一个内部用ConcurrentHashMap的简单实现，但JDK偏偏没提供。Jetty就自己封了一个，Guava则直接用java.util.Collections.newSetFromMap(new ConcurrentHashMap()) 实现。<br>Queue<br>Queue是在两端出入的List，所以也可以用数组或链表来实现。</p>
<p>–普通队列–</p>
<p>LinkedList</p>
<p>是的，以双向链表实现的LinkedList既是List，也是Queue。它是唯一一个允许放入null的Queue。</p>
<p>ArrayDeque</p>
<p>以循环数组实现的双向Queue。大小是2的倍数，默认是16。</p>
<p>普通数组只能快速在末尾添加元素，为了支持FIFO，从数组头快速取出元素，就需要使用循环数组：有队头队尾两个下标：弹出元素时，队头下标递增；加入元素时，如果已到数组空间的末尾，则将元素循环赋值到数组<a href="如果此时队头下标大于0，说明队头弹出过元素，有空位">0</a>，同时队尾下标指向0，再插入下一个元素则赋值到数组[1]，队尾下标指向1。如果队尾的下标追上队头，说明数组所有空间已用完，进行双倍的数组扩容。</p>
<p>PriorityQueue</p>
<p>用二叉堆实现的优先级队列，详见入门教程，不再是FIFO而是按元素实现的Comparable接口或传入Comparator的比较结果来出队，数值越小，优先级越高，越先出队。但是注意其iterator()的返回不会排序。</p>
<p>–线程安全的队列–</p>
<p>ConcurrentLinkedQueue/ConcurrentLinkedDeque</p>
<p>无界的并发优化的Queue，基于链表，实现了依赖于CAS的无锁算法。</p>
<p>ConcurrentLinkedQueue的结构是单向链表和head/tail两个指针，因为入队时需要修改队尾元素的next指针，以及修改tail指向新入队的元素两个CAS动作无法原子，所以需要的特殊的算法，篇幅所限见入门教程。</p>
<p>PriorityBlockingQueue</p>
<p>无界的并发优化的PriorityQueue，也是基于二叉堆。使用一把公共的读写锁。虽然实现了BlockingQueue接口，其实没有任何阻塞队列的特征，空间不够时会自动扩容。</p>
<p>DelayQueue</p>
<p>内部包含一个PriorityQueue，同样是无界的。元素需实现Delayed接口，每次调用时需返回当前离触发时间还有多久，小于0表示该触发了。</p>
<p>pull()时会用peek()查看队头的元素，检查是否到达触发时间。ScheduledThreadPoolExecutor用了类似的结构。</p>
<p>–线程安全的阻塞队列–</p>
<p>BlockingQueue的队列长度受限，用以保证生产者与消费者的速度不会相差太远，避免内存耗尽。队列长度设定后不可改变。当入队时队列已满，或出队时队列已空，不同函数的效果见下表：</p>
<p>ArrayBlockingQueue</p>
<p>定长的并发优化的BlockingQueue，基于循环数组实现。有一把公共的读写锁与notFull、notEmpty两个Condition管理队列满或空时的阻塞状态。</p>
<p>LinkedBlockingQueue/LinkedBlockingDeque</p>
<p>可选定长的并发优化的BlockingQueue，基于链表实现，所以可以把长度设为Integer.MAX_VALUE。利用链表的特征，分离了takeLock与putLock两把锁，继续用notEmpty、notFull管理队列满或空时的阻塞状态。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/Java集合总结/" data-id="ckb6cdhml00056svi2b4xgb7o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java-对象导论" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/Java-对象导论/" class="article-date">
  <time datetime="2020-06-07T07:38:06.420Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/Java-对象导论/">Thinking in Java - 对象导论</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、抽象过程<br>1）万物皆为对象<br>2）程序是对象的集合，他们通过发送消息来告知彼此所要做的<br>要想请求一个对象，就必须对该对象发送一条消息，可以把消息想象为对某个特定对象的方法的调用请求<br>3）每个对象都有自己的由其他对象所构成的存储<br>4）每个对象都拥有其类型<br>5）某一特定类型的所有对象都可以接受同样的消息</p>
<p>对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（状态）和方法（行为），都可以唯一的与其他对象区分开来，即每一个对象在内存中都有一个唯一的地址。</p>
<p>2、每个对象都有一个接口<br>1）关键字class的由来:在程序执行期间具有不同状态而其它方面都相似的对象会被分组到对象的类中<br>2）一个类实际上就是一个数据类型，因为类描述具有相同特性（数据元素)和行为（功能）的对象集合<br>3）class，是Java编程语言中的基本单位</p>
<p>3、每个对象都提供服务<br>1）将对象想像为“服务提供者”，有助于提供对象的内聚性</p>
<p>4、被隐藏的具体实现（访问权限）<br>1）public：任何人可用<br>2）private：除类创建者和类的内部方法之外的任何人都不能访问<br>3）protected：类创建者和类的内部方法能访问，继承的类也能访问protected成员，不能访问private成员<br>4）包访问权限：默认的访问权限，类可以访问同一个包（库构件）中的其他类成员，对于包之外，该包内的成员相当于被private所修饰</p>
<p>5、复用的具体实现<br>1）最简单的复用某个类：直接使用该类的对象<br>2）组合：将该类的对象置于某个新的类中，新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。</p>
<p>6、继承（是is-a的关系)<br>1）当父类发生变动时，子类也会反映出这种变动<br>2）类不仅仅只是描述作用于一个对象集合上的约束条件，还有与其他类之间的关系。两个类可以有相同的特性和行为，但其中一个类可能比另一个含有更多的特性，并且可以处理更多的消息，继承使用父类和子类的概念表示了这种类之间的相似性。<br>3）一个父类包含其所有子类所共享的特性和行为。<br>4）继承现有类时，也就创造了新的类。新的类包括现有类的所有成员（包括不可访问的private成员），并且复制了父类的接口，即所有可以发送给父类对象的消息同时也可以发送个子类的对象。<br>5）由于通过发送给类的消息的类型可知类的类型，则这意味着父类与基类具有相同的类型</p>
<p>6.1 使父类与子类产生差异的方法<br>1）直接在子类中添加新方法，父类不能访问这个新方法，是一种is-like-a的关系<br>2）覆盖</p>
<p>7、伴随多态的可互换对象<br>1）处理类型的层次结构时，经常想把一个对象不当作它所属的特定类型来看待，而是当作其父类来看待。<br>2）这使得可以编写出不依赖于特定类型的代码，这样的代码不会受新添加的类型的影响<br>3）前期绑定：非面向对象编程的编译器产生的函数调用会引起前期绑定，编译器将产生对一个具体函数名字的调用，运行时将这个调用解析到将要被执行的代码的绝对地址。<br>4）后期绑定：在OOP中，程序直到运行时才能确定代码的地址。当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查，但是不知道将被执行的确切代码。<br>5）为了后期绑定，Java用一小段特殊代码来替代绝对地址调用，这段代码使用在对象中存储的信息来计算方法体的地址。根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。<br>5）在Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态。</p>
<p>8、单根继承结构<br>1）Java中所有的类最终都继承自单一的类：Object<br>2）单根继承使垃圾回收器的实现变得容易很多。<br>3）所有的对象都可以很容易在堆上创建，参数传递也得到极大简化<br>4）所有的对象都保证具有其类型信息，因而不会因无法确定对象的类型而陷入僵局，这对于系统级操作（如异常处理）尤其重要，并且给编程带来更大的灵活性。</p>
<p>9、容器<br>1）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/Java-对象导论/" data-id="ckb6cdhmh00036svihglf22va" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-StringBuffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/java-StringBuffer/" class="article-date">
  <time datetime="2020-06-07T07:38:06.405Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/java-StringBuffer/">java-String，StringBuilder，StringBuffer三者的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java中的String，StringBuilder，StringBuffer三者的区别<br>　　最近在学习Java的时候，遇到了这样一个问题，就是String,StringBuilder以及StringBuffer这三个类之间有什么区别呢，自己从网上搜索了一些资料，有所了解了之后在这里整理一下，便于大家观看，也便于加深自己学习过程中对这些知识点的记忆，如果哪里有误，恳请指正。</p>
<p>　　这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。</p>
<p>首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String<br>　　String最慢的原因：</p>
<p>　　String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。以下面一段代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> String str=<span class="string">"abc"</span>;</span><br><span class="line"><span class="number">2</span> System.out.println(str);</span><br><span class="line"><span class="number">3</span> str=str+<span class="string">"de"</span>;</span><br><span class="line"><span class="number">4</span> System.out.println(str);</span><br></pre></td></tr></table></figure>
<p>　　如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</p>
<p>　　而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</p>
<p>　　另外，有时候我们会这样对字符串进行赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> String str=<span class="string">"abc"</span>+<span class="string">"de"</span>;</span><br><span class="line"><span class="number">2</span> StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder().append(<span class="string">"abc"</span>).append(<span class="string">"de"</span>);</span><br><span class="line"><span class="number">3</span> System.out.println(str);</span><br><span class="line"><span class="number">4</span> System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>
<p>　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和</p>
<p>　　String str=”abcde”;</p>
<p>　　是完全一样的，所以会很快，而如果写成下面这种形式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> String str1=<span class="string">"abc"</span>;</span><br><span class="line"><span class="number">2</span> String str2=<span class="string">"de"</span>;</span><br><span class="line"><span class="number">3</span> String str=str1+str2;</span><br></pre></td></tr></table></figure></p>
<p>　　那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p>
<p>　　2. 再来说线程安全</p>
<p>　　在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</p>
<p>　　如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p>
<p>　　3. 总结一下<br>　　String：适用于少量的字符串操作的情况</p>
<p>　　StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p>
<p>　　StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/java-StringBuffer/" data-id="ckb6cdhn5000n6svi9nof31xa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/hello-world/" class="article-date">
  <time datetime="2020-06-07T07:38:06.387Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/hello-world/" data-id="ckb6cdhn3000m6svilj8iyg5d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-javaNote" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/07/javaNote/" class="article-date">
  <time datetime="2019-03-07T10:31:48.000Z" itemprop="datePublished">2019-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/07/javaNote/">java小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h4 id="1-Java值类型与引用类型"><a href="#1-Java值类型与引用类型" class="headerlink" title="1. Java值类型与引用类型"></a>1. Java值类型与引用类型</h4><p><img src="https://raw.githubusercontent.com/tingzi123/blog/master/_posts/picture/javavalue.png" alt="Image text"></p>
<h4 id="2-Java运算符优先级"><a href="#2-Java运算符优先级" class="headerlink" title="2. Java运算符优先级"></a>2. Java运算符优先级</h4><p><img src="https://raw.githubusercontent.com/tingzi123/blog/master/_posts/picture/operator.jpg" alt="Image text"></p>
<h4 id="3-Java中代码块加载顺序：静态初始代码块-gt-初始代码块-gt-构造函数"><a href="#3-Java中代码块加载顺序：静态初始代码块-gt-初始代码块-gt-构造函数" class="headerlink" title="3. Java中代码块加载顺序：静态初始代码块&gt;初始代码块&gt;构造函数"></a>3. Java中代码块加载顺序：静态初始代码块&gt;初始代码块&gt;构造函数</h4><p>例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">new</span> Main();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上程序输出的结果，正确的是？</span><br><span class="line">DACBCB</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/07/javaNote/" data-id="ckb6cdhn6000o6svipbyn5yhw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/08/ct20200608/">ct20200608</a>
          </li>
        
          <li>
            <a href="/2020/06/07/test2020/">2020年test</a>
          </li>
        
          <li>
            <a href="/2020/06/07/链队列/">链队列</a>
          </li>
        
          <li>
            <a href="/2020/06/07/链栈/">链栈</a>
          </li>
        
          <li>
            <a href="/2020/06/07/选择排序/">选择排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>