<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-GO：1-3-库源码文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/12/GO：1-3-库源码文件/" class="article-date">
  <time datetime="2020-07-12T08:01:56.000Z" itemprop="datePublished">2020-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/12/GO：1-3-库源码文件/">GO：1.3 库源码文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、什么是库源码文件？"><a href="#1、什么是库源码文件？" class="headerlink" title="1、什么是库源码文件？"></a>1、什么是库源码文件？</h3><p>1、<strong>库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体</strong>，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）。</p>
<p>2、这里的“其他代码”可以与被使用的程序实体在同一个源码文件内，也可以在其他源码文件，甚至其他代码包中。</p>
<p>3、程序实体是什么？<br>在 Go 语言中，<strong>程序实体是变量、常量、函数、结构体和接口的统称</strong>。</p>
<ul>
<li>我们总是会先声明（或者说定义）程序实体，然后再去使用。</li>
<li>程序实体的名字被统称为标识符。标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。</li>
<li>从规则上说，我们可以用中文作为变量的名字。但是不建议这样做。</li>
</ul>
<h3 id="2、怎样把命令源码文件中的代码拆分到其他库源码文件？"><a href="#2、怎样把命令源码文件中的代码拆分到其他库源码文件？" class="headerlink" title="2、怎样把命令源码文件中的代码拆分到其他库源码文件？"></a>2、怎样把命令源码文件中的代码拆分到其他库源码文件？</h3><p>如果在某个目录下有一个命令源码文件 demo4.go，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  hello(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>demo4.go 在调用了hello函数，函数hello被声明在了另外一个源码文件中，我把它命名为 demo4_lib.go，并且放在与 demo4.go 相同的目录main下（在同一个目录下的源码文件都需要被声明为属于同一个代码包。）。如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：如果该目录下有一个命令源码文件，那么为了让同在一个目录下的文件都通过编译，其他源码文件应该也声明属于main包。</p>
<p>现在运行它们，比如，我们可以在这些文件所在的目录下运行如下命令并得到相应的结果。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run demo4.<span class="keyword">go</span> demo4_lib.<span class="keyword">go</span> </span><br><span class="line">Hello, everyone!</span><br></pre></td></tr></table></figure></p>
<p>或者，像下面这样先构建当前的代码包再运行。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build puzzlers/article3/q1</span><br><span class="line">$ ./q1            </span><br><span class="line">Hello, everyone!</span><br></pre></td></tr></table></figure></p>
<p>1、在这里，我把 demo4.go 和 demo4_lib.go 都放在了一个相对路径为puzzlers/article3/q1的目录中。</p>
<p>2、在默认情况下，相应的代码包的导入路径会与此一致。我们可以通过代码包的导入路径引用其中声明的程序实体。但是，这里的情况是不同的。</p>
<p>3、注意，demo4.go 和 demo4_lib.go 都声明自己属于main包。我在前面讲 Go 语言源码的组织方式的时候提到过这种用法，即：源码文件声明的包名可以与其所在目录的名称不同，只要这些文件声明的包名一致就可以。</p>
<p>4、代码包声明的基本规则：</p>
<ul>
<li>同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。如果目录中有命令源码文件，那么其他种类的源码文件也应该声明属于main包。这也是我们能够成功构建和运行它们的前提。</li>
<li>源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。对于命令源码文件而言，构建生成的可执行文件的主名称会与其父目录的名称相同</li>
</ul>
<p>###3、怎样把命令源码文件中的代码拆分到其他代码包？<br>1、把 demo4.go 另存为 demo5.go，并放到一个相对路径为puzzlers/article3/q2的目录中。</p>
<p>2、然后再创建一个相对路径为puzzlers/article3/q2/lib的目录，再把 demo4_lib.go 复制一份并改名为 demo5_lib.go 放到该目录中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lib5</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里修改了两个地方。</p>
<ul>
<li>第一个改动是，把代码包声明语句由package main改为了package lib5。注意，故意让声明的包名与其所在的目录的名称不同。</li>
<li><p>第二个改动是，把全小写的函数名hello改为首字母大写的Hello。</p>
<p>基于以上改动，我们再来看下面的几个问题。</p>
</li>
</ul>
<h4 id="1、代码包的导入路径总会与其所在目录的相对路径一致吗？"><a href="#1、代码包的导入路径总会与其所在目录的相对路径一致吗？" class="headerlink" title="1、代码包的导入路径总会与其所在目录的相对路径一致吗？"></a>1、代码包的导入路径总会与其所在目录的相对路径一致吗？</h4><p>库源码文件 demo5_lib.go 所在目录的相对路径是puzzlers/article3/q2/lib，而它却声明自己属于lib5包。在这种情况下，该包的导入路径是puzzlers/article3/q2/lib，还是puzzlers/article3/q2/lib5？<br>1、首先，我们在构建或者安装这个代码包的时候，提供给go命令的路径应该是目录的相对路径，就像这样：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> install puzzlers/article3/q2/lib</span><br></pre></td></tr></table></figure></p>
<p>该命令会成功完成。之后，当前工作区的 pkg 子目录下会产生相应的归档文件，具体的相对路径是:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg/darwin_amd64/puzzlers/article3/q2/lib.a</span><br></pre></td></tr></table></figure></p>
<p>其中的darwin_amd64就是我在讲工作区时提到的平台相关目录。可以看到，这里与源码文件所在目录的相对路径是对应的。</p>
<p>2、为了进一步说明问题，需要先对 demo5.go 做两个改动。</p>
<ul>
<li>第一个改动是，在以import为前导的代码包导入语句中加入puzzlers/article3/q2/lib，也就是试图导入这个代码包。</li>
<li>第二个改动是，把对hello函数的调用改为对lib.Hello函数的调用。其中的lib.叫做限定符，旨在指明右边的程序实体所在的代码包。不过这里与代码包导入路径的完整写法不同，只包含了路径中的最后一级lib，这与代码包声明语句中的规则一致。</li>
</ul>
<p>现在，通过运行go run demo5.go命令试一试。错误提示会类似于下面这种。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./demo5.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">2</span>: imported and not used: <span class="string">"puzzlers/article3/q2/lib"</span> as lib5</span><br><span class="line">./demo5.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">2</span>: undefined: lib</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一个错误提示的意思是，我们导入了puzzlers/article3/q2/lib包，但没有实际使用其中的任何程序实体。这在 Go 语言中是不被允许的，在编译时就会导致失败。</li>
<li>这里还有另外一个线索，那就是“as lib5”。这说明虽然导入了代码包puzzlers/article3/q2/lib，但是使用其中的程序实体的时候应该以lib5.为限定符。这也就是第二个错误提示的原因了。Go 命令找不到lib.这个限定符对应的代码包。</li>
</ul>
<p>3、为什么会是这样？<br>根本原因就是，我们在源码文件中声明所属的代码包与其所在目录的名称不同。请记住，源码文件所在的目录相对于 src 目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符要与它声明所属的代码包名称对应。</p>
<p>有两个方式可以使上述构建成功完成。我在这里选择把 demo5_lib.go 文件中的代码包声明语句改为package lib。理由是，为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。</p>
<h4 id="2、什么样的程序实体才可以被当前包外的代码引用？"><a href="#2、什么样的程序实体才可以被当前包外的代码引用？" class="headerlink" title="2、什么样的程序实体才可以被当前包外的代码引用？"></a>2、什么样的程序实体才可以被当前包外的代码引用？</h4><p>1、为什么要把 demo5_lib.go 文件中的那个函数名称hello的首字母大写？<br>实际上这涉及了 Go 语言中对于程序实体访问权限的规则。超级简单，<strong>名称的首字母为大写的程序实体才可以被当前包外的代码引用</strong>，否则它就只能被当前包内的其他代码引用。通过名称，Go 语言自然地把程序实体的访问权限划分为了<strong>包级私有的和公开的</strong>。<strong>对于包级私有的程序实体，即使你导入了它所在的代码包也无法引用到它。</strong></p>
<h4 id="3、对于程序实体，还有其他的访问权限规则吗？"><a href="#3、对于程序实体，还有其他的访问权限规则吗？" class="headerlink" title="3、对于程序实体，还有其他的访问权限规则吗？"></a>3、对于程序实体，还有其他的访问权限规则吗？</h4><p>1、答案是肯定的。在 Go 1.5 及后续版本中，我们可以通过创建internal代码包让一些程序实体仅仅能被当前模块中的其他代码引用。这被称为 Go 程序实体的第三种访问权限：<strong>模块级私有</strong>。</p>
<p>2、具体规则是，<strong>internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用</strong>。当然，引用前需要先导入这个internal包。<strong>对于其他代码包，导入该internal包都是非法的，无法通过编译</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/12/GO：1-3-库源码文件/" data-id="ckcivu87r0004a0virv6nb728" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：1-2-命令源码文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/GO：1-2-命令源码文件/" class="article-date">
  <time datetime="2020-07-10T11:25:13.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/GO：1-2-命令源码文件/">GO：1.2 命令源码文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们已经知道，环境变量 GOPATH 指向的是一个或多个工作区，每个工作区中都会有以代码包为基本组织形式的源码文件。</p>
<p>这里的源码文件又分为三种，即：<strong>命令源码文件、库源码文件和测试源码文件</strong>，它们都有着不同的用途和编写规则。<br><img src="/2020/07/10/GO：1-2-命令源码文件/command1.png" alt="command1.png"></p>
<h3 id="1、命令源码文件的用途是什么，怎样编写它？"><a href="#1、命令源码文件的用途是什么，怎样编写它？" class="headerlink" title="1、命令源码文件的用途是什么，怎样编写它？"></a>1、命令源码文件的用途是什么，怎样编写它？</h3><p>1、命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。</p>
<p>2、如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么它就是命令源码文件。 就像下面这段代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello, world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你把这段代码存成 demo1.go 文件，那么运行go run demo1.go命令后就会在屏幕（标准输出）中看到Hello, world!</p>
<p>注：<br>1、当需要模块化编程时，我们往往会将代码拆分到多个文件，甚至拆分到不同的代码包中。但无论怎样，对于一个独立的程序来说，<strong>命令源码文件永远只会也只能有一个</strong>。如果有与命令源码文件同包的源码文件，那么它们也应该声明属于main包。</p>
<p>2、通过构建或安装命令源码文件，<strong>生成的可执行文件就可以被视为“命令”</strong>，既然是命令，那么就应该具备接收参数的能力。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/10/GO：1-2-命令源码文件/" data-id="ckcivu87m0001a0vini37rlrs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GO：工作区和GOPATH" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/GO：工作区和GOPATH/" class="article-date">
  <time datetime="2020-07-10T06:27:34.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/10/GO：工作区和GOPATH/">GO：工作区和GOPATH</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、Go基础知识导图"><a href="#1、Go基础知识导图" class="headerlink" title="1、Go基础知识导图"></a>1、Go基础知识导图</h3><p><img src="/2020/07/10/GO：工作区和GOPATH/go1.jpg" alt="go1.jpg"></p>
<h3 id="2、工作区和GOPATH"><a href="#2、工作区和GOPATH" class="headerlink" title="2、工作区和GOPATH"></a>2、工作区和GOPATH</h3><h4 id="1、Go-3个环境变量"><a href="#1、Go-3个环境变量" class="headerlink" title="1、Go 3个环境变量"></a>1、Go 3个环境变量</h4><ul>
<li>GOROOT：Go语言安装根目录的路径，也就是GO语言的安装路径</li>
<li>GOPATH：若干工作区目录的路径，是我们自己定义的工作空间</li>
<li>GOBIN：Go程序生成的可执行文件的路径</li>
</ul>
<h4 id="2、GOPATH有什么意义"><a href="#2、GOPATH有什么意义" class="headerlink" title="2、GOPATH有什么意义"></a>2、GOPATH有什么意义</h4><ol>
<li><p>可以把GOPATH简单理解成Go语言的工作目录，它的值是一个目录的路径，也可以是多个目录的路径，每个目录都代表Go语言的一个工作区。</p>
</li>
<li><p>我们需要利用这些工作区去放置Go语言的源码文件，以及安装（install）后的归档文件（archive file，也就是以.a为扩展名的文件）和可执行文件。</p>
</li>
<li><p>Go语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本都是围绕GOPATH和工作区进行的。</p>
</li>
</ol>
<p>go build 命令一些可选项的用途和用法</p>
<h4 id="1、Go-语言源码的组织方式是怎样的？"><a href="#1、Go-语言源码的组织方式是怎样的？" class="headerlink" title="1、Go 语言源码的组织方式是怎样的？"></a>1、Go 语言源码的组织方式是怎样的？</h4><p>1、Go语言的源码也是以代码包为基本组织单位的。在文件系统中，这些代码包与目录一一对应。目录有子目录，代码包也可以有子包。</p>
<p>2、一个代码包可以包含任意个以.go为扩展名的原码文件，这些源码文件都需要被声明属于同一个代码包。</p>
<p>3、代码包的名称一般会与源码文件所在目录同名。如果不同名，在构建、安装时会以代码包名称为准。</p>
<p>4、每个代码包都有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/labstack/echo"</span></span><br></pre></td></tr></table></figure></p>
<p>5、在工作区中，一个代码包的导入路径实际上就是从src子目录到该包的实际存储位置的相对路径。</p>
<p>6、所以说，Go语言源码的组织方式就是以环境变量GOPATH、工作区、src目录个代码包为主线的。一般情况下，Go语言的源码文件都需要存放在环境变量GOPATH包含的某个工作区（目录）中的src目录下的某个代码包（目录）中。</p>
<h4 id="2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）"><a href="#2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）" class="headerlink" title="2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）"></a>2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）</h4><p>1、源码文件通常会被放在某个工作区的src子目录下</p>
<p>2、安装后如果产生了归档文件（以.a为扩展名的文件）会被放进该工作区的pkg子目录</p>
<p>3、如果产生了可执行文件，就可能会被放在该工作区的bin子目录下。</p>
<p><strong>归档文件存放具体位置和规则：</strong><br>1、源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件就是与这个代码包同名的。</p>
<p>2、放置它的相对目录就是该代码包的导入路径的直接父级。比如，一个已存在的代码包的导入路径是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com/labstack/echo</span><br></pre></td></tr></table></figure></p>
<p>那么执行命令<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> insatll github.com/labstack/echo</span><br></pre></td></tr></table></figure></p>
<p>生成的归档文件的相对目录就是github.com/labstack，文件名为echo.a。</p>
<p>3、上面这个代码包导入路径还有一层含义，即：该代码包的源码文件存在于github网站的labstack组的代码仓库echo中</p>
<p>4、归档文件的相对目录与pkg目录之间还有一级目录，称为平台相关目录。平台相关目录的名称是由“build”的目标操作系统、下划线和目标计算架构的代号组成的。比如，构建某个代码包的目标擦欧总系统时Linux，目标计算架构是64位，对应的平台相关目录就是linux_amd64。<br>因此，上述代码包的归档文件就会被放置在当前工作区的子目录<br>pkg/linux_amd64/github.com/labstack中。<br>gopath与工作区：<br><img src="/2020/07/10/GO：工作区和GOPATH/gopath1.png" alt="gopath1.png"></p>
<p>5、某个工作区的src子目录下的源码文件在安装后一般会被放置到当前工作区的pkg子目录下对应的目录中，或者直接被放置到该工作区的bin子目录中。</p>
<h4 id="3、理解构建和安装Go程序的过程"><a href="#3、理解构建和安装Go程序的过程" class="headerlink" title="3、理解构建和安装Go程序的过程"></a>3、理解构建和安装Go程序的过程</h4><p>构建与安装的异同：<br>1、构建使用命令go build，安装使用命令go install。构建和安装代码包的时候都会执行编译、打包等操作，并且，这些操作生成的任何文件都会先被保存到某个临时的目录中。</p>
<p>2、构建源码文件</p>
<ul>
<li>如果构建的是库源码文件</li>
</ul>
<p>那么操作后产生的结果只会存在于临时目录中，这里构建的主要意义在于检查和验证；</p>
<ul>
<li>如果构建的是命令源码文件</li>
</ul>
<p>操作的结果文件会被搬运到源码文件所在的目录中。</p>
<p>3、安装过程会先执行构建、然后还会进行你链接操作，并且把结果文件搬运到指定目录。如：</p>
<ul>
<li>安装库源码文件，结果文件被搬运到他所在工作区的pkg目录下的某个子目录中；</li>
<li>安装命令源码文件，结果文件被搬运到他所在工作区的bin目录中，或者环境变量GOBIN指向的目录中。</li>
</ul>
<h3 id="4、go-build-命令一些可选项的用途和用法"><a href="#4、go-build-命令一些可选项的用途和用法" class="headerlink" title="4、go build 命令一些可选项的用途和用法"></a>4、go build 命令一些可选项的用途和用法</h3><p>1、在运行go build命令的时候，默认不会编译目标代码包所依赖的那些代码包。</p>
<p>2、如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。</p>
<p>3、如果要强制编译它们，可以在执行命令的时候加入标记-a。此时，不但目标代码包总是会被编译，它依赖的代码包也总会被编译，即使依赖的是标准库中的代码包也是如此。</p>
<p>5、另外，如果不但要编译依赖的代码包，还要安装它们的归档文件，那么可以加入标记-i。</p>
<p>6、那么我们怎么确定哪些代码包被编译了呢？有两种方法。</p>
<ul>
<li>运行go build命令时加入标记-x，这样可以看到go build命令具体都执行了哪些操作。另外也可以加入标记-n，这样可以只查看具体操作而不执行它们。</li>
<li>运行go build命令时加入标记-v，这样可以看到go build命令编译的代码包的名称。它在与-a标记搭配使用时很有用。</li>
</ul>
<p>7、下面再说一说与 Go 源码的安装联系很紧密的一个命令：go get。<br>命令go get会自动从一些主流公用代码仓库（比如 GitHub）下载目标代码包，并把它们安装到环境变量GOPATH包含的第 1 工作区的相应目录中。如果存在环境变量GOBIN，那么仅包含命令源码文件的代码包会被安装到GOBIN指向的那个目录。</p>
<p>最常用的几个标记有下面几种。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-u：下载并安装代码包，不论工作区中是否已存在它们。</span><br><span class="line"></span><br><span class="line">-d：只下载代码包，不安装代码包。</span><br><span class="line"></span><br><span class="line">-fix：在下载代码包后先运行一个用于根据当前 Go 语言版本修正代码的工具，然后再安装代码包。</span><br><span class="line"></span><br><span class="line">-t：同时下载测试所需的代码包。</span><br><span class="line"></span><br><span class="line">-insecure：允许通过非安全的网络协议下载和安装代码包。HTTP 就是这样的协议。</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/10/GO：工作区和GOPATH/" data-id="ckcivu87e0000a0vis2dw0rda" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hexo博客迁移" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/02/hexo博客迁移/" class="article-date">
  <time datetime="2020-07-02T07:53:23.000Z" itemprop="datePublished">2020-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/02/hexo博客迁移/">hexo博客迁移</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、安装hexo博客必要的软件"><a href="#1、安装hexo博客必要的软件" class="headerlink" title="1、安装hexo博客必要的软件"></a>1、安装hexo博客必要的软件</h4><p>1、下载安装Git客户端<br>2、安装node js</p>
<h4 id="2、Github添加新电脑生成的密钥"><a href="#2、Github添加新电脑生成的密钥" class="headerlink" title="2、Github添加新电脑生成的密钥"></a>2、Github添加新电脑生成的密钥</h4><p>打开git bash输入如下命令：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"xxxxx@xxx.com"</span></span><br></pre></td></tr></table></figure></p>
<p>邮箱为GitHub注册邮箱，输入命令后直接回车，生成密钥对。根据提示找到密钥对所在位置，将id_rsa.pub公钥内容复制粘贴到Github-settings-‘SSH and GPG keys’-‘SSH keys’中。</p>
<p>使用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com   测试公钥是否添加成功</span><br></pre></td></tr></table></figure></p>
<h4 id="3、备份原文件"><a href="#3、备份原文件" class="headerlink" title="3、备份原文件"></a>3、备份原文件</h4><p>需要转移的文件有：<br><img src="/2020/07/02/hexo博客迁移/hexo1.png" alt="hexo1"><br>由于配置文件和主题文件需要经常更改，采用github创建博客分支的方式进行备份。</p>
<p><strong>1、创建分支</strong><br> 克隆github上上生成的静态文件到hexo文件夹中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/yourname/xxxx.github.io.git hexo</span></span><br></pre></td></tr></table></figure></p>
<p>克隆后将除.git文件外其他所有文件删除。主要是为了得到版本管理文件夹.git（.git文件为隐藏文件，可直接将可见文件全部删除）。</p>
<p><strong>2、将备份的原文件复制到此文件夹</strong><br>若文件夹是从github克隆，则需要删除主题文件中的版本控制文件夹,以next主题为例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf thems/next/.git*</span><br></pre></td></tr></table></figure></p>
<p>创建名为hexo的分支<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hexo</span><br></pre></td></tr></table></figure></p>
<p>保存所有文件到暂存区<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all</span><br></pre></td></tr></table></figure></p>
<p>提交变更<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"hexo-2"</span></span><br></pre></td></tr></table></figure></p>
<p>提交变更时报错：<br><img src="/2020/07/02/hexo博客迁移/hexo2.png" alt="hexo2"><br>根据提示配置。<br>推送分支到github,并用–set-upstream与origin创建关联，将hexo设置为默认分支<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --set-upstream origin hexo</span><br></pre></td></tr></table></figure></p>
<h4 id="4、迁移"><a href="#4、迁移" class="headerlink" title="4、迁移"></a>4、迁移</h4><p>以后在其他电脑上写博客，直接将分支克隆下来。再使用npm install安装依赖。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b hexo https:<span class="comment">//github.com/yourname/xxx.github.io.git</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<h4 id="5、发表文章"><a href="#5、发表文章" class="headerlink" title="5、发表文章"></a>5、发表文章</h4><p>1、新建文章<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure></p>
<p>2、注意：需要使用git push把源文件推到分支上<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"xxxx"</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p>
<p>3、部署文章<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p>
<p>参考：<br>1、<a href="https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/" target="_blank" rel="noopener">https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/</a></p>
<p>2、<a href="https://blog.csdn.net/white_idiot/article/details/80685990" target="_blank" rel="noopener">https://blog.csdn.net/white_idiot/article/details/80685990</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/02/hexo博客迁移/" data-id="ckcivu88o000va0viy2mke3qd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-测试驱动开发TDD" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/15/测试驱动开发TDD/" class="article-date">
  <time datetime="2020-06-15T06:27:12.000Z" itemprop="datePublished">2020-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/15/测试驱动开发TDD/">测试驱动开发TDD</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="测试驱动开发TDD（Test-Driven-Development）"><a href="#测试驱动开发TDD（Test-Driven-Development）" class="headerlink" title="测试驱动开发TDD（Test Driven Development）"></a>测试驱动开发TDD（Test Driven Development）</h2><h3 id="1、什么是-TDD"><a href="#1、什么是-TDD" class="headerlink" title="1、什么是 TDD"></a>1、什么是 TDD</h3><h4 id="1、TDD-有广义和狭义之分"><a href="#1、TDD-有广义和狭义之分" class="headerlink" title="1、TDD 有广义和狭义之分"></a>1、TDD 有广义和狭义之分</h4><p>1、常说的是狭义的TDD，也就是单元测试驱动开发UTDD（Unit Test Driven Development）；</p>
<p>2、广义的TDD：是验收测试驱动开发ATDD（Acceptance Test Driven Development），<br>包括行为驱动开发BDD（Behavior Driven Development）和消费者驱动契约开发Consumer-Driven Contracts Development 等。</p>
<h4 id="2、TDD-有三层含义："><a href="#2、TDD-有三层含义：" class="headerlink" title="2、TDD 有三层含义："></a>2、TDD 有三层含义：</h4><ul>
<li>Test-Driven Development，测试驱动开发。</li>
<li>Task-Driven Development，任务驱动开发，要对问题进行分析并进行任务分解。</li>
<li>Test-Driven Design，测试保护下的设计改善。TDD 并不能直接提高设计能力，它只是给你更多机会和保障去改善设计。</li>
</ul>
<h4 id="3、TDD-流程"><a href="#3、TDD-流程" class="headerlink" title="3、TDD 流程"></a>3、TDD 流程</h4><p>TDD 的基本流程是：红，绿，重构。<br><img src="/2020/06/15/测试驱动开发TDD/tdd2.jpg" alt="tdd2"></p>
<p>更详细的流程是：<br><img src="/2020/06/15/测试驱动开发TDD/tdd1.jpg" alt="tdd1"></p>
<p>1、编写测试<br>2、运行测试，观察测试结果是否如期失败（变红）<br>3、测试结果不如期失败，返回第1步修改测试<br>4、测试结果如期失败，编写刚好能够让测试通过的产品代码实现<br>5、运行测试，观察测试结果是否如期成功（变绿）<br>6、测试结果不如期成功，返回第4步修改实现<br>7、测试结果如期成功，分析代码是否需要重构<br>8、需要重构，返回第4步修改实现<br>9、不需要重构，编写下一个测试</p>
<h4 id="4、TDD-优点"><a href="#4、TDD-优点" class="headerlink" title="4、TDD 优点"></a>4、TDD 优点</h4><p>1、降低开发者负担<br>通过明确的流程，让我们一次只关注一个点，思维负担更小。</p>
<p>2、保护网<br>TDD 的好处是覆盖完全的单元测试，对产品代码提供了一个保护网，让我们可以轻松地迎接需求变化或改善代码的设计。<br>所以如果你的项目需求稳定，一次性做完，后续没有任何改动的话，能享受到 TDD 的好处就比较少了。</p>
<p>3、提前澄清需求<br>先写测试可以帮助我们去思考需求，并提前澄清需求细节，而不是代码写到一半才发现不明确的需求。</p>
<p>4、快速反馈<br>有很多人说 TDD 时，我的代码量增加了，所以开发效率降低了。但是，如果没有单元测试，你就要手工测试，你要花很多时间去准备数据，启动应用，跳转界面等，反馈是很慢的。准确说，快速反馈是单元测试的好处。</p>
<h4 id="5、TDD-的三条规则"><a href="#5、TDD-的三条规则" class="headerlink" title="5、TDD 的三条规则"></a>5、TDD 的三条规则</h4><p>1、除非是为了使一个失败的 unit test 通过，否则不允许编写任何产品代码</p>
<p>2、在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）</p>
<p>3、只允许编写刚好能够使一个失败的 unit test 通过的产品代码</p>
<p>如果违反了会怎么样呢？<br>1、违反第一条，先编写了产品代码，那这段代码是为了实现什么需求呢？怎么确保它真的实现了呢？<br>2、违反第二条，写了多个失败的测试，如果测试长时间不能通过，会增加开发者的压力，另外，测试可能会被重构，这时会增加测试的修改成本。<br>3、违反第三条，产品代码实现了超出当前测试的功能，那么这部分代码就没有测试的保护，不知道是否正确，需要手工测试。可能这是不存在的需求，那就凭空增加了代码的复杂性。如果是存在的需求，那后面的测试写出来就会直接通过，破坏了 TDD 的节奏感。</p>
<p>我认为它的本质是：<br>1、分离关注点，一次只戴一顶帽子<br>在我们编程的过程中，有几个关注点：需求，实现，设计。<br>TDD 给了我们明确的三个步骤，每个步骤关注一个方面。</p>
<ul>
<li>红：<br>写一个失败的测试，它是对一个小需求的描述，只需要关心输入输出，这个时候根本不用关心如何实现。</li>
<li>绿：<br>专注在用最快的方式实现当前这个小需求，不用关心其他需求，也不要管代码的质量多么惨不忍睹。</li>
<li>重构：<br>既不用思考需求，也没有实现的压力，只需要找出代码中的坏味道，并用一个手法消除它，让代码变成整洁的代码。</li>
</ul>
<p>2、注意力控制<br>人的注意力既可以主动控制，也会被被动吸引。注意力来回切换的话，就会消耗更多精力，思考也会不那么完整。<br>使用 TDD 开发，我们要主动去控制注意力，写测试的时候，发现一个类没有定义，IDE 提示编译错误，这时候你如果去创建这个类，你的注意力就不在需求上了，已经切换到了实现上，我们应该专注地写完这个测试，思考它是否表达了需求，确定无误后再开始去消除编译错误。</p>
<p>参考：<a href="https://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="noopener">https://www.jianshu.com/p/62f16cd4fef3</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/15/测试驱动开发TDD/" data-id="ckcivu89e001ua0vi5f0399e5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go-goroutine、channel、反射" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-goroutine、channel、反射/" class="article-date">
  <time datetime="2020-06-11T07:58:15.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/go-goroutine、channel、反射/">go:goroutine、channel、反射</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、goroutine"><a href="#1、goroutine" class="headerlink" title="1、goroutine"></a>1、goroutine</h3><h4 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、Go协程和Go主线程</p>
<ul>
<li><strong>Go主线程</strong>（有的程序员直接成为线程/也可以理解成进程）：<strong>一个Go主线程上，可以起多个协程</strong>，即<strong>协程是轻量级的线程</strong>。</li>
</ul>
<p>2、Go协程的特点</p>
<ul>
<li>有独立的栈空间</li>
<li>共享程序堆空间</li>
<li>调度由用户控制</li>
<li>协程是轻量级的线程</li>
</ul>
<p>3、案例<br>1）在主线程（可以理解成进程），开启一个goroutine，该协程每隔一秒输出“hello world”<br>2）在主线程中也每隔一秒输出“hello world”，输出10次后，退出程序<br>3）要求主线程和goroutine同时执行<br>4）主线程和协程执行流程图</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>    </span><br><span class="line">    <span class="string">"strconv"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个函数，每隔1秒输出“hello world”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span> ;i++  &#123;   </span><br><span class="line">        fmt.Println(<span class="string">"test() hello world"</span>+strconv.Itoa(i))     </span><br><span class="line">        </span><br><span class="line">        time.Sleep(time.Second)  <span class="comment">//休眠一秒  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">go</span> test()<span class="comment">//开启一个协程    </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span> ;i++  &#123;    </span><br><span class="line">        fmt.Println(<span class="string">"main() hello world"</span>+strconv.Itoa(i))      </span><br><span class="line">        </span><br><span class="line">        time.Sleep(time.Second)     <span class="comment">//休眠一秒  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main() hello world1</span><br><span class="line">test() hello world1</span><br><span class="line">main() hello world2</span><br><span class="line">test() hello world2</span><br><span class="line">test() hello world3</span><br><span class="line">main() hello world3</span><br><span class="line">main() hello world4</span><br><span class="line">test() hello world4</span><br><span class="line">test() hello world5</span><br><span class="line">main() hello world5</span><br><span class="line">test() hello world6</span><br><span class="line">main() hello world6</span><br><span class="line">main() hello world7</span><br><span class="line">test() hello world7</span><br><span class="line">test() hello world8</span><br><span class="line">main() hello world8</span><br><span class="line">main() hello world9</span><br><span class="line">test() hello world9</span><br></pre></td></tr></table></figure></p>
<p>由输出看出，<strong>主线程main和协程test同时执行</strong></p>
<ul>
<li><p>主线程和协程执行流程图<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine1.jpg" alt="goroutine1"></p>
</li>
<li><p>程序开始执行，main主线程开始执行</p>
</li>
<li>go test()开启协程，<strong>主线程main和协程test同时执行</strong></li>
<li>程序退出以<strong>主线程</strong>为主：<pre><code>1） 如果主线程退出了，则协程即使还没有执行完毕也会退出
2）当然协程可以在主线程没有退出前，就执行完毕退出协程
</code></pre></li>
</ul>
<p>4、总结</p>
<ul>
<li><p>1）<strong>主线程</strong>是一个<strong>物理线程</strong>，<strong>直接作用在CPU上</strong>。是重量级的，非常耗费CPU资源。</p>
</li>
<li><p>2）<strong>协程从主线程开启的</strong>，是轻量级的线程，是<strong>逻辑态的</strong>。对资源消耗相对小</p>
</li>
<li><p>3）Go的协程机制是重要特点，可以轻松的开启上万个协程。（其他编程语言的开发机制一般是基于线程的，开启过多的线程，资源消耗大）</p>
</li>
</ul>
<h4 id="2、goroutine的调度模型"><a href="#2、goroutine的调度模型" class="headerlink" title="2、goroutine的调度模型"></a>2、goroutine的调度模型</h4><p>1、MPG模式基本介绍</p>
<ul>
<li>M：操作系统的主线程（是物理线程，真正干活的人）</li>
<li>P：协程执行需要的上下文环境（运行时需要的资源和运行时的状态）</li>
<li>G：协程（逻辑态的）</li>
</ul>
<p>2、MPG模式运行的状态</p>
<p>1）MPG模式运行的状态1<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine2.jpg" alt="goroutine2"></p>
<p>2）MPG模式运行的状态2<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine3.jpg" alt="goroutine3"></p>
<h4 id="3、设置运行CPU数目"><a href="#3、设置运行CPU数目" class="headerlink" title="3、设置运行CPU数目"></a>3、设置运行CPU数目</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="comment">//runtime.NumCPU()   查询系统的CPU数目</span></span><br><span class="line">    cpuNum := runtime.NumCPU()   </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"cpuNum="</span>,cpuNum)     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置使用多个CPU     </span></span><br><span class="line">    runtime.GOMAXPROCS(cpuNum<span class="number">-1</span>)     </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"ok"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、管道channel"><a href="#2、管道channel" class="headerlink" title="2、管道channel"></a>2、管道channel</h3><p>案例：计算1-20的各个数的阶乘，并且把各个数放入map中并打印，使用goroutine完成</p>
<p>思路：</p>
<ul>
<li>1、编写一个函数，计算各个数的阶乘并放入map中</li>
<li>2、启动多个协程，统计的结果放入map中</li>
<li>3、map应该做全局的</li>
</ul>
<p>解法一：使用全局变量加锁同步<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (     </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"sync"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(  </span><br><span class="line">    myMap =<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//全局资源不加锁，会发生资源竞争，同时写会报错   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以声明一个全局互斥锁解决    </span></span><br><span class="line">    <span class="comment">//sync是一个包，synchornized 同步    </span></span><br><span class="line">    <span class="comment">//Mutex 互斥      </span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//test函数计算n的阶乘，将结果放入myMap中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="keyword">int</span>)</span></span>&#123;    </span><br><span class="line">    res:=<span class="number">1</span>    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++&#123;      </span><br><span class="line">    res*=i  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入map前加锁    </span></span><br><span class="line">    lock.Lock()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//把结果放入myMap     </span></span><br><span class="line">    myMap[n]=res    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//写完map后解锁    </span></span><br><span class="line">    lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//这里开启20个协程，</span></span><br><span class="line">    <span class="comment">//20个协程同时向map写数据，会发生 并发map写 错误    </span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++&#123;         </span><br><span class="line">        <span class="keyword">go</span> test(i)    </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//休眠5秒钟（人为估算），让主线程等待所有的协程执行完   </span></span><br><span class="line">    time.Sleep(<span class="number">5</span>*time.Second)   </span><br><span class="line">    <span class="comment">//如果不休眠，可能main主线程已经结束退出，但是test协程还没写入map     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//互斥性资源读写都要加锁     </span></span><br><span class="line">    lock.Lock()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出结果，对map进行读操作     </span></span><br><span class="line">    <span class="keyword">for</span> i,v :=<span class="keyword">range</span> myMap&#123;           </span><br><span class="line">        fmt.Printf(<span class="string">"map[%d]=%d\n"</span>,i,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    lock.Unlock()&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="number">17</span>]=<span class="number">355687428096000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">16</span>]=<span class="number">20922789888000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">20</span>]=<span class="number">2432902008176640000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">9</span>]=<span class="number">362880</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">10</span>]=<span class="number">3628800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">12</span>]=<span class="number">479001600</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">3</span>]=<span class="number">6</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">19</span>]=<span class="number">121645100408832000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">11</span>]=<span class="number">39916800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">15</span>]=<span class="number">1307674368000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">18</span>]=<span class="number">6402373705728000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">8</span>]=<span class="number">40320</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">5</span>]=<span class="number">120</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">7</span>]=<span class="number">5040</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">14</span>]=<span class="number">87178291200</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">13</span>]=<span class="number">6227020800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">4</span>]=<span class="number">24</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">6</span>]=<span class="number">720</span></span><br></pre></td></tr></table></figure></p>
<p>因为map的key是无序的，所以未按递增顺序执行，而且并发执行的顺序也可能不是递增得到结果的</p>
<p>上面的解法中</p>
<ul>
<li>主线程等待所有goroutine全部完成时间很难确定，这里设置为5秒，是为估算</li>
<li>如果主线程休眠时间长了，会加长等待时间；如果等待时间短了，可能还有goroutine处于工作状态（没有执行完），这时也会随主线程的退出二销毁</li>
<li>通过全局变量加锁同步来实现协程间通讯，并不利于多个协程对全局变量的读写操作</li>
</ul>
<p>综上，我们引出一种新的通讯机制channel</p>
<p>解法二：使用channel</p>
<h4 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、channel本质上就是一个数据结构-队列</p>
<p>2、数据先进先出</p>
<p>3、<strong>线程安全</strong>，多个goroutine访问时，自己不需要再加锁，即：<strong>channel本身就是线程安全的</strong></p>
<p>4、<strong>channel是有类型的</strong>，一个string的channel只能存放string类型数据<br><img src="/2020/06/11/go-goroutine、channel、反射/channel1.jpg" alt="channel1"></p>
<h4 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h4><h5 id="1、定义-声明"><a href="#1、定义-声明" class="headerlink" title="1、定义/声明"></a>1、定义/声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 数据类型</span><br><span class="line"></span><br><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//intChan类型为int，只能存放int型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//mapChan类型为map[int]string，只能存放map[int]string型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> perChan <span class="keyword">chan</span> Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> perChan2 <span class="keyword">chan</span> *Person</span><br></pre></td></tr></table></figure>
<p>2、注意</p>
<ul>
<li>channel是<strong>引用类型</strong></li>
<li><strong>channel必须初始化后才能写入数据，即make后才能使用</strong></li>
<li>channel是由类型的，如intChan类型为int，只能存放int型数据</li>
</ul>
<h5 id="3、管道的初始化、从管道读写数据以及注意事项"><a href="#3、管道的初始化、从管道读写数据以及注意事项" class="headerlink" title="3、管道的初始化、从管道读写数据以及注意事项"></a>3、管道的初始化、从管道读写数据以及注意事项</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">//1、创建一个可以存放3个int的管道   </span></span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span>    </span><br><span class="line">    intChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)  <span class="comment">//channel make后才能使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、intChan是什么     </span></span><br><span class="line">    fmt.Printf(<span class="string">"intChan的值=%v intChan本身的地址=%v\n"</span>,intChan,&amp;intChan)   </span><br><span class="line">    <span class="comment">//输出：intChan的值=0xc000092080 </span></span><br><span class="line">    <span class="comment">//intChan本身的地址=0xc00008c018      </span></span><br><span class="line">    <span class="comment">//可以看出intChan的值为一个地址，所以channel是引用类型。    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、向管道写入数据     </span></span><br><span class="line">    intChan&lt;<span class="number">-10</span><span class="comment">//直接写入常量   </span></span><br><span class="line">    num:=<span class="number">211</span>     </span><br><span class="line">    intChan&lt;-num<span class="comment">//写入变量    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、看看管道的长度和容量    </span></span><br><span class="line">    <span class="comment">//容量是make时传入的，这里传入的是3，容量不能自动增长，和slice、map不一样    </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))     </span><br><span class="line">    <span class="comment">//channel len=2 cap=3    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、注意：给管道写入数据时不能超过容量     </span></span><br><span class="line">    intChan&lt;<span class="number">-50</span>      <span class="comment">//intChan&lt;-98     </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))   </span><br><span class="line">    <span class="comment">//fatal error: all goroutines are asleep - deadlock!   </span></span><br><span class="line">    <span class="comment">//报告死锁deadlock错误     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、从管道中读取数据     </span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">int</span>     </span><br><span class="line">    num2 = &lt;-intChan  </span><br><span class="line">    fmt.Println(<span class="string">"num2="</span>,num2)<span class="comment">//num2= 10，从队列头开始取     </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))    </span><br><span class="line">    <span class="comment">//channel len=2 cap=3     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、在没有使用协程的情况下，如果管道中的数据已经全部取出，再取数据就会报告死锁deadlock错误     </span></span><br><span class="line">    num3 := &lt;-intChan    </span><br><span class="line">    num4 := &lt;-intChan     </span><br><span class="line">    num5 := &lt;-intChan   </span><br><span class="line">    fmt.Println(<span class="string">"num3="</span>,num3,<span class="string">"num4="</span>,num4,<span class="string">"num5="</span>,num5)   </span><br><span class="line">    <span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<ul>
<li>channel中只能存放指定的数据类型</li>
<li>channel的数据放满后，就不能再放入了，否则报告死锁deadlock错误</li>
<li>当 channel的数据放满后，如果从channel中取出数据，可以再次放入数据</li>
<li>在没有使用协程的情况下，如果channel中的数据取完了，再次取数据，会报告死锁deadlock错误</li>
</ul>
<p>一个例子，当管道是空接口interface{}类型时，可以存放任意数据类型的值，取出管道中的值对象的的字段值时，需要类型断言<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123; </span><br><span class="line">    Name <span class="keyword">string</span>     </span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    allChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">3</span>)<span class="comment">//定义一个空接口类型，容量为3的管道allChan      </span></span><br><span class="line"></span><br><span class="line">    allChan&lt;<span class="number">-10</span><span class="comment">//往管道写入int类型的值     </span></span><br><span class="line">    allChan&lt;-<span class="string">"tom"</span><span class="comment">//往管道写入string类型的值    </span></span><br><span class="line"></span><br><span class="line">    cat:=Cat&#123;<span class="string">"小花猫"</span>,<span class="number">4</span>&#125;<span class="comment">//实例化一个Cat    </span></span><br><span class="line">    allChan&lt;-cat<span class="comment">////往管道写入Cat类型的值    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//想要取出管道中的第三个值，需要丢弃第一个和第二个    </span></span><br><span class="line">    &lt;-allChan    </span><br><span class="line">    &lt;-allChan    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//取到第三个   </span></span><br><span class="line">    newCat:=&lt;-allChan   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//newCat从编译层面看是空接口类型,接口类型本身没有字段    </span></span><br><span class="line">    <span class="comment">//但在运行时可动态指向结构体Cat，</span></span><br><span class="line">    <span class="comment">//下面写法语法上没错，运行时可动态指向Cat     </span></span><br><span class="line">    fmt.Printf(<span class="string">"newCat的类型=%T newCat的值=%v\n"</span>,newCat,newCat)   </span><br><span class="line">    <span class="comment">//输出：newCat的类型=main.Cat newCat的值=&#123;小花猫 4&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//newCat从编译层面看是空接口类型，接口类型本身没有字段，</span></span><br><span class="line">    <span class="comment">//直接写编译不通过，需要类型断言      </span></span><br><span class="line">    aNewCat:=newCat.(Cat)     </span><br><span class="line">    fmt.Printf(<span class="string">"newCat.Name=%v"</span>,aNewCat.Name)</span><br><span class="line">    <span class="comment">//输出：newCat.Name=小花猫</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4、管道的遍历和关闭"><a href="#4、管道的遍历和关闭" class="headerlink" title="4、管道的遍历和关闭"></a>4、管道的遍历和关闭</h5><p> 1、管道的关闭</p>
<p>使用内置函数<strong>close()可以关闭管道</strong>，当管道关闭后，就不能再向管道写数据了，但是仍然可以从管道中读取数据<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)  </span><br><span class="line">    intChan&lt;<span class="number">-100</span>   </span><br><span class="line">    intChan&lt;<span class="number">-200</span>    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、关闭管道    </span></span><br><span class="line">    <span class="built_in">close</span>(intChan)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、关闭管道后，不能再写入数据   </span></span><br><span class="line">    <span class="comment">//intChan&lt;-300    </span></span><br><span class="line">    <span class="comment">//panic: send on closed channel     </span></span><br><span class="line">    <span class="comment">//向一个关闭的通道中发送数据，panic终止程序    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、关闭管道后，可以再读取数据   </span></span><br><span class="line">    n1:=&lt;-intChan    </span><br><span class="line">    fmt.Println(<span class="string">"n1="</span>,n1)<span class="comment">//n1= 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、管道的遍历<br>channel支持for-range的方式进行遍历，有两个细节注意：</p>
<ul>
<li>在遍历时，如果channel没有关闭，则会出现死锁deadlock错误</li>
<li>在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历</li>
</ul>
<p>在遍历时不能使用普通for循环遍历，因为管道的长度（len(intChan)）是随数据出管道-1动态变化的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环往管道中写入100个数据      </span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">100</span> ;i++  &#123;       </span><br><span class="line">        intChan&lt;-i*<span class="number">2</span>   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历，一定要先关闭管道,如果不关闭管道，会出现死锁deadlock错误     </span></span><br><span class="line">    <span class="built_in">close</span>(intChan)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//管道没有下标，for-range只返回一个值    </span></span><br><span class="line">    <span class="keyword">for</span> v:= <span class="keyword">range</span> intChan&#123;         </span><br><span class="line">        fmt.Println(<span class="string">"v="</span>,v)     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、goroutine和管道channel结合使用"><a href="#3、goroutine和管道channel结合使用" class="headerlink" title="3、goroutine和管道channel结合使用"></a>3、goroutine和管道channel结合使用</h3><h4 id="1、案例："><a href="#1、案例：" class="headerlink" title="1、案例："></a>1、案例：</h4><p>案例：<br>goroutine和管道channel协同工作<br>1）开启一个wiiteData协程，向管道写入50个整数<br>2）开启一个readData协程，从管道中读取wiiteData写入的数据<br>3）注意：wiiteData和readData操作的是同一个管道<br>4）主线程需要等待wiiteData和readData协程完成工作后才能退出<br>思路图解：<br><img src="/2020/06/11/go-goroutine、channel、反射/goandchan1.jpg" alt="goandchan1"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++  &#123;   </span><br><span class="line">        intChan&lt;-i         </span><br><span class="line">        fmt.Println(<span class="string">"writeData "</span>,i)    </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(intChan)<span class="comment">//关闭intChan，后面intChan仍然可读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//readData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>,exitChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">for</span>&#123;         </span><br><span class="line">        v,ok:=&lt;-intChan      </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;       </span><br><span class="line">          <span class="keyword">break</span>     </span><br><span class="line">         &#125;         </span><br><span class="line">        fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//readData读取数据完后，    </span></span><br><span class="line">    <span class="comment">//往exitChan写入数据true，告知主线程readData执行完毕    </span></span><br><span class="line">    exitChan&lt;-<span class="literal">true</span>   </span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//创建两个管道  </span></span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">50</span>)  </span><br><span class="line">    exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)  <span class="comment">//该管道用于等到intChan管道的读取协程工作完毕后，往exitChan写入数据，标识主线程可退出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> writeData(intChan) <span class="comment">//向管道写入50个整数</span></span><br><span class="line">    <span class="keyword">go</span> readData(intChan,exitChan)   <span class="comment">//从管道中读取wiiteData写入的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>&#123;      </span><br><span class="line">        _,ok:=&lt;-exitChan    </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;            </span><br><span class="line">             <span class="keyword">break</span>       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、管道阻塞机制"><a href="#2、管道阻塞机制" class="headerlink" title="2、管道阻塞机制"></a>2、管道阻塞机制</h4><p>如果<strong>只向管道里写数据，而没有读取</strong>，就会出现<strong>阻塞而死锁</strong>deadlock。<br>注意：如果<strong>有向管道读取数据，但读取比写数据慢得多</strong>，也不会发生死锁，只要编译器检测到数据在管道中是流动的，即有读取也有写入，那么就不会发生死锁</p>
<p>下面例子中，intChan容量改为10<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++  &#123;   </span><br><span class="line">        intChan&lt;-i     <span class="comment">//数据一下就放入，但下面readData读取慢慢读</span></span><br><span class="line">    </span><br><span class="line">        fmt.Println(<span class="string">"writeData "</span>,i)    </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(intChan)<span class="comment">//关闭intChan，后面intChan仍然可读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//readData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>,exitChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">for</span>&#123;         </span><br><span class="line">        v,ok:=&lt;-intChan      </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;       </span><br><span class="line">          <span class="keyword">break</span>     </span><br><span class="line">         &#125;         </span><br><span class="line">       time.Sleep(time.Second)<span class="comment">//慢慢读，每隔一秒读一次</span></span><br><span class="line">       </span><br><span class="line">      fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//readData读取数据完后，    </span></span><br><span class="line">    <span class="comment">//往exitChan写入数据true，告知主线程readData执行完毕    </span></span><br><span class="line">    exitChan&lt;-<span class="literal">true</span>   </span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//创建两个管道  </span></span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)<span class="comment">//容量10</span></span><br><span class="line">    exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)  <span class="comment">//该管道用于等到intChan管道的读取协程工作完毕后，往exitChan写入数据，标识主线程可退出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> writeData(intChan) <span class="comment">//向管道写入50个整数</span></span><br><span class="line">    <span class="keyword">go</span> readData(intChan,exitChan)   <span class="comment">//从管道中读取wiiteData写入的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>&#123;      </span><br><span class="line">        _,ok:=&lt;-exitChan    </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;            </span><br><span class="line">             <span class="keyword">break</span>       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">writeData  <span class="number">1</span></span><br><span class="line">writeData  <span class="number">2</span></span><br><span class="line">writeData  <span class="number">3</span></span><br><span class="line">writeData  <span class="number">4</span></span><br><span class="line">writeData  <span class="number">5</span></span><br><span class="line">writeData  <span class="number">6</span></span><br><span class="line">writeData  <span class="number">7</span></span><br><span class="line">writeData  <span class="number">8</span></span><br><span class="line">writeData  <span class="number">9</span></span><br><span class="line">writeData  <span class="number">10</span></span><br><span class="line">writeData  <span class="number">11</span></span><br><span class="line">readData 读到数据=<span class="number">1</span></span><br><span class="line">writeData  <span class="number">12</span></span><br><span class="line">readData 读到数据=<span class="number">2</span></span><br><span class="line">writeData  <span class="number">13</span></span><br><span class="line">readData 读到数据=<span class="number">3</span></span><br><span class="line">writeData  <span class="number">14</span></span><br><span class="line">readData 读到数据=<span class="number">4</span></span><br><span class="line">writeData  <span class="number">15</span></span><br><span class="line">readData 读到数据=<span class="number">5</span></span><br><span class="line">writeData  <span class="number">16</span></span><br><span class="line">readData 读到数据=<span class="number">6</span></span><br><span class="line">writeData  <span class="number">17</span></span><br><span class="line">readData 读到数据=<span class="number">7</span></span><br><span class="line">writeData  <span class="number">18</span></span><br><span class="line">readData 读到数据=<span class="number">8</span></span><br><span class="line">writeData  <span class="number">19</span></span><br><span class="line">readData 读到数据=<span class="number">9</span></span><br><span class="line">writeData  <span class="number">20</span></span><br><span class="line">readData 读到数据=<span class="number">10</span></span><br><span class="line">writeData  <span class="number">21</span></span><br><span class="line">readData 读到数据=<span class="number">11</span></span><br><span class="line">writeData  <span class="number">22</span></span><br><span class="line">readData 读到数据=<span class="number">12</span></span><br><span class="line">writeData  <span class="number">23</span></span><br><span class="line">readData 读到数据=<span class="number">13</span></span><br><span class="line">writeData  <span class="number">24</span></span><br><span class="line">readData 读到数据=<span class="number">14</span></span><br><span class="line">writeData  <span class="number">25</span></span><br><span class="line">readData 读到数据=<span class="number">15</span></span><br><span class="line">writeData  <span class="number">26</span></span><br><span class="line">readData 读到数据=<span class="number">16</span></span><br><span class="line">writeData  <span class="number">27</span></span><br><span class="line">readData 读到数据=<span class="number">17</span></span><br><span class="line">writeData  <span class="number">28</span></span><br><span class="line">readData 读到数据=<span class="number">18</span></span><br><span class="line">writeData  <span class="number">29</span></span><br><span class="line">readData 读到数据=<span class="number">19</span></span><br><span class="line">writeData  <span class="number">30</span></span><br><span class="line">readData 读到数据=<span class="number">20</span></span><br><span class="line">writeData  <span class="number">31</span></span><br><span class="line">readData 读到数据=<span class="number">21</span></span><br><span class="line">writeData  <span class="number">32</span></span><br><span class="line">readData 读到数据=<span class="number">22</span></span><br><span class="line">writeData  <span class="number">33</span></span><br><span class="line">readData 读到数据=<span class="number">23</span></span><br><span class="line">writeData  <span class="number">34</span></span><br><span class="line">readData 读到数据=<span class="number">24</span></span><br><span class="line">writeData  <span class="number">35</span></span><br><span class="line">readData 读到数据=<span class="number">25</span></span><br><span class="line">writeData  <span class="number">36</span></span><br><span class="line">readData 读到数据=<span class="number">26</span></span><br><span class="line">writeData  <span class="number">37</span></span><br><span class="line">readData 读到数据=<span class="number">27</span></span><br><span class="line">writeData  <span class="number">38</span></span><br><span class="line">readData 读到数据=<span class="number">28</span></span><br><span class="line">writeData  <span class="number">39</span></span><br><span class="line">readData 读到数据=<span class="number">29</span></span><br><span class="line">writeData  <span class="number">40</span></span><br><span class="line">readData 读到数据=<span class="number">30</span></span><br><span class="line">writeData  <span class="number">41</span></span><br><span class="line">readData 读到数据=<span class="number">31</span></span><br><span class="line">writeData  <span class="number">42</span></span><br><span class="line">readData 读到数据=<span class="number">32</span></span><br><span class="line">writeData  <span class="number">43</span></span><br><span class="line">readData 读到数据=<span class="number">33</span></span><br><span class="line">writeData  <span class="number">44</span></span><br><span class="line">readData 读到数据=<span class="number">34</span></span><br><span class="line">writeData  <span class="number">45</span></span><br><span class="line">readData 读到数据=<span class="number">35</span></span><br><span class="line">writeData  <span class="number">46</span></span><br><span class="line">readData 读到数据=<span class="number">36</span></span><br><span class="line">writeData  <span class="number">47</span></span><br><span class="line">readData 读到数据=<span class="number">37</span></span><br><span class="line">writeData  <span class="number">48</span></span><br><span class="line">readData 读到数据=<span class="number">38</span></span><br><span class="line">writeData  <span class="number">49</span></span><br><span class="line">readData 读到数据=<span class="number">39</span></span><br><span class="line">writeData  <span class="number">50</span></span><br><span class="line">readData 读到数据=<span class="number">40</span></span><br><span class="line">readData 读到数据=<span class="number">41</span></span><br><span class="line">readData 读到数据=<span class="number">42</span></span><br><span class="line">readData 读到数据=<span class="number">43</span></span><br><span class="line">readData 读到数据=<span class="number">44</span></span><br><span class="line">readData 读到数据=<span class="number">45</span></span><br><span class="line">readData 读到数据=<span class="number">46</span></span><br><span class="line">readData 读到数据=<span class="number">47</span></span><br><span class="line">readData 读到数据=<span class="number">48</span></span><br><span class="line">readData 读到数据=<span class="number">49</span></span><br><span class="line">readData 读到数据=<span class="number">50</span></span><br></pre></td></tr></table></figure></p>
<p>因为管道容量为10，所以写到11的时候，需要等待数据被读出才能写入，所以写数据12-50与读取是交错的，读取数据每隔一秒读取一次。最后数据全部写完，只需要读取数据。</p>
<h4 id="3、细节"><a href="#3、细节" class="headerlink" title="3、细节"></a>3、细节</h4><p>1、在默认情况下，管道是双向的，即可读可写<br>2、管道可以声明为只读或只写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管道声明为只写</span></span><br><span class="line"><span class="keyword">var</span> chan1 <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">chan1 &lt;- <span class="number">1</span> <span class="comment">//ok</span></span><br><span class="line">num1 := &lt;-chan1 <span class="comment">//error，无效的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管道声明为只读</span></span><br><span class="line"><span class="keyword">var</span> chan2 &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">num2 := &lt;-chan2 <span class="comment">//ok</span></span><br><span class="line">chan2 &lt;- <span class="number">2</span> <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>管道声明为只读或只写的应用场景：</p>
<ul>
<li>先声明一个双向管道intChan</li>
<li>声明两个函数，一个往intChan只写数据的send函数，一个往intChan只读数据的recv函数，防止误操作</li>
<li>可以将双向管道intChan作为实参，传给只写数据的send函数，send函数形参为<strong>ch chan&lt;- int</strong></li>
<li>可以将双向管道intChan作为实参，传给只读数据的recv函数，re函数形参为<strong>ch &lt;-chan int</strong></li>
<li>上面所述中，将双向管道作为实参传给单向管道（只读或只写）并不会报错。</li>
<li>管道的双向和单向只是管道的性质，但是管道的类型都是chan int，所以不会报错</li>
</ul>
<p>3、使用<strong>select</strong>可以解决<strong>从管道取数据的阻塞问题</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">//使用select可以解决从管道取数据的阻塞问题     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、定义一个管道 10个数据 int     </span></span><br><span class="line">    intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++  &#123;     </span><br><span class="line">         intChan&lt;-i     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、定义一个管道 5个数据，string     </span></span><br><span class="line">    stringChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">5</span>)    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span> ;i++  &#123;   </span><br><span class="line">         stringChan&lt;-<span class="string">"hello"</span>+fmt.Sprintf(<span class="string">"%d"</span>,i)  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统方法在遍历管道时，如果不关闭会阻塞并死锁deadlock   </span></span><br><span class="line">    <span class="comment">//但在实际开发中，我们往往不确定关闭管道的时机    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由此我们使用select解决      </span></span><br><span class="line">    <span class="keyword">for</span>&#123;          </span><br><span class="line">        <span class="keyword">select</span> &#123;          </span><br><span class="line">        <span class="comment">//重点：这里如果intChan一直没有关闭，不会一直阻塞而死锁，                </span></span><br><span class="line">        <span class="comment">//会自动到下一个case匹配         </span></span><br><span class="line">            <span class="keyword">case</span> v:=&lt;-intChan:              </span><br><span class="line">            fmt.Printf(<span class="string">"从intChan读取了数据%d\n"</span>,v)         </span><br><span class="line">            <span class="keyword">case</span> v:=&lt;-stringChan:                   </span><br><span class="line">            fmt.Printf(<span class="string">"从stringChan读取了数据%s\n"</span>,v)              </span><br><span class="line">            <span class="keyword">default</span>:                     </span><br><span class="line">            fmt.Printf(<span class="string">"都取不到了，加入处理逻辑\n"</span>)                    </span><br><span class="line">            <span class="keyword">return</span>        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">从stringChan读取了数据hello0</span><br><span class="line">从intChan读取了数据<span class="number">0</span></span><br><span class="line">从stringChan读取了数据hello1</span><br><span class="line">从stringChan读取了数据hello2</span><br><span class="line">从stringChan读取了数据hello3</span><br><span class="line">从intChan读取了数据<span class="number">1</span></span><br><span class="line">从intChan读取了数据<span class="number">2</span></span><br><span class="line">从stringChan读取了数据hello4</span><br><span class="line">从intChan读取了数据<span class="number">3</span></span><br><span class="line">从intChan读取了数据<span class="number">4</span></span><br><span class="line">从intChan读取了数据<span class="number">5</span></span><br><span class="line">从intChan读取了数据<span class="number">6</span></span><br><span class="line">从intChan读取了数据<span class="number">7</span></span><br><span class="line">从intChan读取了数据<span class="number">8</span></span><br><span class="line">从intChan读取了数据<span class="number">9</span></span><br><span class="line">都取不到了，加入处理逻辑</span><br></pre></td></tr></table></figure></p>
<p>4、<strong>goroutine中使用recover，解决协程中出现panic</strong>，导致程序崩溃问题</p>
<ul>
<li><p>如果我们起了一个协程，但是这个协程出现了panic，如果我们没有捕获这个panic，就会造成成哥程序的崩溃，</p>
</li>
<li><p>这时可以在该协程中使用recover来捕获panic进行处理。这样即使这个协程发生问题，主线程仍然不受影响，继续执行。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数sayHello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;           </span><br><span class="line">        time.Sleep(time.Second)    </span><br><span class="line">        fmt.Println(<span class="string">"hello world"</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="comment">//这里使用defer+recover解决panic终止程序    </span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;           </span><br><span class="line">    <span class="comment">//捕获test抛出的panic         </span></span><br><span class="line">        <span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span> &#123;            </span><br><span class="line">              fmt.Println(<span class="string">"test() 发生错误"</span>)   </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个map  </span></span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>     </span><br><span class="line">    myMap[<span class="number">0</span>]=<span class="string">"golang"</span><span class="comment">//空map直接赋值，报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="keyword">go</span> sayHello()    </span><br><span class="line">    <span class="keyword">go</span> test()   <span class="comment">//这个协程会panic 使用defer+recover解决</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;       </span><br><span class="line">        time.Sleep(time.Second)       </span><br><span class="line">        fmt.Println(<span class="string">"main() ok="</span>,i)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">test() 发生错误</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">0</span></span><br><span class="line">main() ok= <span class="number">1</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">2</span></span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">3</span></span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">4</span></span><br><span class="line">main() ok= <span class="number">5</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">6</span></span><br><span class="line">main() ok= <span class="number">7</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">8</span></span><br><span class="line">main() ok= <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>由输出看出，test协程出错，但是主线程和sayHello协程继续执行</p>
<h3 id="4、反射"><a href="#4、反射" class="headerlink" title="4、反射"></a>4、反射</h3><h4 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、反射的作用：</p>
<ul>
<li><p>1）、反射可以在运行时动态获取变量的各种信息，如变量的类型（type）、类别（kind）</p>
</li>
<li><p>2）、如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段、方法）</p>
</li>
<li><p>3）、通过反射，可以修改变量的值，可以调用关联的方法</p>
</li>
<li><p>4）、使用反射，需要import（“reflect”）</p>
</li>
</ul>
<p>reflect实现了运行时反射，允许程序操作任意类型的对象，典型用法是用静态类型interface{}保存一个值，通过<strong>调用TypeOf获取类型信息</strong>，该函数返回一个Type类型值，<strong>调用ValueOf函数返回一个value类型值</strong>，该值代表运行时数据，Zero接受一个Type类型参数并返回该类型零值的value类型值。</p>
<ul>
<li>5）、反射示意图</li>
</ul>
<p><img src="/2020/06/11/go-goroutine、channel、反射/reflect1.png" alt="reflect1"></p>
<p><strong>reflect.Type是一个接口</strong>，定义了非常多方法，通过这些方法可以反向操作变量，获取变量的各种信息</p>
<p><strong>reflect.Value是一个结构体</strong>，包含了非常多方法，可通过Type()方法将Value转换为Type、返回变量的字段和方法等等</p>
<ul>
<li>6）、变量、interface{}和reflect.Value是可以相互转换的<br><img src="/2020/06/11/go-goroutine、channel、反射/reflect2.png" alt="reflect2"></li>
</ul>
<h4 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h4><p>1、对基本数据类型、interface{}、reflect.Value进行反射的基本操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (     </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//通过反射获取传入变量的type、kind、值     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、先获取到reflect.Type     </span></span><br><span class="line">    rTyp := reflect.TypeOf(b)     </span><br><span class="line">    fmt.Println(<span class="string">"rTyp="</span>,rTyp)     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取到reflect.Value     </span></span><br><span class="line">    rVal := reflect.ValueOf(b)<span class="comment">//rVal=100      </span></span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)     </span><br><span class="line">    <span class="comment">//n:=rVal+2 </span></span><br><span class="line">    <span class="comment">//error，rVal的类型不是int，是reflect.Value，不能做运算    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、如果要做运算，如下      </span></span><br><span class="line">    n:=rVal.Int()+<span class="number">2</span>     </span><br><span class="line">    fmt.Println(<span class="string">"n="</span>,n)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、将rval转成interface&#123;&#125;      </span></span><br><span class="line">    iv:=rVal.Interface()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、将interface&#123;&#125;通过断言转成int(对应的类型)    </span></span><br><span class="line">    num2:=iv.(<span class="keyword">int</span>)     </span><br><span class="line">    fmt.Printf(<span class="string">"num2=%v num2的type=%T\n"</span>,num2,num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//1、定义一个int     </span></span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span>     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、反射</span></span><br><span class="line">    reflectTest01(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rTyp= <span class="keyword">int</span></span><br><span class="line">rVal=<span class="number">100</span> rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">n= <span class="number">102</span></span><br><span class="line">num2=<span class="number">100</span> num2的<span class="keyword">type</span>=<span class="keyword">int</span></span><br></pre></td></tr></table></figure></p>
<p>2、对结构体、interface{}、reflect.Value进行反射的基本操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Name <span class="keyword">string</span>     </span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对结构体反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest02</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//通过反射获取传入变量的type、kind、值     </span></span><br><span class="line">    <span class="comment">//1、先获取到reflect.Type   </span></span><br><span class="line">    rTyp := reflect.TypeOf(b)    </span><br><span class="line">    fmt.Println(<span class="string">"rTyp="</span>,rTyp)   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取到reflect.Value     </span></span><br><span class="line">    rVal := reflect.ValueOf(b)   </span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、获取变量对应的kind，两种方式等价</span></span><br><span class="line">    <span class="comment">//(1)通过获取到的reflect.Type来获取 =》rTyp.Kind()</span></span><br><span class="line">    kind1:=rTyp.Kind()</span><br><span class="line">    <span class="comment">//(2)通过获取到的reflect.Value来获取 =》rVal.Kind()</span></span><br><span class="line">   kind2:=rVal.Kind()</span><br><span class="line">   fmt.Printf(<span class="string">"kind1=%v kind2=%v\n"</span>,kind1,kind2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、将rval转成interface&#123;&#125;     </span></span><br><span class="line">    iv:=rVal.Interface()     </span><br><span class="line">    fmt.Printf(<span class="string">"iv=%v iv的type=%T\n"</span>,iv,iv)  </span><br><span class="line">    <span class="comment">//输出：iv=&#123;tom 20&#125; iv的type=main.Student   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、iv的type=main.Student，但是通过iv取字段会报错     </span></span><br><span class="line">    <span class="comment">//iv.Name     </span></span><br><span class="line">    <span class="comment">//error 因为编译器在编译阶段无法知道iv的类型是main.Student，只有运行时才知道     </span></span><br><span class="line">    <span class="comment">//所以这里直接编译报错    </span></span><br><span class="line">    <span class="comment">//反射是在程序运行时工作的    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、将interface&#123;&#125;通过断言转成int(对应的类型)    </span></span><br><span class="line">    stu:=iv.(Student)    </span><br><span class="line">    <span class="keyword">if</span> ok &#123;     </span><br><span class="line">        fmt.Printf(<span class="string">"stu=%v stu的type=%T\n"</span>,stu,stu)    </span><br><span class="line">        fmt.Printf(<span class="string">"stu.Name=%v stu.Age=%v\n"</span>,stu.Name,stu.Age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//1、定义一个student实例   </span></span><br><span class="line">    stu:=Student&#123;<span class="string">"tom"</span>,<span class="number">20</span>&#125;     </span><br><span class="line">    <span class="comment">//2、反射   </span></span><br><span class="line">    reflectTest02(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rTyp= main.Student</span><br><span class="line">rVal=&#123;tom <span class="number">20</span>&#125; rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">kind1=<span class="keyword">struct</span> kind2=<span class="keyword">struct</span></span><br><span class="line">iv=&#123;tom <span class="number">20</span>&#125; iv的<span class="keyword">type</span>=main.Student</span><br><span class="line">stu=&#123;tom <span class="number">20</span>&#125; stu的<span class="keyword">type</span>=main.Student</span><br><span class="line">stu.Name=tom stu.Age=<span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h4><p>1、reflect.Value.Kind()，获取变量的类别，返回一个常量。type是一个大范畴，kind在type上细分（如type只返回int，kind返回具体的int32，int64的常量定义的值等）<br>在上面的例子中有：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、获取变量对应的kind，两种方式等价</span></span><br><span class="line">    <span class="comment">//(1)通过获取到的reflect.Type来获取 =》rTyp.Kind()</span></span><br><span class="line">    kind1:=rTyp.Kind()</span><br><span class="line">    <span class="comment">//(2)通过获取到的reflect.Value来获取 =》rVal.Kind()</span></span><br><span class="line">   kind2:=rVal.Kind()</span><br><span class="line">   fmt.Printf(<span class="string">"kind1=%v kind2=%v\n"</span>,kind1,kind2)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kind1=<span class="keyword">struct</span> kind2=<span class="keyword">struct</span></span><br></pre></td></tr></table></figure></p>
<p>2、Type和Kind的区别：Type是类型，Kind是类别，<strong>Type和Kind可能相同也可能不同</strong></p>
<ul>
<li>var num int = 10 num的Type是int，Kind也是int</li>
<li>var stu Student   stu的Type是<strong>包名.Student</strong>，Kind是struct</li>
</ul>
<p>3、变量、interface{}和reflect.Value是可以相互转换的</p>
<p>4、使用反射的方式来获取变量的值（并返回对应的类型），要求数据类型匹配，如x是int，那么就应该用reflect.ValueOf(x).Int()，不能使用其他，否则panic</p>
<p>5、通过反射修改变量的值，注意当使用SetXXX方法来修改变量的值，需要通过变量对应的指针来修改，这时需要使用reflect.Value.Elem()方法</p>
<ul>
<li><p>func (v Value) SetXXX(x XXX)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">SetXXX</span><span class="params">(x XXX)</span></span> </span><br><span class="line"><span class="comment">//SetXXX方法是和Value类型绑定的方法，不能用指针类型去调用它，只能把指针类型再转为Value类型，使用Elem函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>func (v Value) Elem() Value   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"> <span class="comment">//重点：Elem返回v持有的接口保管的值的Value类型封装，或持有的指针指向的值的Value类型封装</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line"><span class="string">"fmt"</span>    </span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改反射变量的值    </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;    </span><br><span class="line">    <span class="comment">//1、获取到reflect.Value  </span></span><br><span class="line">    rVal := reflect.ValueOf(b)<span class="comment">//rVal=100    </span></span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)  </span><br><span class="line">    <span class="comment">//main函数中调用函数时传的是地址，rVal的值为一个地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取rVal的Kind    </span></span><br><span class="line">    rKind:=rVal.Kind()  </span><br><span class="line">    fmt.Printf(<span class="string">"rVal Kind=%v\n"</span>,rKind)   </span><br><span class="line">    <span class="comment">//输出：rVal Kind=ptr，</span></span><br><span class="line">    <span class="comment">//rVal的Kind是指针，因为main函数中调用函数时传的是地址     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、通过SetXXX修改变量的值    </span></span><br><span class="line">    <span class="comment">//rVal.SetInt(20) //error   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//func (v Value) SetXXX(x XXX)，  </span></span><br><span class="line">    <span class="comment">//SetXXX方法是和Value类型绑定的方法，不能用指针类型去调用它    </span></span><br><span class="line">    <span class="comment">//只能把指针类型再转为Value类型，使用Elem函数    </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//func (v Value) Elem() Value   </span></span><br><span class="line">    <span class="comment">//Elem返回v持有的接口保管的值的Value类型封装，或持有的指针指向的值的Value类型封装     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、通过Elem()获取到指针指向的值，再通过SetXXX修改变量的值     </span></span><br><span class="line">    rVal.Elem().SetInt(<span class="number">20</span>)    <span class="comment">//值修改为20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;     </span><br><span class="line">    <span class="comment">//1、定义一个int    </span></span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span>     </span><br><span class="line">    <span class="comment">//2、反射    </span></span><br><span class="line">    reflectTest01(&amp;num)<span class="comment">//修改变量num的值，所以要穿num的地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、打印修改后的num</span></span><br><span class="line">    fmt.Println(<span class="string">"num="</span>,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rVal=<span class="number">0xc000060058</span> rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">rVal Kind=ptr</span><br><span class="line">num= <span class="number">20</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/" data-id="ckcivu88l000ra0vinhi3wdom" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go-文件操作、json" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-文件操作、json/" class="article-date">
  <time datetime="2020-06-11T07:54:54.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/go-文件操作、json/">go:文件操作、json</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、文件操作"><a href="#1、文件操作" class="headerlink" title="1、文件操作"></a>1、文件操作</h3><h4 id="1、基本认识"><a href="#1、基本认识" class="headerlink" title="1、基本认识"></a>1、基本认识</h4><p>1、文件在程序中是以 <strong>流</strong> 的形式来操作的</p>
<ul>
<li>流：数据在数据源（文件）和程序（内存）之间经历的路径</li>
<li>输入流：数据从数据源（文件）到程序（内存）之间的路径</li>
<li>输出流：数据从程序（内存）到数据源（文件）之间的路径</li>
</ul>
<p><img src="/2020/06/11/go-文件操作、json/file1.png" alt="file1"></p>
<p>2、GO中，os.File封装所有文件相关操作（方法），File是一个结构体</p>
<p>3、<strong>文件是引用类型</strong></p>
<h4 id="2、文件操作"><a href="#2、文件操作" class="headerlink" title="2、文件操作"></a>2、文件操作</h4><h5 id="1、打开文件"><a href="#1、打开文件" class="headerlink" title="1、打开文件"></a>1、打开文件</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(file *File,err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Open打开一个文件用于读取，如果操作成功，返回一个文件对象（结构体指针或者文件句柄）可用于读取数据；如果出错，错误底层类型是PathError</p>
<h5 id="2、关闭文件"><a href="#2、关闭文件" class="headerlink" title="2、关闭文件"></a>2、关闭文件</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File )</span> <span class="title">Close</span> <span class="params">(error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Close关闭文件f，用于读取，使文件不能用于读写。返回可能出现的错误</p>
<p>案例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.Open(<span class="string">"d:/test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出文件</span></span><br><span class="line">    fmt.Printf(<span class="string">"file=%v"</span>,file)<span class="comment">//输出 file=&amp;&lt;0xcXXXXXXXX&gt;，</span></span><br><span class="line">    <span class="comment">//看出文件是一个地址（指针）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    err = file.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"close file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3、读文件操作应用实例"><a href="#3、读文件操作应用实例" class="headerlink" title="3、读文件操作应用实例"></a>3、读文件操作应用实例</h5><p>1、读取文件的内容并显示在终端（<strong>带缓冲区</strong>的方式）<br>os.Open()、 file.Close()、bufio.NewReader()<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.Open(<span class="string">"d:/test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当函数退出时，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个 *Reader，是带缓冲的</span></span><br><span class="line">    <span class="comment">//默认缓冲4096个字节</span></span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环读取文件的内容</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        str ,err :=  reader.ReadString(<span class="string">"\n"</span>)<span class="comment">//读到一个换行就结束一次</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;<span class="comment">//io.EOF表示文件的末尾</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//输出内容</span></span><br><span class="line">         fmt.Print(str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件读取结束</span></span><br><span class="line">     fmt.Println(<span class="string">"文件读取结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、读取文件的内容并显示在终端（使用ioutil一次性将整个文件读入到内存中），这种方式适合文件不大的情况 。</p>
<ul>
<li>这种方式不用显示的Open和Close文件，因为文件的Open和Close被封装到ReadFile函数内部</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file = <span class="string">"d:/test.txt"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用ioutil.ReadFile一次性将文件读取完</span></span><br><span class="line">    content,err := ioutil.ReadFile(file)<span class="comment">//返回一个[]byte（byt切片）</span></span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"read file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把读取的文件内容显示到终端</span></span><br><span class="line">    fmt.Printf(<span class="string">"content=%v"</span>,content)<span class="comment">//这是一个[]byte</span></span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">"content=%v"</span>,<span class="keyword">string</span>(content))<span class="comment">//[]byte转成string输出</span></span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4、写文件操作应用实例"><a href="#4、写文件操作应用实例" class="headerlink" title="4、写文件操作应用实例"></a>4、写文件操作应用实例</h5><p>1、基本介绍<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(path <span class="keyword">string</span>,flag <span class="keyword">int</span>,perm FileMode)</span> <span class="params">(file *File,err error)</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>path：要打开文件的路径</li>
<li>flag：打开文件的方式</li>
<li>perm：文件权限，Windows系统下无效，Unix和Linux下有效</li>
</ul>
<h6 id="1、实例一"><a href="#1、实例一" class="headerlink" title="1、实例一"></a>1、实例一</h6><p> 带缓冲bufio.NewWriter</p>
<p>1）创建一个<strong>新文件</strong>，<strong>写入</strong>内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_WRONLY | os.O_CREATE,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以只写方式打开，如果没有文件就创建一个，如果有就继续往下</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入内容</span></span><br><span class="line">    str := <span class="string">"要写入的内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2）打开一个<strong>已经存在</strong>的文件，将原来的内容<strong>覆盖</strong>成新的内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_WRONLY | os.O_TRUNC,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以只写方式打开，如果文件已经有内容就清空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入要覆盖的新内容</span></span><br><span class="line">    str := <span class="string">"写入要覆盖的新内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3）打开一个<strong>已经存在</strong>的文件，在原来的内容<strong>追加</strong>新的内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_WRONLY | os.O_APPEND,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以只写方式打开，在文件末尾以追加的形式写入内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入要追加写入的新内容</span></span><br><span class="line">    str := <span class="string">"追加写入的新内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4）打开一个已经存在的文件，将原来的内容<strong>读出</strong>显示在终端，并<strong>追加</strong>新的内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_RDWR | os.O_APPEND,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以读写方式打开，在文件末尾以追加的形式写入内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先读取文件原来的内容，并显示在终端</span></span><br><span class="line">     <span class="comment">//创建一个 *Reader，是带缓冲的</span></span><br><span class="line">    <span class="comment">//默认缓冲4096个字节</span></span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环读取文件的内容</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        str ,err :=  reader.ReadString(<span class="string">"\n"</span>)<span class="comment">//读到一个换行就结束一次</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;<span class="comment">//io.EOF表示文件的末尾</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//输出内容，显示在终端</span></span><br><span class="line">         fmt.Print(str)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入要追加写入的新内容</span></span><br><span class="line">    str := <span class="string">"第二次追加写入的新内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="2、实例二"><a href="#2、实例二" class="headerlink" title="2、实例二"></a>2、实例二</h6><p>将一个文件的内容，写入到另外一个文件。（两个文件已经存在）<br>ioutil.ReadFile/ioutil.WriteFile<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将”d:/test.txt“文件内容导入到”e:/kkk.txt“</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1、将”d:/test.txt“文件内容读取到内存</span></span><br><span class="line">    <span class="comment">//2、将读取到的内容写入”e:/kkk.txt“</span></span><br><span class="line">    </span><br><span class="line">      file1Path = <span class="string">"d:/test.txt"</span></span><br><span class="line">      file2Path = <span class="string">"e:/kkk.txt"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用ioutil.ReadFile一次性将文件读取完</span></span><br><span class="line">    data,err := ioutil.ReadFile(file1Path)<span class="comment">//返回一个[]byte（byt切片）</span></span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"read file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把读取的文件内容显写入e:/kkk.txt文件</span></span><br><span class="line">    err = ioutil.WriteFile(file2Path,data,<span class="number">0666</span>)<span class="comment">//data接收一个[]byte</span></span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"write file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5、判断文件或文件夹是否存在"><a href="#5、判断文件或文件夹是否存在" class="headerlink" title="5、判断文件或文件夹是否存在"></a>5、判断文件或文件夹是否存在</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(filePath <span class="keyword">string</span>)</span> <span class="params">(fi FileInfo,err error)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果返回的error为nil，说明文件或文件夹存在</li>
<li>如果返回的error使用为os.IsNotExist判断为true，说明文件或文件夹不存在</li>
<li>如果返回的error为其他类型，则不确定是否存在</li>
</ul>
<h3 id="2、json"><a href="#2、json" class="headerlink" title="2、json"></a>2、json</h3><p>1、JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。易于人阅读和编写，也易于机器解析和生成，并有效提升网络效率。</p>
<p>2、json序列化（如struct、map、slice序列化成json字符串）<br>json.Marshal()序列化后是一个[]byte，要转string<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span>    </span><br><span class="line">    Birthday  <span class="keyword">string</span>    </span><br><span class="line">    Sal <span class="keyword">float64</span>    </span><br><span class="line">    Skill <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monster := Monster&#123;</span><br><span class="line">        Name:<span class="string">"牛魔王"</span>,            </span><br><span class="line">        Age:<span class="number">500</span>,            </span><br><span class="line">        Birthday:<span class="string">"2011-11-11"</span>,           </span><br><span class="line">        Sal:<span class="number">8000.0</span>,            </span><br><span class="line">        Skill:<span class="string">"牛魔拳"</span>,      </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line"><span class="comment">//将monster序列化     </span></span><br><span class="line">data,err:=json.Marshal(&amp;monster)      </span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;            </span><br><span class="line">    fmt.Printf(<span class="string">"序列化失败 err=%v\n"</span>,err)     </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出序列化后的结果     </span></span><br><span class="line">    <span class="comment">//json.Marshal(&amp;monster)序列化后是一个[]byte，要转string      </span></span><br><span class="line">    fmt.Printf(<span class="string">"序列化后的结果monster=%v"</span>,<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testStruct()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序列化后的结果monster=&#123;<span class="string">"Name"</span>:<span class="string">"牛魔王"</span>,<span class="string">"Age"</span>:<span class="number">500</span>,<span class="string">"Birthday"</span>:<span class="string">"2011-11-11"</span>,<span class="string">"Sal"</span>:<span class="number">8000</span>,<span class="string">"Skill"</span>:<span class="string">"牛魔拳"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：也可以对基本数据类型进行序列化，序列化结果直接将基本数据类型转成string，但是对基本数据类型进行序列化一般没有意义。</p>
<p>3、json反序列化（如将json反序列化成struct、map、slice）<br>json.Unmarshal([]byte(str),&amp;monster)第一个参数要传一个[]byte<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span> </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span>    </span><br><span class="line">    Age <span class="keyword">int</span>    </span><br><span class="line">    Birthday  <span class="keyword">string</span>     </span><br><span class="line">    Sal <span class="keyword">float64</span>    </span><br><span class="line">    Skill <span class="keyword">string</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unSerialStruct</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    str:=<span class="string">"&#123;\"Name\":\"牛魔王\",\"Age\":500,\"Birthday\":\"2011-11-11\","</span> +            <span class="string">"\"Sal\":8000,\"Skill\":\"牛魔拳\"&#125;"</span>     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个Monster实例      </span></span><br><span class="line">    <span class="keyword">var</span> monster Monster      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//json.Unmarshal([]byte(str),&amp;monster)第一个参数要传一个[]byte     </span></span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str),&amp;monster)</span><br><span class="line">    <span class="comment">//传地址才能改变var monster的值</span></span><br><span class="line">      <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123; </span><br><span class="line">         fmt.Printf(<span class="string">"反序列化失败 err=%v\n"</span>,err)    </span><br><span class="line">      &#125;      </span><br><span class="line">      </span><br><span class="line">      fmt.Printf(<span class="string">"反序列化后的结果monster=%v"</span>,monster)</span><br><span class="line"> &#125;</span><br><span class="line">      </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">        unSerialStruct()  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反序列化后的结果monster=&#123;牛魔王 <span class="number">500</span> <span class="number">2011</span><span class="number">-11</span><span class="number">-11</span> <span class="number">8000</span> 牛魔拳&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-文件操作、json/" data-id="ckcivu88m000sa0vilihlgi9q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/" class="article-date">
  <time datetime="2020-06-11T07:35:04.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/">go:结构体、方法、工厂模式、OOP三大特性、类型断言、接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="面向对象-结构体"><a href="#面向对象-结构体" class="headerlink" title="面向对象-结构体"></a>面向对象-结构体</h3><p>1、GO支持面向对象编程（OOP），但不是纯粹的面向对象编程语言，更准确地说是<strong>GO支持面向对象编程特性</strong><br>2、GO没有类的概念，结构体（struct）来实现OOP<br>3、GO面向对象编程非常简洁，去掉传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等<br>4、Go仍然有面向对象编程的继承、封装和多态的特性，只是实现方式不一样。<br>5、GO面向对象（OOP）很优雅，OOP本身就是语言类型系统的一部分（Go天然支持OOP），通过接口（interface）关联，耦合性低，非常灵活。<br>6、GO更准确的说是<strong>面向接口编程</strong></p>
<h5 id="1、结构体变量在内存中的布局"><a href="#1、结构体变量在内存中的布局" class="headerlink" title="1、结构体变量在内存中的布局"></a>1、结构体变量在内存中的布局</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Color <span class="keyword">string</span></span><br><span class="line">    Hobby <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个结构体cat变量</span></span><br><span class="line">vat cat1 Cat</span><br><span class="line">cat.Name = <span class="string">"小白"</span></span><br><span class="line">cat.Age = <span class="number">3</span></span><br><span class="line">cat.Color = <span class="string">"白色"</span></span><br><span class="line">cat.Hobby = <span class="string">"吃鱼"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"cat1="</span>,cat1)</span><br></pre></td></tr></table></figure>
<p>结构体是自定义的数据类型(如Cat)，结构体变量（实例）是具体的、实际的一个变量(如cat1)</p>
<p>结构体实例在内存中的布局，以cat1为例<br>1、当代码执行到“var cat1 Cat”时，cat1指向一个结构体，这时还没有给结构体的各个字段赋值，所以各个字段为默认值<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/struct1.jpg" alt="struct1"></p>
<p>2、结构体有一个自己的地址，cat1直接指向一个结构体的数据空间，而不是结构体的地址，所以<strong>结构体是值类型</strong></p>
<p>3、赋值语句为结构体的字段赋值<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/struct2.jpg" alt="struct2"></p>
<p>总结：</p>
<ul>
<li>当我们声明一个结构体变量时，结构体的数据空间已经有了，且结构体的每个字段已有<strong>默认值</strong></li>
<li>声明结构体变量后，该变量指向一个结构体的数据空间，而不是该结构体数据空间的地址，所以结构体是<strong>值类型</strong></li>
</ul>
<h5 id="2、结构体声明"><a href="#2、结构体声明" class="headerlink" title="2、结构体声明"></a>2、结构体声明</h5><p>1、在创建一个变量后，如果没有给字段赋值，系统会赋零值</p>
<ul>
<li>基本数据类型赋零值</li>
<li><strong>引用类型：slice、map、指针的零值是nil，即没有分配内存空间</strong></li>
<li>数组类型的默认值与元素相关</li>
</ul>
<p>2、不同结构体变量的字段你是独立的，互不影响。因为结构体是值类型、默认是值拷贝</p>
<h5 id="3、创建结构体实例的4种方式"><a href="#3、创建结构体实例的4种方式" class="headerlink" title="3、创建结构体实例的4种方式"></a>3、创建结构体实例的4种方式</h5><p>1、直接声明<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vat person Person</span><br><span class="line">person.field1 = value1</span><br><span class="line">person.field2 = value2</span><br><span class="line">person.field3 = value3</span><br></pre></td></tr></table></figure></p>
<p>2、声明时直接为字段赋值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vat person Person = Person&#123;</span><br><span class="line">    field1:value1</span><br><span class="line">    field2:value2</span><br><span class="line">    field3:value3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、通过new函数创建，创建对象是一个指向该结构体的指针<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vat person *Person = <span class="built_in">new</span>(Person)</span><br><span class="line"><span class="comment">//person是一个指针，标准赋值方式如下</span></span><br><span class="line">(*person).field1 = value1  </span><br><span class="line">(*person).field2 = value2</span><br><span class="line">(*person).field3 = value3</span><br><span class="line"><span class="comment">//运算符优先级："." &gt; "*"，所以需要括号(*person).field1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可简写为</span></span><br><span class="line">person.field1 = value1</span><br><span class="line">person.field2 = value2</span><br><span class="line">person.field3 = value3</span><br><span class="line"></span><br><span class="line"><span class="comment">//GO的设计者为了使用方便，底层会对简写写法person.field1 = value1进行处理，会给person加上取值运算 (*person).field1 = value1</span></span><br></pre></td></tr></table></figure></p>
<p>4、vat person *Person = &amp;Person{}，可以直接再{}中赋值，如方式2，也可如下赋值，如方式3<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    vat person *Person = &amp;Person&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person是一个指针，标准赋值方式如下</span></span><br><span class="line">    (*person).field1 = value1</span><br><span class="line">    (*person).field2 = value2</span><br><span class="line">    (*person).field3 = value3</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可简写为</span></span><br><span class="line">    person.field1 = value1</span><br><span class="line">    person.field2 = value2</span><br><span class="line">    person.field3 = value3</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GO的设计者为了使用方便，底层会对简写写法person.field1 = value1进行处理，会给person加上取值运算 (*person).field1 = value1</span></span><br></pre></td></tr></table></figure></p>
<p>总结:</p>
<ul>
<li>方式3和方式4返回的是一个<strong>结构体指针</strong></li>
</ul>
<h5 id="4、结构体内细节"><a href="#4、结构体内细节" class="headerlink" title="4、结构体内细节"></a>4、结构体内细节</h5><p>1、<strong>结构体中所有字段在内存中是连续分布的</strong><br>2、当结构体的字段是指针时，指针本身的地址是连续的，但是指针指向的地址指值不一定连续<br>3、结构体使用户单独定义的类型，和其它类型转换时，需要有完全相同的字段（名字、个数和累型）<br>4、结构体进行type重新定义（相当于取别名），Go认为是<strong>新的数据类型</strong>，但是相互间可以强转<br>5、在结构体的每个字段上，可以写上一个<strong>tag</strong>，该tag可以通过<strong>反射机制</strong>获取，常见的使用场景就是<strong>序列化</strong>和<strong>反序列化</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age <span class="keyword">int</span> <span class="string">`json:"age"`</span></span><br><span class="line">    Skill <span class="keyword">string</span> <span class="string">`json:"skill"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">monster := Monster&#123;</span><br><span class="line">    <span class="string">"牛魔王"</span>，</span><br><span class="line">    <span class="number">500</span>，</span><br><span class="line">    “牛头拳”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将monster变量序列化为json字符串（反射机制）</span></span><br><span class="line">jsonStr,err := json.Marshal(monster)<span class="comment">//返回值为[]byte切片</span></span><br><span class="line"><span class="comment">//这里json包去访问monster中的字段，如果字段小写则访问不到，字段小写表示只能当前包内访问，则只能大写。但是大写，json格式化后json串中也是大写，与前端命名习惯不一致，所以可以用tag为字段取别名成小写形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"json处理错误"</span>，err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"jsonStr"</span>,<span class="keyword">string</span>(jsonStr))</span><br></pre></td></tr></table></figure></p>
<h3 id="方法method"><a href="#方法method" class="headerlink" title="方法method"></a>方法method</h3><p>1、Go中方法是<strong>作用在指定的数据类型上</strong>的（和指定数据类型绑定），因此自定义类型，都可以有方法（不仅是struct）。</p>
<p>2、方法的声明与调用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="comment">//A结构体有一个方法test，说明test方法和结构体（类型）A绑定，test方法只能被A的对象来调用</span></span><br><span class="line"></span><br><span class="line">    a.Num=<span class="number">2</span> <span class="comment">//这里的改变不会影响main函数中的赋值输出，因为struct是值类型，func (a A)这里不是指针。</span></span><br><span class="line">    fmt.Println(a.Num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a A </span><br><span class="line">    a.Num=<span class="number">1</span></span><br><span class="line">    a.test()<span class="comment">//调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   由上述代码有：</p>
<ul>
<li>1、test方法和A类型绑定</li>
<li>2、test方法只能通过A的实例来调用，<strong>不能直接调用</strong>，也不能用其他类型调用</li>
<li><strong>3</strong>、func (a A) test()，<strong>a表示哪个A实例调用，他就是该实例的副本</strong>，和函数传参类似，由于<strong>struct是值类型</strong>，func (a A)这里不是指针，所以方法中对字段重新赋值不会影响main函数中的值</li>
</ul>
<h4 id="方法的调用和传参机制"><a href="#方法的调用和传参机制" class="headerlink" title="方法的调用和传参机制"></a>方法的调用和传参机制</h4><p><strong>重点</strong>：方法的调用和传参机制和函数基本一样，不一样的地方是方法调用时，<strong>会将调用方法的实例变量，当作实参也传递给方法</strong></p>
<p>示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">getSum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p Person </span><br><span class="line">    p.Name = <span class="string">"tom"</span></span><br><span class="line">    </span><br><span class="line">    n1 := <span class="number">10</span></span><br><span class="line">    n2 := <span class="number">20</span></span><br><span class="line">    res := p.getSum(n1,n2)<span class="comment">//调用方法</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1、main函数中执行“n1 := 10 n2 := 20”时，内存中开辟main栈并压入变量n1和n2<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method1.png" alt="method1"></p>
<p>2、main函数执行 “ res := p.getSum(n1,n2)”时：</p>
<ul>
<li>先执行“p.getSum(n1,n2)”，内存中开辟getSum栈，并将n1和n2的值拷贝到getSum栈中，同时将结构体实例p值拷贝到getSum栈中（因为结构体实例p调用方法getSum），因为这里传的是“func (p Person)”，所以是值拷贝，所以main栈和getSum栈是完全独立的数据空间。若传指针则为引用传递<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method2.png" alt="method2"></li>
</ul>
<ul>
<li>然后执行赋值给res变量“res := p.getSum(n1,n2)”，main栈中压入res变量，res变量的值有函数getSum返回<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method3.png" alt="method3"></li>
</ul>
<p>注意：<strong>如果一个类型（结构体）实现了String()这个方法，fmt.Println默认会调用这个结构体变量的String()方法输出</strong></p>
<h4 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h4><p>1、调用方式不一样</p>
<ul>
<li>函数的调用方式：函数名（实参列表）</li>
<li>方法的调用方式：绑定类型变量.方法名（实参列表）</li>
</ul>
<p>2、对于普通函数，接收者为值类型时，不能将指针类型数据直接传递，反之亦然</p>
<p>3、对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反之亦然<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">       Name <span class="keyword">string</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">       p.Name = <span class="string">"jack"</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//jack</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">test01</span><span class="params">()</span></span> &#123;</span><br><span class="line">       p.Name = <span class="string">"marry"</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//marry</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">var</span> p Person </span><br><span class="line">       p.Name = <span class="string">"tom"</span></span><br><span class="line">       </span><br><span class="line">       p.test() <span class="comment">//ok</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//tom</span></span><br><span class="line">       </span><br><span class="line">       (&amp;p).test()  <span class="comment">//用p的地址（指针）调也可以，但仍然是值拷贝，只是形式上看是引用拷贝，但是接受的地方“func (p Person)”是传值，所以底层会处理为“p.test()”，只有接受的地方为传地址（如 func (p *Person)），才是引用传递</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//tom</span></span><br><span class="line">       </span><br><span class="line">       (&amp;p).test01()<span class="comment">//ok</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name)<span class="comment">//marry</span></span><br><span class="line">       </span><br><span class="line">       p.test01()<span class="comment">//ok，等价于(&amp;p).test01()，底层处理，形式上传值，实际传地址，因为接受的地方为传地址（如 func (p *Person)）</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name)<span class="comment">//marry </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>针对第3条总结</strong>：<strong>重点重点</strong><br>不管调用的形式如何，真正决定是值拷贝还是地址拷贝，看定义这个方法时跟哪个类型绑定，若跟指针（如 p *Person）绑定则为地址拷贝，若跟值类型（如 p Person）绑定则为值拷贝</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>1、GO的结构体没有<strong>构造函数</strong>，通常使用工厂模式来解决</p>
<ul>
<li>使用工厂模式实现跨包创建结构体实例</li>
</ul>
<p>1）model包下有结构体Student<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model </span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> student <span class="keyword">struct</span>&#123;</span><br><span class="line"> <span class="comment">//这里结构体定义为小写student，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Score <span class="keyword">float64</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//使用工厂模式</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>,score <span class="keyword">float64</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">          Name : name,</span><br><span class="line">          Score : score,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>2）main包下使用工厂模式创建结构体student实例<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"factory/model"</span></span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用工厂模式创建student实例</span></span><br><span class="line">    <span class="keyword">var</span> stu = model.NewStudent(<span class="string">"tom"</span>,<span class="number">88.8</span>)<span class="comment">//返回值为一个指针</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu) <span class="comment">//输出&amp;&#123;tom 88.8&#125;</span></span><br><span class="line">   fmt.Println(*stu) <span class="comment">//输出&#123;tom 88.8&#125;</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu.Name) <span class="comment">//等价于(*stu).Name 输出tom</span></span><br><span class="line">   fmt.Println(stu.Score) <span class="comment">//等价于(*stu).Score 输出88.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果结构体中的字段也是小写，只能在定义结构体的包中使用，其他包不可访问，同理可以为结构体绑定一个公有方法，用于返回字段<br>1）model包下有结构体Student<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model </span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> student <span class="keyword">struct</span>&#123;</span><br><span class="line"> <span class="comment">//这里结构体定义为小写student，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        score <span class="keyword">float64</span></span><br><span class="line"> <span class="comment">//这里字段score定义为小写，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//使用工厂模式</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>,score <span class="keyword">float64</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">          Name : name,</span><br><span class="line">          score : score,<span class="comment">//该包内可以访问小写字段，其他包不可以</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//GetScore方法绑定结构体，返回字段score</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">GetScore</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.score</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2）main包下使用工厂模式创建结构体student实例<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"factory/model"</span></span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用工厂模式创建student实例</span></span><br><span class="line">    <span class="keyword">var</span> stu = model.NewStudent(<span class="string">"tom"</span>,<span class="number">88.8</span>)<span class="comment">//返回值为一个指针</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu) <span class="comment">//输出&amp;&#123;tom 88.8&#125;</span></span><br><span class="line">   fmt.Println(*stu) <span class="comment">//输出&#123;tom 88.8&#125;</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu.Name) <span class="comment">//等价于(*stu).Name 输出tom</span></span><br><span class="line">   fmt.Println(stu.GetScore()) <span class="comment">//输出88.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="面向对象编程三大特性"><a href="#面向对象编程三大特性" class="headerlink" title="面向对象编程三大特性"></a>面向对象编程三大特性</h3><p>面向对象编程三大特性：<strong>封装、继承、多态</strong>。</p>
<h4 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h4><p>1、封装：把<strong>抽象出来的字段和对字段的操作封装在一起</strong>，数据就被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作</p>
<p>2、封装的优点</p>
<ul>
<li>隐藏实现的细节</li>
<li>提供方法可以对数据进行验证、保证安全合理</li>
</ul>
<p>3、如何体现封装</p>
<ul>
<li>对结构体中的属性进行封装</li>
<li>通过方法、包实现封装</li>
</ul>
<p>4、封装的实现<br>参考上一个笔记，工厂模式（将结构体、属性定义为包私有，通过公有方法访问）</p>
<h4 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h4><p>继承可以<strong>解决代码复用</strong>，提高扩展性、可维护性<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/oop1.jpg" alt="oop1"><br>GO使用在一个结构体中<strong>嵌套匿名结构体</strong>的方式来实现继承<br>案例：<br>1、抽取共有字段和方法，创建一个结构体Student<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">      Name <span class="keyword">string</span></span><br><span class="line">      Age <span class="keyword">int</span></span><br><span class="line">      Score <span class="keyword">float64</span>     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//共有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">ShowInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"学生名=%v年龄=%v 成绩=%v           \n"</span>,stu.Name,stu.Age,stu.Score)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">SetScore</span><span class="params">(score <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">       stu.Score = score</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>2、创建结构体Pupil<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pupil <span class="keyword">struct</span>&#123;</span><br><span class="line">      Student    <span class="comment">//嵌入Student匿名结构体</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Pupil特有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(p *Pupil)</span> <span class="title">testing</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"小学生正在考试中"</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>3、创建结构体Graduate<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Graduate <span class="keyword">struct</span>&#123;</span><br><span class="line">      Student    <span class="comment">//嵌入Student匿名结构体</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Graduate特有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(g *Graduate)</span> <span class="title">testing</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"大学生正在考试中"</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>4、main创建实例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//当我们对结构体嵌入了匿名结构体后，使用方法发生了变化</span></span><br><span class="line">     <span class="comment">//创建一个Pupil实例</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Student.Name = <span class="string">"tom"</span></span><br><span class="line">     pupil.Student.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.Student.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//创建一个Graduate实例</span></span><br><span class="line">     graduate := &amp;Graduate&#123;&#125;</span><br><span class="line">     graduate.Student.Name = <span class="string">"marry"</span></span><br><span class="line">     graduate.Student.Age = <span class="number">8</span></span><br><span class="line">     graduate.testing()</span><br><span class="line">     graduate.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     graduate.Student.ShowInfo()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="继承细节"><a href="#继承细节" class="headerlink" title="继承细节"></a>继承细节</h5><p>1、结构体可以使用嵌套匿名结构体的<strong>所有字段和方法</strong>，即：首字母大写和小写的字段和方法都可以使用</p>
<p>2、访问匿名结构体字段可以简化<br>在上述案例中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//当我们对结构体嵌入了匿名结构体后，使用方法发生了变化</span></span><br><span class="line">     <span class="comment">//创建一个Pupil实例</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Student.Name = <span class="string">"tom"</span></span><br><span class="line">     pupil.Student.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.Student.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//创建Pupil实例，访问Pupil结构体中的匿名结构体Student的字段和方法可以简化为</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Name = <span class="string">"tom"</span></span><br><span class="line">     pupi.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//pupil.Student.Name = "tom" 等价于pupil.Name = "tom"，</span></span><br><span class="line">    <span class="comment">// pupil.Name 先去pupil找Name字段，如果没有，再去Pupil结构体中的匿名结构体Student找字段Name</span></span><br><span class="line">    <span class="comment">//如果找到则访问，否则报错</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>3、当结构体和匿名结构体有相同的字段或方法时，编译器采用<strong>就近访问原则</strong>访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体来区分<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">SayOk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"A SayOK"</span>,a.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"A hello"</span>,a.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    A</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SayOk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"b SayOK"</span>,b.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    </span><br><span class="line">    b.Name = <span class="string">"jack"</span><span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//去结构体B中找字段Name，找到并赋值jack，则b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.SayOK() <span class="comment">//b SayOK jack</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法SayOK ，找到并执行fmt.Println("b SayOK",b.Name)，这里b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.hello() <span class="comment">//A hello ""空串</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法hello，没有找到，再去匿名结构体A中找，找到并执行fmt.Println("A hello"，a.Name)，前面的语句并没有为a.Name赋值，则为默认值空串，a.Name就近等于空串</span></span><br><span class="line">    </span><br><span class="line">    b.A.Name = <span class="string">"tom"</span><span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//去结构体B的匿名结构体A中找字段Name，找到并赋值tom，则b.Name= "tom"</span></span><br><span class="line">    </span><br><span class="line">    b.SayOK() <span class="comment">//b SayOK jack</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法SayOK ，找到并执行fmt.Println("b SayOK",b.Name)，这里b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.A.SayOK() <span class="comment">//A SayOK tom</span></span><br><span class="line">    <span class="comment">//去结构体B的匿名结构体A中找方法SayOK ，找到并执行fmt.Println("A hello",a.Name)，这里a.Name= "tom"</span></span><br><span class="line">    </span><br><span class="line">    b.hello() <span class="comment">//A hello tom</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法hello，没有找到，再去匿名结构体A中找，找到并执行fmt.Println("A hello"，a.Name)，前面的语句为a.Name赋值tom，则a.Name就近等于tom</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、当结构体嵌入两个（或多个）匿名结构体，如<strong>两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的字段和方法）</strong>，在访问时，就必须要明确指定匿名结构体的名字，否则编译报错</p>
<p>5、如果一个struct嵌套了一个有名字的结构体，这种模式就是<strong>组合</strong>，如果是组合关系，那么在访问组合的结构体的字段和方法时，就必须带上结构体的名字，<strong>不能简写</strong>。<br>Go中层级关系明确，如果是组合关系，例：一个结构体A嵌套了一个有名结构体B，B的名字为b,B有字段Name，现创建A的实例a,访问字段Name时，只能a.b.Name，不能a.Name，编译器会报错。看到a.Name时，编译器会去A中找字段Name，没有就立马报错（嵌套匿名结构体时会继续在匿名结构体中找）</p>
<p>6、嵌套匿名结构体后，也可以创建结构体变量时，直接指定各个匿名结构体字段的值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pupil := &amp;Pupil&#123;Student&#123;<span class="string">"tom"</span>，<span class="number">15</span>，<span class="number">78.5</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">pupil := &amp;Pupil&#123;</span><br><span class="line">    Student&#123;</span><br><span class="line">        Name:<span class="string">"tom"</span>，</span><br><span class="line">        Age:<span class="number">15</span>，</span><br><span class="line">        Score:<span class="number">78.5</span>，</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>7、在结构体中嵌入匿名结构体时，也可以直接嵌入匿名结构体的指针，这样效率更高</p>
<p>8、在结构体中嵌入匿名结构体时，也可以直接嵌入匿名基本数据类型。<br>如嵌入匿名int，访问时直接通过 “外层结构体实例名.int = 20”这种形式。但是不能同时侵入两个同样的匿名基本数据类型，因为无法区分，如嵌入两个匿名int，这是不允许的。</p>
<h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>一个struct嵌套了多个匿名结构体，那么该结构体可以直接访问所有嵌套的匿名结构体的字段和方法，从而实现多重继承<br>1、当结构体嵌入两个（或多个）匿名结构体，如<strong>两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的字段和方法）</strong>，在访问时，就必须要明确指定匿名结构体的名字，否则编译报错</p>
<p>2、为了代码简洁性，建议尽量不适用多重继承</p>
<h4 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a>3、多态</h4><h5 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、变量（实例）具有多种形态，在GO中，多态特征是通过接口实现的。可以按照统一的接口来调用不同的实现，这时<strong>接口变量就呈现不同的形态</strong>。<br>案例说明：<br>1、定义一个接口Usb<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span>&#123;</span><br><span class="line">    <span class="comment">//声明两个没有实现的方法</span></span><br><span class="line">    Start()</span><br><span class="line">    Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、定义一个结构体Phone<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">type</span> Stu <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让Phone实现接口Usb的所有方法，即实现了接口Usb</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机开始工作。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机停止工作。。。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、再定义一个结构体Camera<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> Stu Camera&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//让Camera实现接口Usb的所有方法，即实现了接口Usb</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">     fmt.Println(<span class="string">"相机开始工作。。。"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">     fmt.Println(<span class="string">"相机停止工作。。。"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>4、再定义一个结构体Computer<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu Computer&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个方法Working，接收一个Usb接口类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">Working</span><span class="params">(usb Usb)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过usb接口变量来调用Start和Stop方法</span></span><br><span class="line">    usb.Start()</span><br><span class="line">    usb.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5、在main函数中使用接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建结构体Computer变量</span></span><br><span class="line">    computer := Computer&#123;&#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//创建结构体Phone变量</span></span><br><span class="line">    phone := Phone&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建结构体Camera变量</span></span><br><span class="line">    camera := Camera&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关键点</span></span><br><span class="line">    computer.Working(phone)</span><br><span class="line">    <span class="comment">//手机开始工作。。。</span></span><br><span class="line">    <span class="comment">//手机停止工作。。。</span></span><br><span class="line">    </span><br><span class="line">    computer.Working(camera)</span><br><span class="line">     <span class="comment">//相机开始工作。。。</span></span><br><span class="line">    <span class="comment">//相机停止工作。。。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结构体Computer的Working函数接收的是一个Usb接口变量，因为结构体Phone和Camera都实现了这个接口，所以可以传入，并且当传Phone时，可以动态的调用phone.Start()和phone.Stop()，传入camera时同理。Usb接口变量体现出多态。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2、接口体现多态的特征"><a href="#2、接口体现多态的特征" class="headerlink" title="2、接口体现多态的特征"></a>2、接口体现多态的特征</h5><p>1、多态参数<br>在前面的Usb接口案例中，Computer的Working函数接收的是一个Usb接口变量，Phone和Camera都实现了这个接口，所以既可以接收Phone变量，又可以接收Camera变量，体现出多态。</p>
<p>2、多态数组<br>在上述Usb案例中，我们可以定义一个Usb接口数组<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个Usb接口数组，可以存放Phone和Camera的结构体变量</span></span><br><span class="line">    <span class="keyword">var</span> usbArr [<span class="number">3</span>]Usb</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;nil&gt;&lt;nil&gt;&lt;nil&gt;]</span></span><br><span class="line">    </span><br><span class="line">    usbArr[<span class="number">0</span>] = Phone&#123;&#125;</span><br><span class="line">    usbArr[<span class="number">1</span>] = Phone&#123;&#125;</span><br><span class="line">    usbArr[<span class="number">2</span>] = Camera&#123;&#125;</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;&gt;&lt;&gt;&lt;&gt;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上述的案例中的结构体都没有字段，这里都加上Name字段，然后创建结构体变量</span></span><br><span class="line">    usbArr[<span class="number">0</span>] = Phone&#123;<span class="string">"华为"</span>&#125;</span><br><span class="line">    usbArr[<span class="number">1</span>] = Phone&#123;<span class="string">"小米"</span>&#125;</span><br><span class="line">    usbArr[<span class="number">2</span>] = Camera&#123;<span class="string">"索尼"</span>&#125;</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;华为&gt;&lt;小米&gt;&lt;索尼&gt;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Usb接口数组usbArr，可以存放Phone和Camera的结构体变量，体现出多态数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><h5 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、<strong>类型断言</strong>，由于<strong>接口</strong>是一般类型，<strong>不知道具体类型</strong>。如果要转成具体类型，就需要使用类型断言。</p>
<h5 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h5><p>1、定义结构体Point<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">    y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、main函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; <span class="comment">//定义一个空接口类型变量a</span></span><br><span class="line">    <span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment">//定义Point类型变量point</span></span><br><span class="line">    </span><br><span class="line">    a = point <span class="comment">//ok，</span></span><br><span class="line">    <span class="comment">//将Point类型变量point赋给一个空接口类型变量a，</span></span><br><span class="line">    <span class="comment">//使空接口类型变量a指向Point类型的变量point</span></span><br><span class="line">    <span class="comment">//空接口变量可以接收任何数据类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b Point</span><br><span class="line">    <span class="comment">//b = a不可以，不可以将一个空接口类型变量a赋给其他数据类型</span></span><br><span class="line">    <span class="comment">//b = a.(Point)可以，a.(Point)称为类型断言</span></span><br><span class="line">    </span><br><span class="line">    b,ok = a.(Point) </span><br><span class="line">    <span class="comment">//判断空接口类型变量a是指向Point类型的变量</span></span><br><span class="line">    <span class="comment">//如果是就转成Point类型的变量并赋给b，否则报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类型断言检查，不要让断言失败直接panic终止程序</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(b)<span class="comment">//输出&lt;1，2&gt;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         fmt.Println(<span class="string">"转换失败"</span>)</span><br><span class="line">     &#125;       </span><br><span class="line">     </span><br><span class="line">     fmt.Println(<span class="string">"代码继续执行"</span>)<span class="comment">//类型断言检查，断言失败不会panic终止程序，这里还会执行到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>重点</strong>：</p>
<ul>
<li>在进行类型断言时，如果类型不匹配，就会报panic。因此进行类型断言时，要确保原来的空接口指向的就是要断言的类型</li>
<li>例：首先“a = point ”使空接口类型变量a指向Point类型的变量point，才可以类型断言“b = a.(Point) ”</li>
</ul>
<h5 id="3、类型断言最佳案例"><a href="#3、类型断言最佳案例" class="headerlink" title="3、类型断言最佳案例"></a>3、类型断言最佳案例</h5><p><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/assert1.png" alt="assert1"></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h5 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、interface类型可以定义一组方法但是不需要实现</p>
<p>2、interface中<strong>不能包含任何变量</strong></p>
<h5 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    method1(参数列表)返回值列表</span><br><span class="line">    method2(参数列表)返回值列表</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> 自定义类型名 <span class="keyword">struct</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s 自定义类型名)</span> <span class="title">method1</span><span class="params">(参数列表)</span>返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">//方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s 自定义类型名)</span> <span class="title">method2</span><span class="params">(参数列表)</span>返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">//方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意：<br>1）接口中的所有方法都没有方法体，即接口的方法都是没有实现的方法。体现<strong>多态</strong>、<strong>高内聚低耦合</strong></p>
<p>2）Go中的接口，不需要显示实现。只要一个结构体变量（实例）含有接口类型中的所有方法，则称这个结构体变量实现了这个接口（没有类似implement这样的关键字，GO是基于方法实现的多态，而不需显示指出接口名称）。</p>
<p>3）如果由接口a和接口b有完全一样的方法列表，那么有实例c如果实现了接口a，同时也就实现了接口b，即：同时实现两个或两个以上的接口（在其他语言中是做不到的，例如Java，必须显示implement实现a，再显示implement实现b）</p>
<p>4）特别指出，需要<strong>实现接口所有的方法</strong></p>
<h5 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h5><p>1、<strong>接口本身不能创建实例</strong>，但是可以指向一个实现了该接口的自定义类型（如struct）的变量（实例）</p>
<p>2、接口中的所有方法都没有方法体，即接口的方法都是没有实现的方法</p>
<p>3、Go中，一个自定义类型需要将某个接口的<strong>所有方法都实现</strong>，才能称这个自定义类型实现了该接口</p>
<p>4、只要是自定义类型，都可以实现接口，不仅仅是结构体类型。如自定义一个int类型“type integer int”，这个自定义的类型integer也可以实现接口</p>
<p>5、一个自定义类型可以<strong>实现多个</strong>接口。（只要把多个接口的方法都实现就可以）</p>
<p>6、Go接口中不能有任何变量（常量也不可以）</p>
<p>7、一个接口（如接口A）可以<strong>继承多个</strong>别的接口（如接口B和C），这时如果要实现接口A，也必须要将接口B和C的方法全部实现，但是<strong>接口B和C中不能有完全相同的方法</strong>，编译器会报错重复定义，因为无法区分。</p>
<p>8、interface类型默认是一个<strong>指针</strong>（<strong>引用类型</strong>），如果没有对interface初始化就使用，那么会输出nil</p>
<p>9、空接口interface{}，没有任何方法，所以<strong>所有类型都默认实现了空接口</strong>（即空接口可以接收任何数据类型，可以把任何数据类型变量赋给空接口）。</p>
<p>10、<strong>空接口也是一种数据类型</strong><br>例：可以声明一个空接口类型变量<br>“vat t interface{}”</p>
<p>该空接口类型变量可以接收任何数据类型的值<br>“t = student”//接收一个Student类型的变量student<br>“t = 8.8”//接收一个float类型的值8.8</p>
<h5 id="4、接口使用案例"><a href="#4、接口使用案例" class="headerlink" title="4、接口使用案例"></a>4、接口使用案例</h5><p>1、定义一个接口AInteger<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AInteger <span class="keyword">interface</span>&#123;</span><br><span class="line">    Test01()</span><br><span class="line">    Test02()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、再定义一个接口BInteger<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AInteger <span class="keyword">interface</span>&#123;</span><br><span class="line">    Test01()</span><br><span class="line">    Test03()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、定义一个结构体Stu<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test01</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test02</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test03</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4、在main函数中使用接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stu := Stu&#123;&#125;<span class="comment">//创建一个Stu实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> a AInteger =stu </span><br><span class="line">    <span class="comment">//ok，将实例stu赋给接口AInteger的变量a，因为stu实现了接口AInteger中的所有方法（ Test01和Test02）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b BInteger =stu</span><br><span class="line">    <span class="comment">//ok，将实例stu赋给接口BInteger的变量b，因为stu实现了接口BInteger中的所有方法（ Test01和Test03）</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"ok"</span>,a,b)<span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5、接口与继承比较"><a href="#5、接口与继承比较" class="headerlink" title="5、接口与继承比较"></a>5、接口与继承比较</h5><p>1、当B结构体继承了A结构体，那么B结构体就自动的继承了A结构体的字段和方法，并且可以直接使用</p>
<p>2、B结构体需要扩展功能，同时不希望破坏继承关系，可以去实现某个接口，因此，可以认为：实现<strong>接口是对继承机制的一种补充</strong></p>
<p>3、接口与继承解决的问题不同</p>
<ul>
<li>继承的价值：解决代码的<strong>复用性</strong>和<strong>可维护性</strong></li>
<li>接口的价值：<strong>设计</strong>，设计好各种规范（方法），让其他自定义类型去实现这些方法来增强功能</li>
</ul>
<p>4、接口比继承更加灵活。<strong>继承</strong>是满足 <strong>is - a</strong> 的关系，<strong>接口</strong>只需要满足 <strong>like - a</strong> 的关系</p>
<p>5、接口在一定程度上实现代码解耦，尤其在GO中更加松散</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/" data-id="ckcivu88p000wa0vij3dbn6x1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go-错误处理机制、数组、切片、map" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-错误处理机制、数组、切片、map/" class="article-date">
  <time datetime="2020-06-11T07:29:33.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/go-错误处理机制、数组、切片、map/">go:错误处理机制、数组、切片、map</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、go错误处理机制"><a href="#1、go错误处理机制" class="headerlink" title="1、go错误处理机制"></a>1、go错误处理机制</h3><p>1、Go引入处理方式：<strong>defer、panic、recover</strong>，通常三者结合使用<br>2、这几个异常使用场景简单描述：Go中可以抛出一个panic异常，然后在defer中通过recover捕获这个异常，然后正常处理<br>示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num1 := <span class="number">10</span></span><br><span class="line">    num2 := <span class="number">0</span></span><br><span class="line">    res := num1/num2  <span class="comment">//会报错，10/0错误，0不可以作为除数</span></span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     test()<span class="comment">//test函数报错，下面的代码不会执行</span></span><br><span class="line">     fmt.Println(<span class="string">"main下面的代码"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异常处理：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用defer+recover结合捕获并处理异常</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        err :=<span class="built_in">recover</span>()<span class="comment">//recover()是一个内置函数，可以捕获异常</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;<span class="comment">//如果捕获到异常</span></span><br><span class="line">             fmt.Println(<span class="string">"err="</span>,err)</span><br><span class="line">             <span class="comment">//这里可以把错误信息发送给管理员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()<span class="comment">//这里调用defer后的匿名函数</span></span><br><span class="line">    num1 := <span class="number">10</span></span><br><span class="line">    num2 := <span class="number">0</span></span><br><span class="line">    res := num1/num2  <span class="comment">//会报错，10/0错误，0不可以作为除数</span></span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test()<span class="comment">//defer+recover结合捕获并处理异常后，使得下面的代码可以执行</span></span><br><span class="line">     fmt.Println(<span class="string">"main下面的代码"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h5><p>1、Go支持自定义错误，使用<strong>errors.New</strong>和<strong>panic</strong>内置函数<br>1）errors.New（“错误说明”），返回一个<strong>error</strong>类型的值，表示一个错误<br>2）panic内置函数，接收一个空接口interface{}类型的值（即任何值）作为参数。可以接收error类型的变量，输出错误信息，并退出程序。<br>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数读取配置文件init.conf的信息</span></span><br><span class="line"><span class="comment">//如果文件名传入不正确，返回一个自定义错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> name == <span class="string">"init.conf"</span>&#123;<span class="comment">//如果捕获到异常</span></span><br><span class="line">             <span class="comment">//读取...</span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//返回一个自定义错误</span></span><br><span class="line">             <span class="keyword">return</span> errors.New(<span class="string">"读取文件错误"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := readConf(init.conf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">             <span class="comment">//如果发生错误，输出错误，并终止程序</span></span><br><span class="line">             <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">     fmt.Println(<span class="string">"test后面的代码"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     test()<span class="comment">//test函数如果发生读取文件错误，panic会终止程序，下面的代码不会执行</span></span><br><span class="line">     fmt.Println(<span class="string">"main下面的代码"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、数组"><a href="#2、数组" class="headerlink" title="2、数组"></a>2、数组</h3><p>1、数组可以存放多个同一类型数据。数组也是一种数据类型，Go中，数组是<strong>值类型</strong><br>2、四种初始化数组方式<br>如果定义时不赋值，则会被系统赋默认值</p>
<ul>
<li><p>1）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2）var arr时不指定类型，类型推导</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3）用“…”代替数组大小</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4）指定元素值的下标</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>:<span class="string">"tom"</span>,<span class="number">2</span>:<span class="string">"jack"</span>,<span class="number">0</span>:<span class="string">"marry"</span>&#125;<span class="comment">//顺序可乱序，输出按下标输出</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3、数组遍历"><a href="#3、数组遍历" class="headerlink" title="3、数组遍历"></a>3、数组遍历</h5><p>1、常规for循环遍历<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr);i++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"arr[%d]=%v\n]"</span>,i,arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、for-range结构遍历<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value := <span class="keyword">range</span> arr&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"i=%v,v=%v\n"</span>,index,value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4、数组使用细节"><a href="#4、数组使用细节" class="headerlink" title="4、数组使用细节"></a>4、数组使用细节</h5><p>1、var arr []int，这时arr是一个slice切片<br>2、Go数组属于值类型，默认情况下是值传递，进行值拷贝，数组间不会互相影响<br>3、如想在其他函数中修改原来的数组，可以使用引用传递（指针方式，传数组地址）<br>4、<strong>长度是数组类型的一部分</strong>，在传递函数参数时，需要考虑数组长度<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">     fmt.Println(<span class="string">"modify的arr"</span>,arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr =[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    modify(arr)<span class="comment">//这里编译错误，因为认为main函数中的[3]int与modify函数中的形参[]int不是同一类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、切片"><a href="#3、切片" class="headerlink" title="3、切片"></a>3、切片</h3><p>1、切片是数组的一个引用，因此数组时引用类型，传递方式是引用传递<br>2、切片的长度可以变化，因此切片是一个动态数组<br>3、切片的使用和数组类似，遍历、访问切片的元素和求切片长度len（slice）都一样<br>3、切片定义的基本语法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span><span class="comment">//与数组不同的是，【】中不需要填入大小或“...”</span></span><br></pre></td></tr></table></figure></p>
<p>4、示例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个数组</span></span><br><span class="line"><span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">66</span>,<span class="number">99</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// intArr[1:3]表示切片slice从intArr这个数组的下标为1的元素开始引用，到下标为3的元素，但不包含标为3的元素</span></span><br><span class="line">slice := intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(<span class="string">"slice的元素："</span>，slice)              <span class="comment">//[22,33]</span></span><br><span class="line">fmt.Println(<span class="string">"slice的元素个数："</span>，<span class="built_in">len</span>(slice))   <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="string">"slice的容量："</span>，<span class="built_in">cap</span>(slice))        <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片的容量可以动态变化</span></span><br></pre></td></tr></table></figure></p>
<h5 id="1、切片在内存中的布局"><a href="#1、切片在内存中的布局" class="headerlink" title="1、切片在内存中的布局"></a>1、切片在内存中的布局</h5><p><img src="/2020/06/11/go-错误处理机制、数组、切片、map/slice1.jpg" alt="slice1"></p>
<p>由上图可以看出<br>1、slice是一个引用类型<br>2、slice从底层来说是一个结构体是struct，由三部分构成<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">    ptr *[<span class="number">2</span>]intArr  <span class="comment">//指向切片第一个元素的地址</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span>         <span class="comment">//长度</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span>         <span class="comment">//容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于slice是引用类型，所以通过slice去修改引用到的intArr数组中的值，intArr本身的值也会发生改变</p>
<h5 id="2、切片使用的三种方式"><a href="#2、切片使用的三种方式" class="headerlink" title="2、切片使用的三种方式"></a>2、切片使用的三种方式</h5><p>1、定义一个切片，然后让切片去引用一个已经创建好的数组，如上所示<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个数组</span></span><br><span class="line"><span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">66</span>,<span class="number">99</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// intArr[1:3]表示切片slice从intArr这个数组的下标为1的元素开始引用，到下标为3的元素，但不包含标为3的元素</span></span><br><span class="line">slice := intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(<span class="string">"slice的元素："</span>，slice)              <span class="comment">//[22,33]</span></span><br><span class="line">fmt.Println(<span class="string">"slice的元素个数："</span>，<span class="built_in">len</span>(slice))   <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="string">"slice的容量："</span>，<span class="built_in">cap</span>(slice))        <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片的容量可以动态变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//几种引用数组元素写法</span></span><br><span class="line">slice1 := intArr[:<span class="number">3</span>] <span class="comment">//等价于intArr[0:3]  1,22,33</span></span><br><span class="line">slice2 := intArr[<span class="number">1</span>:] <span class="comment">//等价于intArr[1:len(intArr)]  22,33,66,99</span></span><br><span class="line">slice1 := intArr[:] <span class="comment">//等价于intArr[0:len(intArr)]  1,22,33,66,99</span></span><br></pre></td></tr></table></figure></p>
<p>2、通过make来创建切片<br>基本语法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">//cap可选参数，cap&gt;=len</span></span><br></pre></td></tr></table></figure></p>
<p>使用案例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">float64</span></span><br><span class="line"><span class="comment">//对于切片，必须make后使用</span></span><br><span class="line">fmt.Println(<span class="string">"slice="</span>，slice)<span class="comment">//输出[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//make后</span></span><br><span class="line">slice = <span class="built_in">make</span>([]<span class="keyword">float64</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="string">"slice="</span>，slice)<span class="comment">//输出[0,0,0,0,0],默认值为0</span></span><br></pre></td></tr></table></figure></p>
<p>3、定义切片时直接指定具体数组<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>方式1创建切片的方式是直接引用一个事先定义好的数组，程序员对这个数组可见</li>
<li>方式2通过make方式创建切片，<strong>make也会创建一个数组，由切片在底层进行维护，程序员不可见</strong></li>
<li><strong>切片定义完之后，还不能直接使用</strong>，这时是一个空切片【】，需要引用到一个数组或者make一个空间来使用</li>
<li>切片可以再切片</li>
</ul>
<h5 id="3、切片的遍历"><a href="#3、切片的遍历" class="headerlink" title="3、切片的遍历"></a>3、切片的遍历</h5><p>1、for循环<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//20,20,30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;<span class="built_in">len</span>(slice);i++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"slice[%v]=%v "</span>,i,slice[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、for-range<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//20,20,30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> slice&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"i=%v v=%v\n"</span>,i,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4、切片的使用注意事项"><a href="#4、切片的使用注意事项" class="headerlink" title="4、切片的使用注意事项"></a>4、切片的使用注意事项</h5><p>1、<strong>切片定义完之后，还不能直接使用</strong>，这时是一个空切片【】，需要引用到一个数组或者make一个空间来使用</p>
<p>2、切片可以再切片</p>
<p>3、用<strong>append</strong>内置函数，可以对切片动态追加<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>&#125;</span><br><span class="line"><span class="comment">//通过append直接给切片slice追加具体的值，数据类型需匹配</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">400</span>)</span><br><span class="line"><span class="comment">//append操作后，会生成一个新数组，需要将append后的值赋给slice，保证slice引用到append操作后的新数组</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">500</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">600</span>,<span class="number">700</span>,<span class="number">800</span>)<span class="comment">//一次追加多个</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice,slice...)<span class="comment">//直接追加一个切片</span></span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>append操作的本质就是对数组扩容</li>
<li>go底层会创建一个新的数组newArr，将slice原来包含的元素拷贝到新数组newArr中，slice再重新引用数组newArr</li>
<li>数组newArr在底层维护，程序员不可见</li>
</ul>
<p>4、用<strong>copy</strong>内置函数，可以对切片拷贝<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(slice)<span class="comment">//输出[0,0,0,0,0,0,0,0,0,0]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(slice,a)<span class="comment">//将切片a的值拷贝到slice中</span></span><br><span class="line">fmt.Println(slice)<span class="comment">//输出【1，2，3，4，5，0，0，0，0，0】</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>copy操作需要两个参数都是切片，只能从切片拷贝到切片</li>
<li>上面代码中，切片a与slice的数据空间是独立的，互不影响</li>
<li>将切片a拷贝到slice，slice的长度小于a也是正确的</li>
<li>切片是引用类型，在传递时遵守引用传递机制</li>
</ul>
<h5 id="5、slice与string"><a href="#5、slice与string" class="headerlink" title="5、slice与string"></a>5、slice与string</h5><p>1、string底层是一个byte数组，因此string也可以进行切片处理操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello world"</span></span><br><span class="line"><span class="comment">//使用切片获取到world</span></span><br><span class="line">slice := str[<span class="number">6</span>:]</span><br><span class="line">fmt.Println(slice)<span class="comment">//输出world</span></span><br></pre></td></tr></table></figure></p>
<p>2、string在内存中的形式，以串“abcd”为例<br><img src="/2020/06/11/go-错误处理机制、数组、切片、map/slice2.jpg" alt="slice2"></p>
<p><em>string底层由两部分组成，指向一个字节数组的指针</em>[4]byte和长度len<br>字节数组中真正存放串的内容</p>
<p>3、string是不可变的，即不能通过str[0]=’z’的方式来修改字符(编译会报错)</p>
<p>4、如果需要修改字符串，可以先将string-&gt;[]byte（或者 []rune）-&gt;修改-&gt;重写转成string<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    str := <span class="string">"hello world"</span></span><br><span class="line">   <span class="comment">//把‘w’改成h</span></span><br><span class="line">   <span class="comment">//首先转成byte切片，可以处理英文和数字，中文用[]rune</span></span><br><span class="line">   <span class="comment">//因为[]byte按字节来处理，而一个汉字占3个字节，因此会出现乱码，[]rune按字符处理，兼容汉字</span></span><br><span class="line">   slice := []<span class="keyword">byte</span>(str)</span><br><span class="line">   slice[<span class="number">6</span>]=<span class="string">'h'</span></span><br><span class="line">   str = <span class="keyword">string</span>(slice)</span><br><span class="line">   fmt.Println(slice)<span class="comment">//输出hello horld</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 4、映射map</span></span><br><span class="line"><span class="string">1、map是key-value数据结构，又称为字段或者关联数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2、声明基本语法</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[keyType]valueType</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* key可以是很多种类型，如：bool，int系列、string、指针、channel，还可以是只包含前面几个类型的接口、结构体、数组，**通常为int、string**</span></span><br><span class="line"><span class="string">* **key不可以是slice、map、function**，因为这几个不能用“==”判断（key通常需要判断key存不存在）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* value的类型通常是string、map、struct</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* key不可重复，value可重复，**key**是**无序的**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* **声明不会分配内存**，初始化需要make分配内存后才能赋值和使用 </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//声明，还未分配内存</span></span><br><span class="line"></span><br><span class="line">a[<span class="string">"no1"</span>]=<span class="string">"宋江"</span>  <span class="comment">//这里会panic恐慌，给一个空map赋值，会报错</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure></p>
<p>使用map前需要先make，给map分配空间，和数组不一样，数组声明后会默认初始化为零值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//声明，还未分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用map前需要先make，给map分配空间，和数组不一样，数组声明后会默认初始化为零值</span></span><br><span class="line">a=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">10</span>)<span class="comment">//分配10个空间，不写默认为1</span></span><br><span class="line">a[<span class="string">"no1"</span>]=<span class="string">"宋江"</span></span><br><span class="line">a[<span class="string">"no2"</span>]=<span class="string">"吴用"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a)        <span class="comment">//输出 map 【no1:宋江 no2:吴用】</span></span><br></pre></td></tr></table></figure></p>
<h4 id="1、map的使用方式"><a href="#1、map的使用方式" class="headerlink" title="1、map的使用方式"></a>1、map的使用方式</h4><h5 id="1、声明-gt-make-gt-赋值"><a href="#1、声明-gt-make-gt-赋值" class="headerlink" title="1、声明-&gt;make-&gt;赋值"></a>1、声明-&gt;make-&gt;赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//声明，还未分配内存，这时map==nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用map前需要先make，给map分配空间，和数组不一样，数组声明后会默认初始化为零值</span></span><br><span class="line">a=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">10</span>)<span class="comment">//分配10个空间，不写默认为1</span></span><br><span class="line">a[<span class="string">"no1"</span>]=<span class="string">"宋江"</span></span><br><span class="line">a[<span class="string">"no2"</span>]=<span class="string">"吴用"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a)        <span class="comment">//输出 map 【no1:宋江 no2:吴用】</span></span><br></pre></td></tr></table></figure>
<h5 id="2、声明同时make-gt-赋值"><a href="#2、声明同时make-gt-赋值" class="headerlink" title="2、声明同时make-&gt;赋值"></a>2、声明同时make-&gt;赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">city[<span class="string">"no1"</span>]=<span class="string">"北京"</span></span><br><span class="line">city[<span class="string">"no2"</span>]=<span class="string">"上海"</span></span><br><span class="line">city[<span class="string">"no3"</span>]=<span class="string">"武汉"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(city)        <span class="comment">//输出 map 【no1:北京 no2:上海 no3:武汉】</span></span><br></pre></td></tr></table></figure>
<h5 id="3、声明时直接赋值"><a href="#3、声明时直接赋值" class="headerlink" title="3、声明时直接赋值"></a>3、声明时直接赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(city)        <span class="comment">//输出 map 【no1:北京 no2:上海 no3:武汉】</span></span><br></pre></td></tr></table></figure>
<h4 id="2、map的增删改查（crud）操作"><a href="#2、map的增删改查（crud）操作" class="headerlink" title="2、map的增删改查（crud）操作"></a>2、map的增删改查（crud）操作</h4><h5 id="1、增加和更新"><a href="#1、增加和更新" class="headerlink" title="1、增加和更新"></a>1、增加和更新</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="string">"key"</span>] = value</span><br><span class="line"><span class="comment">//1、如果key之前不存在，就是增加操作</span></span><br><span class="line"><span class="comment">//2、如果key之前存在，就是修改操作，新值覆盖旧值</span></span><br></pre></td></tr></table></figure>
<h5 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>,<span class="string">"key"</span>)</span><br></pre></td></tr></table></figure>
<p>1、delete是一个内置函数，如果key存在就删除该key-value，如果不存在，不操作，也不会报错<br>2、如果map为nil也不操作，不报错<br>3、如果我们要删除map所有的key，只能遍历逐个删除，不能一次全删除。或者map = make(map[keyType]valueType)，make一个新的，让原来的成为垃圾，被GC回收</p>
<h5 id="3、查找"><a href="#3、查找" class="headerlink" title="3、查找"></a>3、查找</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">val,ok := city[<span class="string">"no1"</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"有key:no1，值为：%v"</span>，val)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     fmt.Println(<span class="string">"没有key:no1"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、map的遍历"><a href="#3、map的遍历" class="headerlink" title="3、map的遍历"></a>3、map的遍历</h4><p>map遍历只能通过for-range，不能用普通for循环，因为map没有下标，key是无序的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> city &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"k=%v v=%v \n"</span>，k,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4、map的长度"><a href="#4、map的长度" class="headerlink" title="4、map的长度"></a>4、map的长度</h4><p>len(map)，统计map中有几对key-value<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"city 有"</span>，<span class="built_in">len</span>（city），“对key-value”)</span><br></pre></td></tr></table></figure></p>
<h4 id="5、map切片"><a href="#5、map切片" class="headerlink" title="5、map切片"></a>5、map切片</h4><p>切片的数据类型如果是map，则成为<strong>map切片</strong>，这样<strong>map的个数可以动态变化</strong>，map切片是一种切片，切片的每个元素都是一个map.<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个map切片</span></span><br><span class="line"><span class="keyword">var</span> monsters []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片make后才能使用</span></span><br><span class="line">monsters = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)<span class="comment">//len=2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> monsters[<span class="number">0</span>] == <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="comment">//切片的元素是map，map需要先make再使用</span></span><br><span class="line">    monsters[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)<span class="comment">//map有两个key</span></span><br><span class="line">    monsters[<span class="number">0</span>][<span class="string">"name"</span>] = <span class="string">"牛魔王"</span></span><br><span class="line">    monsters[<span class="number">0</span>][<span class="string">"age"</span>] = “<span class="number">500</span>”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> monsters[<span class="number">1</span>] == <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="comment">//切片的元素是map，map需要先make再使用</span></span><br><span class="line">    monsters[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)<span class="comment">//map有两个key</span></span><br><span class="line">    monsters[<span class="number">1</span>][<span class="string">"name"</span>] = <span class="string">"玉兔精"</span></span><br><span class="line">    monsters[<span class="number">1</span>][<span class="string">"age"</span>] = “<span class="number">400</span>”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为一开始定义切片长度为2，如果还要添加元素，用append函数动态增加</span></span><br><span class="line"><span class="comment">//1、定义一个monster信息</span></span><br><span class="line">newMonster := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"name"</span> = <span class="string">"新妖怪：红孩儿"</span>,</span><br><span class="line">    <span class="string">"age"</span> = <span class="string">"200"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、添加到切片中</span></span><br><span class="line">monsters = <span class="built_in">append</span>(monsters,newMonster)</span><br><span class="line"></span><br><span class="line"> fmt.Println(monsters)</span><br></pre></td></tr></table></figure></p>
<h4 id="6、map排序"><a href="#6、map排序" class="headerlink" title="6、map排序"></a>6、map排序</h4><p>1、GO中没有专门的map排序方法<br>2、map默认是无序的，也不是按照添加顺序存放，每次遍历的输出结果也不一样<br>3、对map排序，可以先将key排序，再根据key值遍历输出<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">map1[<span class="number">10</span>]=<span class="number">130</span></span><br><span class="line">map1[<span class="number">1</span>]=<span class="number">13</span></span><br><span class="line">map1[<span class="number">4</span>]=<span class="number">56</span></span><br><span class="line">map1[<span class="number">8</span>]=<span class="number">90</span></span><br><span class="line">    </span><br><span class="line">fmt.Println(map1)<span class="comment">//这里每次的输出结果顺序可能不一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="comment">//1、先将map的key放到切片中</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> map1&#123;</span><br><span class="line">    keys = <span class="built_in">append</span>(keys,k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、对切片排序</span></span><br><span class="line">sort.Ints(keys)</span><br><span class="line">fmt.Println(keys)<span class="comment">//key递增输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历切片，根据key值遍历输出值</span></span><br><span class="line"><span class="keyword">for</span> _,k  := <span class="keyword">range</span> keys&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"map1[%v]=%v \n"</span>,k,map1[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7、map使用细节"><a href="#7、map使用细节" class="headerlink" title="7、map使用细节"></a>7、map使用细节</h4><p>1、map是引用类型，遵守引用传递机制。<br>2、map容量到达后，想再增加元素，会自动扩容，不会panic，slice会panic<br>3、map的value也经常使用struct类型</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-错误处理机制、数组、切片、map/" data-id="ckcivu88m000ta0vircxar7q5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-函数/" class="article-date">
  <time datetime="2020-06-11T07:19:21.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/go-函数/">go:函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、函数"><a href="#1、函数" class="headerlink" title="1、函数"></a>1、函数</h3><h4 id="1、函数调用底层机制"><a href="#1、函数调用底层机制" class="headerlink" title="1、函数调用底层机制"></a>1、函数调用底层机制</h4><p>有如下示例<br>下图中的内存空间划分均为逻辑划分</p>
<ol>
<li>从main函数入口开始执行程序<br><img src="/2020/06/11/go-函数/func1.jpg" alt="func1"><br>在内存中会为main函数在栈上开辟一个空间，并为变量n1赋值10</li>
</ol>
<p>2、调用函数test()<br><img src="/2020/06/11/go-函数/func2.jpg" alt="func2"><br>逻辑上内存会为函数test()在栈上另外开辟一个空间（逻辑上），用于存放test（）函数中的数据</p>
<p>3、调用函数test()，并传入参数n1<br><img src="/2020/06/11/go-函数/func3.jpg" alt="func3"><br>test（）函数接受main（）函数传过来的参数n1，<strong>在test栈区中另开辟一个空间存放传过来的参数</strong>，此时，<strong>main栈区和test栈区的n1已经没有关系了（引用类型除外）</strong>，所以test栈区中n1的改变不影响main栈区中的n1</p>
<p>4、test()函数执行n1=n1+1<br><img src="/2020/06/11/go-函数/func4.jpg" alt="func4"><br>test栈区中n1的改变不影响main栈区中的n1</p>
<p>5、test()函数执行打印n1语句，终端输出test栈区中的n1<br><img src="/2020/06/11/go-函数/func5.jpg" alt="func5"></p>
<p>6、test（）函数执行完之后，内存回收test栈区，<strong>test栈区中数据全部被清除</strong>，程序回到main（）函数调用test（）函数的地方<br><img src="/2020/06/11/go-函数/func6.jpg" alt="func6"></p>
<p>7、main()函数执行打印n1语句，终端输出main栈区中的n1<br><img src="/2020/06/11/go-函数/func7.jpg" alt="func7"></p>
<p>8、main（）函数执行完之后，内存回收main栈区，<strong>main栈区中数据全部被清除</strong>，程序结束<br><img src="/2020/06/11/go-函数/func8.jpg" alt="func8"></p>
<p>9、<strong>总结</strong></p>
<ul>
<li>在调用一个函数时，会为该函数分配一个新的栈空间，编译器会通过自身的处理让这个新的空间和其他的栈区空间区分开来</li>
<li>在每个函数对应的栈中，数据空间是独立的，不会混淆</li>
<li>当一个函数调用（执行）完毕后，程序会销毁这个函数对应的栈空间</li>
</ul>
<p>10、注意事项</p>
<ul>
<li>Go不支持传统的函数重载</li>
</ul>
<ul>
<li><p>Go中，<strong>函数本身也是一种数据类型</strong>。可以赋值给一个变量，则该变量就是一个函数类型的变量，<strong>通过该变量可以对函数调用</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">       <span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a:=getSum   <span class="comment">//把函数getSum赋给变量a</span></span><br><span class="line">    fmt.Println(<span class="string">"a的类型是%T,getSum的类型是%T\n"</span>,a,getSum)</span><br><span class="line">    </span><br><span class="line">    res := a(<span class="number">10</span>,<span class="number">40</span>)<span class="comment">//等价于 res := getSum(10,40)</span></span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为函数是一种数据类型，所以在Go中，<strong>函数可以作为形参并调用</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure>
</li>
<li><p>Go支持对函数返回值命名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSub</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>, sub <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">       <span class="comment">///返回值命名sum和sub</span></span><br><span class="line">       sub = n1 - n2</span><br><span class="line">       sum = n1 + n2</span><br><span class="line">       <span class="comment">//为sum和sub赋值，顺序无所谓，可与返回值列表顺序不同</span></span><br><span class="line">       <span class="keyword">return</span>      </span><br><span class="line">       <span class="comment">//等价于return sum , sub ，由于已为返回值命名sum和sub，函数体中已为sum和sub赋值，return时可省略不写返回值，再写上反而显得冗余  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Go支持可变参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//支持0到多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(args... <span class="keyword">int</span>)</span> <span class="title">sum</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//支持1到多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span> , args... <span class="keyword">int</span>)</span> <span class="title">sum</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>args是切片slice，通过args[index]可以访问多个值</p>
<h4 id="2、init函数"><a href="#2、init函数" class="headerlink" title="2、init函数"></a>2、init函数</h4><p>1、<strong>每一个源文件中都可以包含init函数</strong>，该函数会在main函数执行之前，被Go运行框架调用，即init函数在main函数之前被调用。该函数通常用作初始化工作</p>
<p>2、如果一个文件同时包含全局变量定义，init函数和main函数，则执行的流程是：<strong>全局变量定义-&gt;init函数-&gt;main函数</strong></p>
<p>3、如果包含main函数的包里import了其他包，执行流程如下<br><img src="/2020/06/11/go-函数/func9.jpg" alt="func9"></p>
<h4 id="3、匿名函数"><a href="#3、匿名函数" class="headerlink" title="3、匿名函数"></a>3、匿名函数</h4><p>1、如果某个函数我们只是希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用</p>
<p>2、匿名函数的三种使用方式</p>
<ul>
<li>在定义匿名函数时就直接调用，且只能调用一次</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res1 := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1 + n2</span><br><span class="line">     &#125;(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">     <span class="comment">//在定义匿名函数的同时就调用它</span></span><br><span class="line">     </span><br><span class="line">      fmt.Println(<span class="string">"res1="</span>,res1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在紧跟匿名函数定义的后面传入参数调用<br><img src="/2020/06/11/go-函数/func10.png" alt="func10"></p>
<ul>
<li>将匿名函数赋给一个变量（函数变量），再通过该变量来调用匿名函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将匿名函数func(n1 int, n2 int) int 赋值给变量a</span></span><br><span class="line">    <span class="comment">//则a的数据类型就是函数类型，可以通过变量a完成调用</span></span><br><span class="line">    a := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1 + n2</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    res2 := a(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">    res3 := a(<span class="number">90</span>,<span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line">     fmt.Println(<span class="string">"res2="</span>,res2)</span><br><span class="line">     fmt.Println(<span class="string">"res3="</span>,res3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将匿名函数赋给一个全局变量，则这个匿名函数成为一个全局匿名函数，可以在整个程序有效</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    Func1 = <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> n1 + n2</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//这时func1即是一个全局匿名函数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res4 := Func1(<span class="number">4</span>,<span class="number">9</span>)</span><br><span class="line">    fmt.Println(<span class="string">"res4="</span>,res4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h4><p>1、闭包：就是<strong>一个函数</strong>和<strong>与其相关的引用环境</strong>组合的一个整体（实体）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        n = n + x</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f := AddUpper()</span><br><span class="line">    fmt.Println(f(<span class="number">1</span>)) <span class="comment">//输出11</span></span><br><span class="line">    fmt.Println(f(<span class="number">2</span>)) <span class="comment">//输出11+2=13</span></span><br><span class="line">    fmt.Println(f(<span class="number">3</span>)) <span class="comment">//输出13+3=16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对上面代码的说明</p>
<ul>
<li>AddUpper是一个函数，处于外层，返回数据类型时func(int) int</li>
<li><strong>闭包</strong>的说明</li>
</ul>
<p><img src="/2020/06/11/go-函数/func11.png" alt="func11"></p>
<p>在上图红框中可以看到，return返回一个匿名函数，处于内层，这个匿名函数<strong>引用到外层函数的变量n</strong>，因此这个<strong>匿名函数和变量n形成一个整体</strong>，构成<strong>闭包</strong></p>
<ul>
<li><p>可以理解成：闭包是一个类，函数是操作，变量n是字段。函数和它使用到的字段n构成闭包</p>
</li>
<li><p>在main函数中，外层函数AddUpper只被调用一次，所以AddUpper函数中的n只被初始化一次</p>
</li>
<li><p>当我们反复调用内层函数f时，因为外层函数中的变量n只初始化一次，因此每次调用进行累计，而不会重新初始化</p>
</li>
<li><p>闭包的关键，是要分析出返回的内层函数它所引用到的外层函数中的变量，因为函数和它所引用到的变量构成闭包</p>
</li>
</ul>
<h4 id="5、函数中的defer"><a href="#5、函数中的defer" class="headerlink" title="5、函数中的defer"></a>5、函数中的defer</h4><p>1、为什么需要defer<br>    在函数中，经常需要创建资源（如数据库连接、文件句柄、锁等），<strong>为了在函数执行完毕后，及时的释放资源</strong>，Go提供defer（延迟机制）</p>
<p> 2、defer使用案例<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//当执行到defer时，暂时不执行defer后的语句，会将defer后的语句压入独立的栈（这个栈和main函数及sum函数的栈不一样，这里称为defer栈）中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当函数执行完毕后，再从defer栈中，按先入后出顺序出栈执行</span></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n1="</span>,n1)<span class="comment">//3 n1=10</span></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n2="</span>,n2)<span class="comment">//2 n2=20</span></span><br><span class="line">   </span><br><span class="line">   res := n1+n2</span><br><span class="line">   fmt.Println(<span class="string">"n1+n2="</span>,res)<span class="comment">//1 n1+n2=30</span></span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res := sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)<span class="comment">//4 res=30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出顺序：<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n1+n2=<span class="number">30</span></span><br><span class="line">n2=<span class="number">20</span></span><br><span class="line">n1=<span class="number">10</span></span><br><span class="line">res=<span class="number">30</span></span><br></pre></td></tr></table></figure></p>
<p> 3、当执行到defer时，暂时不执行defer后的语句，会将defer后的语句压入独立的栈中，然后执行函数的下一条语句</p>
<p> 4、当函数执行完毕后，再从defer栈中，按先入后出顺序出栈执行</p>
<p> 5、将defer后的语句放入栈时，也会<strong>将相关的值拷贝同时入栈</strong><br>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n1="</span>,n1)<span class="comment">//defer  3 n1=10</span></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n2="</span>,n2)<span class="comment">//defer  2 n2=20</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//增加两条语句</span></span><br><span class="line">  n1++ <span class="comment">//n1=11</span></span><br><span class="line">  n2++ <span class="comment">//n2=21</span></span><br><span class="line">  <span class="comment">//这里n1、n2自增后，并不影响defer栈中的值，因为defer之后的语句入栈时，同时将值拷贝入栈，所以defer中的n1、n2值仍是入栈时候的值</span></span><br><span class="line">  </span><br><span class="line">   res := n1+n2</span><br><span class="line">   fmt.Println(<span class="string">"n1+n2="</span>,res)<span class="comment">//1 n1+n2=32</span></span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res := sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)<span class="comment">//4 res=32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出顺序：<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n1+n2=<span class="number">32</span></span><br><span class="line">n2=<span class="number">20</span></span><br><span class="line">n1=<span class="number">10</span></span><br><span class="line">res=<span class="number">32</span></span><br></pre></td></tr></table></figure></p>
<h4 id="6、函数参数传递的方式"><a href="#6、函数参数传递的方式" class="headerlink" title="6、函数参数传递的方式"></a>6、函数参数传递的方式</h4><p>1、两种传递方式</p>
<ul>
<li><strong>值传递</strong></li>
<li><strong>引用传递</strong></li>
</ul>
<p>不管是值传递还是引用传递，<strong>传递给函数的都是变量的副本</strong>。不同的是：<strong>值传递</strong>传递的是<strong>值的拷贝</strong>，<strong>引用传递</strong>传递的是<strong>地址的拷贝</strong>。</p>
<p>一般来说，地址拷贝效率高，因为数据量小，而值拷贝的效率由传递的数据大小决定，数据越大，效率越低。</p>
<p>2、值类型和引用类型</p>
<ul>
<li>值类型：<strong>基本数据类型（int系列、float系列、bool、string）、数组、结构体</strong></li>
<li>引用类型：<strong>指针、slice切片、map、管道channel、interface</strong>等</li>
</ul>
<h4 id="7、字符串中常用系统函数"><a href="#7、字符串中常用系统函数" class="headerlink" title="7、字符串中常用系统函数"></a>7、字符串中常用系统函数</h4><p>1、统计字符串的长度，按<strong>字节</strong>：<strong>len(str)</strong><br>是一个内置（内建）函数，不属于任何包，可直接使用</p>
<p>2、字符串遍历，同时处理 有中文的问题：<strong>r := []rune(str)</strong><br>遍历字符串时，可先将string类型的字符串str转成rune的切片：[]rune(str)，再进行遍历，因为string类型按字节遍历，[]rune按字符遍历，一个中文占三个字节。（for循环按字节遍历，for … range 按字符遍历）</p>
<p>3、字符串转整数：<strong>n,err := strconv.Atoi(“12”)</strong></p>
<p>4、整数转字符串：<strong>str = strconv.Itoa(12345)</strong></p>
<p>5、字符串转[]byte：<strong>var bytes = []byte(“hello go”)</strong></p>
<p>6、[]byte转字符串：<strong>str = string([]byte{97,98,99})</strong></p>
<p>7、十进制转二进制、八进制、十六进制</p>
<ul>
<li>十进制转二进制:</li>
</ul>
<p><strong>str = strconv.FormatInt(123,2)</strong></p>
<ul>
<li>十进制转八进制:</li>
</ul>
<p>str = strconv.FormatInt(123,<strong>8</strong>)</p>
<ul>
<li>十进制转十六进制:</li>
</ul>
<p>str = strconv.FormatInt(123,<strong>16</strong>)</p>
<p>8、查找子串是否在指定的串中：<strong>strings.Contains(“seafood”,”foo”)</strong>//true</p>
<p>9、统计一个字符串中有几个指定的子串：strings.Count(“ceheese”,”e”)//4</p>
<p>10、不区分大小写的字符串比较（用“==”比较区分大小写）：<strong>strings.EqualFold(“abc”,”Abc”)</strong>//true</p>
<p>11、返回子串在字符串中第一次出现的index值，如果没有返回-1：<strong>strings.Index(“NLT_abc”,”abc”)</strong>//4  下标从0开始索引</p>
<p>12、返回子串在字符串中最后一次出现的index值，如果没有返回-1：<strong>strings.LastIndex(“go go hello”,”go”)</strong>//3  下标从0开始索引</p>
<p>13、将指定的子串替换成另外一个子串：<strong>strings.Replace(“go go hello”,”go”,”go语言”，n)</strong><br>n可以指定你希望替换几个，n=-1表示全部替换</p>
<p>14、按照指定的某个字符为分割标识，将一个字符串拆分成字符串数组：<strong>strings.Split(“hello,world,ok”,”,”)</strong></p>
<p>15、将字符串的字母进行大小写转换：</p>
<p>大写转小写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.ToLower(<span class="string">"Go"</span>)<span class="comment">//go</span></span><br></pre></td></tr></table></figure></p>
<p>小写转大写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.ToUpper(<span class="string">"Go"</span>)<span class="comment">//GO</span></span><br></pre></td></tr></table></figure></p>
<p>16、将字符串的左右两边空格去掉：<strong>strings.TrimSpace(“  go hello    “)</strong></p>
<p>17、将字符串左右两边指定的字符去掉：<strong>strings.Trim(“! hello!”,” !”)</strong><br>//将【hello】左右两边的！和空格去掉</p>
<p>18、将字符串左边指定的字符去掉：<strong>strings.TrimLeft(“! hello!”,” !”)</strong><br>//将【hello】左边的！和空格去掉</p>
<p>19、将字符串右边指定的字符去掉：<strong>strings.TrimRight(“! hello!”,” !”)</strong><br>//将【hello】右边的！和空格去掉</p>
<p>20、判断字符串是否以指定的字符串开头：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.HasPrefix(<span class="string">"ftp://192.168.10.1"</span>,<span class="string">"ftp"</span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>21、判断字符串是否以指定的字符串结束：<strong>strings.HasSuffix(“go_var.jpg”,”jpg”)</strong>//true</p>
<h4 id="8、日期和时间相关函数"><a href="#8、日期和时间相关函数" class="headerlink" title="8、日期和时间相关函数"></a>8、日期和时间相关函数</h4><p>使用时间和日期函数需要引入<strong>time包</strong><br>1、<strong>time.Time</strong>类型，用于表示时间</p>
<p>2、获取当前时间<br><strong>now := time.Now()</strong>//now类型是time.Time</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过变量now获取年月日、时分秒</span><br><span class="line">now.Year()</span><br><span class="line">now.Month()<span class="comment">//英文月份</span></span><br><span class="line"><span class="keyword">int</span>（now.Month()）<span class="comment">//int强转为数字月份</span></span><br><span class="line">now.Day()</span><br><span class="line">now.Hour()</span><br><span class="line">now.Minute()</span><br><span class="line">now.Second()</span><br></pre></td></tr></table></figure>
<p>3、格式化日期</p>
<h5 id="1）方式1使用Printf或者Sprintf"><a href="#1）方式1使用Printf或者Sprintf" class="headerlink" title="1）方式1使用Printf或者Sprintf"></a>1）方式1使用Printf或者Sprintf</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">"当前年月日时分秒 %02d-%02d-%02d %02d-%02d-%02d \n"</span>,now.Year(),now.Month(),now.Day(),now.Hour(),now.Minute(),now.Second())</span><br></pre></td></tr></table></figure>
<p>或者Sprintf，Sprintf会返回一个字符串<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">dateStr := fmt.Sprintf(<span class="string">"当前年月日时分秒 %02d-%02d-%02d %02d-%02d-%02d \n"</span>,now.Year(),now.Month(),now.Day(),now.Hour(),now.Minute(),now.Second())</span><br><span class="line"><span class="comment">//fmt.Sprintf返回一个时间日期字符串赋给变量dateStr，可对变量dateStr进行操作(输出或保存等)</span></span><br><span class="line">fmt.Printf(<span class="string">"dateStr=%v\n"</span>,dateStr)</span><br></pre></td></tr></table></figure></p>
<h5 id="2）方式2使用Format"><a href="#2）方式2使用Format" class="headerlink" title="2）方式2使用Format"></a>2）方式2使用Format</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.printf(now.Format(<span class="string">"2006/01/02 15:04:05"</span>))<span class="comment">//年月日时分秒</span></span><br><span class="line">fmt.printf(now.Format(<span class="string">"2006/01/02))//年月日</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">15</span>:<span class="number">04</span>:<span class="number">05</span><span class="string">"))//时分秒</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">2006</span><span class="string">"))//年</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">01</span><span class="string">"))//月</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">02</span><span class="string">"))//日</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">2006</span><span class="number">-01</span><span class="number">-02</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">05</span><span class="string">"))</span></span><br></pre></td></tr></table></figure>
<p><strong>“2006/01/02 15:04:05”这一串数字是固定的，不能更改</strong>，但格式和组合可以改（传说这串数字是Go开发者脑海中萌生GoLang的时刻）。</p>
<p>4、时间的常量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    Nanosecond Duration = <span class="number">1</span>                             <span class="comment">//纳秒</span></span><br><span class="line">    Microsecond             = <span class="number">1000</span> * Nanosecond     <span class="comment">//微秒</span></span><br><span class="line">    Millisecond                = <span class="number">1000</span> * Microsecond     <span class="comment">//毫秒</span></span><br><span class="line">    Second                     = <span class="number">1000</span> * Millsecond      <span class="comment">//秒</span></span><br><span class="line">    Minute                     = <span class="number">60</span> * Second            <span class="comment">//分钟</span></span><br><span class="line">    Hour                        = <span class="number">60</span> * Minute           <span class="comment">//小时</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>常量的作用：在程序中可用于获取指定时间单位的时间，比如想得到100毫秒 100 * time.Millisecond</p>
<p>可用于休眠<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time.Sleep(time.Second)<span class="comment">//休眠1秒</span></span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">100</span>)<span class="comment">//休眠0.1秒</span></span><br><span class="line"><span class="comment">//只能传入整数，不能传小数</span></span><br><span class="line"><span class="comment">//休眠0.1秒不能这么写time.Sleep(time.Second * 0.1)</span></span><br></pre></td></tr></table></figure></p>
<p>5、时间戳</p>
<ul>
<li><p>unix时间戳<br>返回1970年1月1日0时0分0秒 到当前时间的秒数</p>
</li>
<li><p>unixnano时间戳(unix纳秒时间戳)<br>返回1970年1月1日0时0分0秒 到当前时间的纳秒数</p>
</li>
</ul>
<p>可以用于<strong>获取随机的数字</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了每次生成的随机数不一样，需要设定一个种子seed</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">num := rand.Intn(<span class="number">100</span>)<span class="comment">//0&lt;=n&lt;100</span></span><br><span class="line"><span class="comment">//如果不设置种子，会有一个默认值，但每次随机出来的数都一样</span></span><br></pre></td></tr></table></figure></p>
<h4 id="9、内置（buildin）函数"><a href="#9、内置（buildin）函数" class="headerlink" title="9、内置（buildin）函数"></a>9、内置（buildin）函数</h4><p>1、len()：求长度，比如string、array、slice、map、channel</p>
<p>2、func new<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure></p>
<p>new分配分存，第一个实参为类型而非值，new函数返回值为<strong>指向该类型</strong>的<strong>新分配</strong>的<strong>零值</strong>的<strong>指针</strong>，主要为<strong>值类型</strong>分配内存<br>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num1 := <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"num1的类型%T，num1的值%v，num1的地址%v"</span>，num1，num1，&amp;num1)</span><br><span class="line"><span class="comment">//num1的类型int，num1的值100，num1的地址0xcXXXXXXXX</span></span><br><span class="line"></span><br><span class="line">num2 := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"num2的类型%T，num2的值%v，num2的地址%v，num2指针指向的值"</span>，num2，num2，&amp;num2，*num2)</span><br><span class="line"><span class="comment">//num2的类型*int，</span></span><br><span class="line"><span class="comment">//num2的值0xcXXXXXXXX，num2的地址0xcXXXXXXXX，num2指针指向的值0,（这两个地址在程序运行时，系统动态分配）</span></span><br><span class="line"><span class="comment">//num2的值是一个地址，该地址指向int类型的零值0</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/2020/06/11/go-函数/func12.jpg" alt="func12"></p>
<p>3、make：分配内存，主要用来分配<strong>引用类型</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-函数/" data-id="ckcivu88k000qa0vid06o2dj8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/12/GO：1-3-库源码文件/">GO：1.3 库源码文件</a>
          </li>
        
          <li>
            <a href="/2020/07/10/GO：1-2-命令源码文件/">GO：1.2 命令源码文件</a>
          </li>
        
          <li>
            <a href="/2020/07/10/GO：工作区和GOPATH/">GO：工作区和GOPATH</a>
          </li>
        
          <li>
            <a href="/2020/07/02/hexo博客迁移/">hexo博客迁移</a>
          </li>
        
          <li>
            <a href="/2020/06/15/测试驱动开发TDD/">测试驱动开发TDD</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>