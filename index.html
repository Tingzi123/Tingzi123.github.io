<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-设计模式-备忘录模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/10/设计模式-备忘录模式/" class="article-date">
  <time datetime="2019-04-10T01:41:33.765Z" itemprop="datePublished">2019-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/10/设计模式-备忘录模式/">设计模式-备忘录模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、备忘录模式：在不破坏封装的前提下，存储关键对象的重要状态，从而可以在将来吧对象还原到存储的哪个状态</p>
<p>关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。</p>
<p>应用实例： 1、后悔药。<br>          2、打游戏时的存档。<br>          3、Windows 里的 ctri + z。 4、IE 中的后退。<br>          4、数据库的事务管理。</p>
<p>优点：<br>1）状态存储在外面，不和关键对象混在一起，可以帮助维护内聚<br>2）提供了容易实现的恢复能力<br>3）保持了关键对象的数据封装</p>
<p>缺点<br>1）存储和恢复状态的过程比较耗时</p>
<p>2、实现<br>备忘录模式使用三个类 Memento、Originator 和 CareTaker。<br>Memento 包含了要被恢复的对象的状态。<br>Originator 创建并在 Memento 对象中存储状态。<br>Caretaker 对象负责从 Memento 中恢复对象的状态。<br>MementoPatternDemo，演示类，使用 CareTaker 和 Originator 对象来显示对象的状态恢复。</p>
<p><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/memento.png?raw=true" alt="Image text"></p>
<p>1)创建 Memento类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String state;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2)创建 Originator 类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String state;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateToMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento Memento)</span></span>&#123;</span><br><span class="line">      state = Memento.getState();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3)创建 CareTaker 类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento state)</span></span>&#123;</span><br><span class="line">      mementoList.add(state);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4)创建 Originator和CareTaker对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MementoPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">      CareTaker careTaker = <span class="keyword">new</span> CareTaker();</span><br><span class="line">      originator.setState(<span class="string">"State #1"</span>);</span><br><span class="line">      originator.setState(<span class="string">"State #2"</span>);</span><br><span class="line">      careTaker.add(originator.saveStateToMemento());</span><br><span class="line">      originator.setState(<span class="string">"State #3"</span>);</span><br><span class="line">      careTaker.add(originator.saveStateToMemento());</span><br><span class="line">      originator.setState(<span class="string">"State #4"</span>);</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">"Current State: "</span> + originator.getState());    </span><br><span class="line">      originator.getStateFromMemento(careTaker.get(<span class="number">0</span>));</span><br><span class="line">      System.out.println(<span class="string">"First saved State: "</span> + originator.getState());</span><br><span class="line">      originator.getStateFromMemento(careTaker.get(<span class="number">1</span>));</span><br><span class="line">      System.out.println(<span class="string">"Second saved State: "</span> + originator.getState());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Current State: State #4</span><br><span class="line">First saved State: State #2</span><br><span class="line">Second saved State: State #3</span><br></pre></td></tr></table></figure></p>
<p>参考：<a href="http://www.runoob.com/design-pattern/memento-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/memento-pattern.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/10/设计模式-备忘录模式/" data-id="cjuc6lbbn000tlss6gtlvyt8q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式-策略模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/05/设计模式-策略模式/" class="article-date">
  <time datetime="2019-04-05T10:59:40.462Z" itemprop="datePublished">2019-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/05/设计模式-策略模式/">设计模式-策略模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<h3 id="原则就是"><a href="#原则就是" class="headerlink" title="原则就是:"></a>原则就是:</h3><p>分离变化部分，封装接口，基于接口编程各种功能。<br>该模式让行为算法的变化独立于算法的使用者。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h4 id="意图："><a href="#意图：" class="headerlink" title="意图："></a>意图：</h4><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<h4 id="关键代码："><a href="#关键代码：" class="headerlink" title="关键代码："></a>关键代码：</h4><p>实现同一个接口。</p>
<h4 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h4><p>1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。                          2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。<br>3、JAVA AWT 中的 LayoutManager。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>1、算法可以自由切换。<br>2、避免使用多重条件判断。<br>3、扩展性良好。</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>1、策略类会增多。<br>2、所有策略类都需要对外暴露。</p>
<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><p>1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。<br>Context 是一个使用了某种策略的类。<br>StrategyPatternDemo，演示类使用 Context 和策略对象来演示 Context在它所配置或使用的策略改变时的行为变化。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/strategy.png?raw=true" alt="Image text"></p>
<p>1、创建一个接口Strategy。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、创建实现接口的实体类OperationAdd、OperationSubstract、OperationMultiply。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 * num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、创建 Context 类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4、使用 Context 来查看当它改变策略 Strategy 时的行为变化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());    </span><br><span class="line">      System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());      </span><br><span class="line">      System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());    </span><br><span class="line">      System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5、输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="number">10</span> - <span class="number">5</span> = <span class="number">5</span></span><br><span class="line"><span class="number">10</span> * <span class="number">5</span> = <span class="number">50</span></span><br></pre></td></tr></table></figure></p>
<p>注意点：</p>
<blockquote>
<ul>
<li>分析项目中变化与不变部分</li>
<li>多用组合少用继承，用行为类组合，不用行为的继承，更有弹性</li>
</ul>
</blockquote>
<h3 id="与状态模式的比较"><a href="#与状态模式的比较" class="headerlink" title="与状态模式的比较"></a>与状态模式的比较</h3><p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。<br>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/05/设计模式-策略模式/" data-id="cjuc6lbbm000rlss6z8efxkin" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式-RMI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/05/设计模式-RMI/" class="article-date">
  <time datetime="2019-04-05T10:13:36.753Z" itemprop="datePublished">2019-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/05/设计模式-RMI/">设计模式总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、RMI远程方法调用是计算机之间通过网络实现对象调用的一种通讯机制</p>
<p>2、设计模式的三个分类：<br>1）创建型模式：对象实例化的模式，该模式解耦了对象的实例化过程<br>简单工厂：一个工厂类根据传入的参量决定创建出哪种产品类的实例<br>工厂方法:定义一个创捷对象的接口，让子类决定实例化哪个类<br>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类<br>单例模式：某个类只能有一个实例，提供一个全局访问点<br>生成器模式：封装一个复杂对象的构建过程，并可以按步骤构造<br>原型模式：通过复制现有的实例来创建新的实例（克隆）</p>
<p>2）结构型模式：把类和对象结合在一起形成更大的结构<br>适配器模式：把一个类的方法接口转换成客户希望的另一个接口<br>组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构<br>装饰模式：动态的给对象添加新的功能<br>代理模式：为其他对象提供一个代理以控制对这个对象的访问<br>蝇量模式:通过共享技术有效地支持大量细粒度的对象<br>外观模式：提供统一的方法来访问子系统的一群接口<br>桥接模式：将抽象部分与它的实现部分分离，使他们都可以独立地变化</p>
<p>3）行为型模式：类和对象如何交互，划分责任和算法<br>模板模式：定义一个算法结构，而将一些步骤延迟到子类中实现<br>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器<br>策略模式：定义一系列的算法，把它们封装起来，并且使他们可相互替换<br>状态模式：允许一个对象在其内部状态改变时改变它的行为<br>观察者模式：对象之间的一对多的依赖关系<br>备忘录模式：在不破坏封装性的前提下，保存对象的内部状态<br>中介者模式：用一个中介对象来封装一系列的对象交互<br>命令模式：将命令请求封装为一个对象，使得可用不同的请求来进行参数化<br>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素新的功能</p>
<p>责任链：请求发送者和接收者之间解耦，使得多个对象都有机会处理这个请求<br>迭代器：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/05/设计模式-RMI/" data-id="cjuc6lbb6000plss6oflitevu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java-对象导论" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/Java-对象导论/" class="article-date">
  <time datetime="2019-04-01T14:07:10.940Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/Java-对象导论/">Thinking in Java - 对象导论</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、抽象过程<br>1）万物皆为对象<br>2）程序是对象的集合，他们通过发送消息来告知彼此所要做的<br>要想请求一个对象，就必须对该对象发送一条消息，可以把消息想象为对某个特定对象的方法的调用请求<br>3）每个对象都有自己的由其他对象所构成的存储<br>4）每个对象都拥有其类型<br>5）某一特定类型的所有对象都可以接受同样的消息</p>
<p>对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（状态）和方法（行为），都可以唯一的与其他对象区分开来，即每一个对象在内存中都有一个唯一的地址。</p>
<p>2、每个对象都有一个接口<br>1）关键字class的由来:在程序执行期间具有不同状态而其它方面都相似的对象会被分组到对象的类中<br>2）一个类实际上就是一个数据类型，因为类描述具有相同特性（数据元素)和行为（功能）的对象集合<br>3）class，是Java编程语言中的基本单位</p>
<p>3、每个对象都提供服务<br>1）将对象想像为“服务提供者”，有助于提供对象的内聚性</p>
<p>4、被隐藏的具体实现（访问权限）<br>1）public：任何人可用<br>2）private：除类创建者和类的内部方法之外的任何人都不能访问<br>3）protected：类创建者和类的内部方法能访问，继承的类也能访问protected成员，不能访问private成员<br>4）包访问权限：默认的访问权限，类可以访问同一个包（库构件）中的其他类成员，对于包之外，该包内的成员相当于被private所修饰</p>
<p>5、复用的具体实现<br>1）最简单的复用某个类：直接使用该类的对象<br>2）组合：将该类的对象置于某个新的类中，新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。</p>
<p>6、继承（是is-a的关系)<br>1）当父类发生变动时，子类也会反映出这种变动<br>2）类不仅仅只是描述作用于一个对象集合上的约束条件，还有与其他类之间的关系。两个类可以有相同的特性和行为，但其中一个类可能比另一个含有更多的特性，并且可以处理更多的消息，继承使用父类和子类的概念表示了这种类之间的相似性。<br>3）一个父类包含其所有子类所共享的特性和行为。<br>4）继承现有类时，也就创造了新的类。新的类包括现有类的所有成员（包括不可访问的private成员），并且复制了父类的接口，即所有可以发送给父类对象的消息同时也可以发送个子类的对象。<br>5）由于通过发送给类的消息的类型可知类的类型，则这意味着父类与基类具有相同的类型</p>
<p>6.1 使父类与子类产生差异的方法<br>1）直接在子类中添加新方法，父类不能访问这个新方法，是一种is-like-a的关系<br>2）覆盖</p>
<p>7、伴随多态的可互换对象<br>1）处理类型的层次结构时，经常想把一个对象不当作它所属的特定类型来看待，而是当作其父类来看待。<br>2）这使得可以编写出不依赖于特定类型的代码，这样的代码不会受新添加的类型的影响<br>3）前期绑定：非面向对象编程的编译器产生的函数调用会引起前期绑定，编译器将产生对一个具体函数名字的调用，运行时将这个调用解析到将要被执行的代码的绝对地址。<br>4）后期绑定：在OOP中，程序直到运行时才能确定代码的地址。当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查，但是不知道将被执行的确切代码。<br>5）为了后期绑定，Java用一小段特殊代码来替代绝对地址调用，这段代码使用在对象中存储的信息来计算方法体的地址。根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。<br>5）在Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态。</p>
<p>8、单根继承结构<br>1）Java中所有的类最终都继承自单一的类：Object<br>2）单根继承使垃圾回收器的实现变得容易很多。<br>3）所有的对象都可以很容易在堆上创建，参数传递也得到极大简化<br>4）所有的对象都保证具有其类型信息，因而不会因无法确定对象的类型而陷入僵局，这对于系统级操作（如异常处理）尤其重要，并且给编程带来更大的灵活性。</p>
<p>9、容器<br>1）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/01/Java-对象导论/" data-id="cjuc6lbaj0000lss6v8z7e18j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/30/数据库总结/" class="article-date">
  <time datetime="2019-03-30T08:55:03.830Z" itemprop="datePublished">2019-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/30/数据库总结/">数据库总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、 where、having之间的区别和用法<br>聚合函数是比较where、having 的关键。 </p>
<p>where、聚合函数、having 在from后面的执行顺序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where&gt;聚合函数(sum,min,max,avg,count)&gt;having</span><br></pre></td></tr></table></figure></p>
<p>注意事项 ：<br>1、where 后不能跟聚合函数，因为where执行顺序大于聚合函数。<br>2、where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，<br>使用where条件显示特定的行。</p>
<p>3、having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/30/数据库总结/" data-id="cjuc6lbb6000jlss6h5voyzl3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OS设备管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/30/OS设备管理/" class="article-date">
  <time datetime="2019-03-30T08:07:25.857Z" itemprop="datePublished">2019-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/30/OS设备管理/">操作系统-设备管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、概 述<br>1 、 I / O 的 特 点<br>（1）I/O性能经常成为系统性能的瓶颈，CPU性能越高，与I/O差距越大<br>（2）操作系统庞大复杂的原因之一是：资源多、杂，并发，均来自I/O<br>（3）异步性<br>处理机与I/O设备各自以不同的速度工作，可以并行工作，无需相互等待，通过中断方式或DMA方式交互。<br>（4）接口通用性<br>I/O设备与处理机连接通过通用接口。</p>
<p>1.1 设备的分类<br>（1）按使用特性分类<br>存储型设备：用来保存信息的设备，比如磁盘磁带等。<br>输入型设备：键盘、鼠标、物理传感设备<br>输出型设备：打印机、绘图仪（可保存）<br>输入输出型设备（交互型设备）</p>
<p>（2）按信息交换单位分类<br>块设备：<br>以数据块为单位存储、传输信息；比如磁盘、磁带、光盘等<br>字符设备：<br>以字符为单位存储、传输信息；不寻址，没有查找操作；比如键盘、鼠标、打印机等</p>
<p>（3）按外部设备的从属关系分<br>系统设备：<br>指操作系统生成时，登记在系统中的标准设备（如终端、打印机、磁盘机等）；<br>用户设备：<br>指在系统生成时，未登记在系统中的非标准设备（如鼠标）。</p>
<p>（4）按资源分配角度分<br>独占设备：<br>在一段时间内只能有一个进程使用的设备，一般为低速I/O设备（如打印机，磁带等）<br>共享设备：<br>在一段时间内可有多个进程共同使用的设备，多个进程以交叉的方式来使用设备，其资源利用率高（如硬盘）<br>虚拟设备：<br>在一类设备上模拟另一类设备，常用共享设备模拟独占设备，目的是为了提高利用率</p>
<p>1.2 设 备 管 理 的 目 标 和 任 务<br>（1）按照用户的请求，控制设备的各种操作，完成I/O设备与内存之间的数据交换（包括设备分配与回收；设备中断处理；缓冲区管理），<br>最终完成用户的I/O请求<br>– 设备分配与回收<br>– 建立统一的独立于设备的接口<br>– 实现真正的I/O操作<br>– 处理外部设备的中断处理<br>– 管理I/O缓冲区，减少外设和内存及CPU之间的速度不匹配问题</p>
<p>（2）向用户提供使用外部设备的方便接口，使用户摆脱繁琐的编程负担</p>
<p>（3）充分利用各种技术（通道，中断，缓冲等）提高CPU与设备、设备与设备之间的并行工作能力，充分利用资源，提高资源利用率</p>
<p>2、数据传输控制<br>2.1 程序控制I/O技术<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osdev1.png?raw=true" alt="Image text"><br>– 由处理器提供I/O相关指令来实现<br>– I/O处理单元处理请求并设置I/O状态寄存器相关位<br>– 不中断处理器，也不给处理器警告信息<br>– 处理器定期轮询I/O单元的状态，直到处理完毕<br>– I/O软件包含直接操纵I/O的指令<br>• 控制指令: 用于激活外设，并告诉它做什么<br>• 状态指令: 用于测试I/O控制中的各种状态和条件<br>• 数据传送指令: 用于在设备和主存之间来回传送数据</p>
<p>– 程序直接控制方式简单，不需要多少硬件支持，但是存在以下缺点：<br>• CPU和外设只能串行工作。由于CPU处理速度远快于外设，CPU的大量时间都处于循环测试等待状态，使得处理机利用率大大降低<br>• CPU在一段时间内只能和一台外设交换数据，从而不能实现设备之间的并行工作<br>• 由于程序直接控制方式通过不断测试状态位来控制数据传送，因此无法发现和处理其他设备的问题</p>
<p>2.2 中断驱动I/O技术<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osdev2.png?raw=true" alt="Image text"><br>– 首先，进程发出指令启动外设，同时将状态寄存器中的中断允许位打开；<br>– 进程发出指令后，该进程放弃处理机，进程调度程序调度其他就绪进程占据处理机；<br>– 当输入完成时，I/O控制器通过中断请求线向CPU发出中断信号，CPU接收到信号后做相应处理（将缓冲寄存器中数据送到指定内存单元，<br>把阻塞进程唤醒，再返回到被中断进程继续执行）<br>– 在以后的“某个时刻”，被唤醒进程（就绪态）被进程调度程序选中重新占据处理机，从约定的内存单元中取数据进一步处理<br>（如果数据没完，重复）<br>– 优点：<br>• 不再循环测试状态位，提高CPU利用率且支持设备和设备以及设备和CPU之间的并行工作。<br>– 缺点：<br>• 由于数据缓冲寄存器较小，故中断次数较多，这仍将损耗大量CPU时间，同时有可能造成数据丢失（数据缓冲寄存器的数据来不及取走）</p>
<p>2.3 D M A 技 术<br>• 直接存储器访问（DMA：Direct Memory Access）<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osdev3.png?raw=true" alt="Image text"><br>• 在外设和内存之间开辟直接的数据交换通路，目的是为了减少CPU的干预<br>• 自动控制数据在内存和I/O单元间的传送<br>• 大大提高处理I/O的效能<br>– 当处理器需要读写数据时给DMA控制单元发送一条命令。<br>– 处理器发送完命令后就可处理其它事情<br>– DMA控制器将自动管理数据的传送<br>– 当这个过程完成后，它会给处理器发一个中断<br>– 处理器只在开始传送和传送结束时关注一下即可<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osdev4.png?raw=true" alt="Image text"></p>
<p>DMA方式与中断的主要区别:<br>– 中断方式是在数据缓冲寄存器满后，发中断请求，CPU进行中断处理<br>– DMA方式则是在所要求传送的数据块全部传送结束时要求CPU进行中断处理<br>– 大大减少了CPU进行中断处理的次数<br>– 中断方式的数据传送是由CPU控制完成的<br>– 而DMA方式则是在DMA控制器的控制下不经过CPU控制完成的</p>
<p>DMA 方式的局限性；<br>– 数据传送方向、内存始址、数据长度等都由CPU控制；并且每台设备需一个DMA控制器，当外设较多时控制会进一步复杂化。</p>
<p>3、通 道<br>– 通道又称为I/O处理机<br>– 引入通道的目的:<br>• 为了使CPU从I/O事务中解脱出来<br>• 为了提高CPU与设备、设备与设备之间的并行度</p>
<p>– 定义：<br>• 通道是独立于CPU的专门负责数据输入/输出传输工作的处理机，对外部设备实现统一管理，代替CPU对输入/输出操作进行控制，从而使输入，输出操作可与CPU并行操作。<br>– 通道有自己的通道指令。</p>
<p>通道分类：<br>1）字节多路通道<br>• 字节多路通道以字节为单位传输信息，它可以分时地执行多个通道程序。<br>– 主要连接以字节为单位的低速I/O设备。如打印机，终端。<br>– 以字节为单位交叉传输，当一台传送一个字节后，立即转去为另一台传送字节</p>
<p>2）选择通道<br>• 选择通道是以成组方式工作的，即每次传送一批数据，故传送速度很高。选择通道在一段时间内只能执行一个通道程序，<br>只允许一台设备进行数据传输</p>
<p>3）数组(成组)多路通道<br>• 它结合了选择通道传送速度高和字节多路通道能进行分时并行操作的优点。它先为一台设备执行一条通道指令，然后自动转接，<br>为另一台设备执行一条通道指令<br>– 主要连接高速设备</p>
<p>4、中断技术<br>– 中断机制是操作系统得以正常工作的最重要的手段<br>– 它使得OS可以捕获普通程序发出的系统功能调用<br>– 及时处理设备的中断请求<br>– 防止用户程序中破坏性的活动等等</p>
<p>4.1 中断的概念<br>• 指CPU对系统中或系统外发生随机事件的响应<br>• 如外部设备完成数据传输，出现异常等<br>• CPU对系统发生的某个事件作出的一种反应<br>– CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osdev5.png?raw=true" alt="Image text"></p>
<p>引入中断的目的<br>• 解决主机与外设的并行工作问题<br>• 提高可靠性<br>• 实现实时控制<br>– 特点：<br>• 中断是随机的<br>• 中断是可恢复的<br>• 中断是自动处理的<br>– 中断源：引起中断发生的事件<br>– 中断寄存器：记录中断<br>– 中断字：中断寄存器的内容</p>
<p>– 系统堆栈:<br>在内存开辟的一块区域，用于临时保存现场</p>
<p>– 关中断：某些情况下，尽管中断源发出了中断请求，但CPU的PSW的中断允许位已被消除，从而不允许CPU响应中断<br>– 开中断：当设置PSW的中断允许位时，CPU可以接受中断<br>– 开中断和关中断是为了保证某些程序执行的原子性<br>– 中断屏蔽：指系统用软件方式有选择地封锁部分中断而允许其他部分的中断仍能得到响应。比如PSW可以设置优先级，可以屏蔽掉优先级低的中断</p>
<p>4.2 中断类型<br>强迫性中断<br>• 正在运行的程序所不期望的，由于某种硬件故障或外部请求引起的<br>– 自愿性中断<br>• 用户在程序中有意识安排的中断，是由于用户在编制程序时因为要求操作系统提供服务，有意使用“访管”指令或系统调用，使中断发生</p>
<p>强迫性中断<br>• 输入/输出(I/O)中断：主要来自外部设备通道<br>• 程序性中断：运行程序中本身的中断(如溢出,缺页中断,缺段中断,地址越界)<br>• 时钟中断<br>• 硬件故障</p>
<p>自愿性中断<br>• 执行I/O，创建进程，分配内存<br>• 信号量操作，发送/接收消息</p>
<p>– 外中断<br>来自处理机和内存外部的中断，包括I/O中断、时钟中断等，也称为中断<br>– 内中断<br>与外中断相反，比如溢出、系统调用等，称为陷阱</p>
<p>在多级中断系统中，可能同时有多个中断请求，CPU接受中断优先级为最高的那个中断<br>– 忽略其中断优先级较低的那些中断<br>– 在一些机器中，中断优先级按中断类型划分：<br>• 机器故障中断的优先级最高<br>• 程序中断和访问管理程序中断次之<br>• 外部中断更次之<br>• 输入输出的优先级最低</p>
<p>中断和陷阱的区别：<br>陷阱的优先级一般高于中断<br>• 陷阱通常由正在执行的指令引起的（比如系统调用），而中断则是由与现行指令无关的中断源引起的<br>• 陷阱处理程序的服务为当前进程所用，而中断处理程序提供的服务则不是为了当前进程的<br>• CPU在执行完一条指令后，下一条指令之前响应中断，而在一条指令执行中也可以响应陷阱</p>
<p>中断处理过程：<br>（1）设备给处理器发一个中断信号<br>（2）处理器处理完当前指令后响应中断，延迟非常短（前提是处理器没有关闭中断）<br>（3）保存中断点的程序执行上下文环境，这通常包括程序状态字PSW，程序计数器PC中的下一条指令位置，一些寄存器的值，它们通常保存在系统栈中,处理器状态被切换到管态<br>（4）处理器根据中断源查询中断向量表，获得与该中断相联系的处理程序入口地址，并将PC置成该地址，处理器开始一个新的指令周期，控制转移到中断处理程序<br>（5）中断处理程序开始工作，包括检查I/O相关的状态信息，操纵I/O设备或者在设备和主存之间传送数<br>据等等<br>（6）中断处理结束时，处理器检测到中断返回指令，被中断程序的上下文环境从系统栈中被恢复，处理器状态恢复成原来的状态。<br>（7）PSW和PC被恢复成中断前的值，处理器开始一个新的指令周期，中断处理结束</p>
<p>多个中断的处理：<br>– 若中断处理过程中又发生中断，引起多中断处理问题<br>– 两种策略方法：<br>– 第一种：<br>• 处理一个中断时禁止中断，对任何新中断置之不理，在这期间发生的中断将保持挂起状态<br>– 实现方法：<br>• 在任何中断处理前使用禁止中断指令<br>• 在处理结束后开放中断指令<br>• 所有中断严格按照发生顺序处理<br>• 不考虑中断紧急程度，无法达到较严格时间要求</p>
<p>– 第二种：中断按照优先度分级<br>• 允许优先级高中断打断优先级低的中断处理过程<br>• 这样中断优先级技术将引起中断处理的嵌套<br>• 只要合适地定义中断的优先级别，方法一的弊端大都可以克服</p>
<p>典型的中断处理：<br>1）时钟中断<br>• 维护软件时钟：系统有若干个软件时钟，控制定时任务以及进程的处理器时间配额，时钟中断需要维护、定时更新这些软件时钟<br>• 处理器时间调度：维护当前进程时间片软件时钟，并在当前进程时间片到时以后运行调度程序选择下一个被调度的进程<br>• 控制系统定时任务：通过软件时钟和调度程序定时激活一些系统任务，如监测死锁、系统记帐、系统审计等</p>
<p>2）硬件故障中断<br>– 保存现场，使用一定警告手段，提供些辅助诊断信息<br>– 在高可靠系统中，中断处理程序还要评估系统可用性，尽可能恢复系统</p>
<p>5、缓冲技术<br>– 引入原因<br>• 缓和CPU和I/O设备速度失配的矛盾<br>• 减少CPU中断频率，放宽对中断响应时间的限制。<br>• 提高CPU和设备之间的并行性<br>– 缓冲的实现方法<br>• 采用硬件缓冲器，比如数据缓冲寄存器<br>• 在内存中划出专用缓冲区存放数据</p>
<p>5.1 缓冲种类<br>根据系统设置的缓冲器的个数，可把缓冲技术分为：<br>（1） 单缓冲<br>单缓冲是在设备和处理机之间设置一个缓冲器。设备和设备之间不能通过单缓冲达到并行操作。</p>
<p>（2） 双缓冲<br>双缓冲只是一种说明设备和设备、CPU和设备并行操作的简单模型，并不能用于实际系统中的并行操作。</p>
<p>（3） 多缓冲（ 缓冲队列 、 环形缓冲队列）<br>多缓冲是把多个缓冲区连接起来组成两部分，一部分专门用于输入，另一部分专门用于输出的缓冲结构。</p>
<p>（4） 缓冲池<br>缓冲池则是把多个缓冲区连接起来统一管理，既可用于输入又可用于输出的缓冲结构</p>
<p>缓冲池的结构<br>缓冲池由多个缓冲区组成。而一个缓冲区由两部分组成： 一部分是用来标识该缓冲区和用于管理的缓冲首部，另一部分是用于存放数据的缓冲体。<br>这两部分有一一对应的映射关系。对缓冲池的管理是通过对每一个缓冲器的缓冲首部进行操作实现的<br>系统把各缓冲区按其使用状况连成三种队列：<br>• 空白缓冲队列em，其队首指针为F(em)，队尾指针为L(em);<br>• 装满输入数据的输入缓冲队列in，其队首指针为F(in)，队尾指针为L(in);<br>• 装满输出数据的输出缓冲队列out，其队首指针为F(out)，队尾指针为L(out)。</p>
<p>6、设备分配<br>设备分配用数据结构：<br>– 设备控制表DCT<br>系统中每个设备都必须有一张DCT，且在系统生成时或在该设备和系统连接时创建，但表中的内容则根据系统执行情况而被动态地修改。</p>
<p>– 控制器控制表COCT<br>– COCT也是每个控制器一张，它反映I/O控制器的使用状态以及和通道的连接情况等(在DMA方式时，该项是没有的)。</p>
<p>– 通道控制表CHCT<br>该表只在通道控制方式的系统中存在，也是每个通道一张。包括通道标识符、通道忙/闲标识、等待获得<br>该通道的进程等待队列的队首指针与队尾指针等</p>
<p>– 系统设备表SDT<br>系统设备表SDT整个系统一张，它记录已被连接到系统中的所有物理设备的情况，并为每个物理设备设一表项</p>
<p>6.1 设备分配<br>(1) 先请求先分配<br>– 当有多个进程对某一设备提出I/O请求时，或者是在同一设备上进行多次I/O操作时，系统按提出I/O请求的先后顺序，将进程发出的I/O请求命令排成队列，其队首指向被请求设备的DCT。</p>
<p>(2) 优先级高者先分配<br>系统能从I/O请求队列队首取下一个具有最高优先级进程发来的I/O请求命令，并将设备分配给发出该命令的进程<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osdev6.png?raw=true" alt="Image text"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/30/OS设备管理/" data-id="cjuc6lbd00012lss63icsi9j8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OS文件管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/29/OS文件管理/" class="article-date">
  <time datetime="2019-03-29T13:50:30.819Z" itemprop="datePublished">2019-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/29/OS文件管理/">操作系统-文件管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、 文件与文件系统<br>（1）文件的概念<br>文件指的是一组带标识的在逻辑上有完整意义的信息项（构成文件内容的基本单元）的序列，或者是相关联纪录的集合。文件存放在磁盘或磁带等存<br>储介质上。<br>文件是一个抽象机制，它提供了一种把信息保存在存储介质上，而且便于以后存取的方法，用户不必关心实现细节</p>
<p>（2）文件系统<br>• 是操作系统中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用</p>
<p>1.1 文件系统的功能：<br>（1）统一管理文件的存储空间，实施存储空间的分配与回收；<br>（2）为用户提供可见的文件逻辑结构，实现文件的按名存取；名字空间 → → → 存储空间<br>（3）对文件及文件目录的管理，这是文件系统最基本的功能，包括文件（目录）的建立、删除、读写等；<br>（4）提供操作系统与用户的接口（提供对文件的操作命令：信息存取、加工等）。</p>
<p>1.2 文件的分类<br>（1）按文件性质和用途分类<br>• 系统文件：<br>有关OS及有关系统所组成文件，不能直接访问<br>• 用户文件：<br>用户委托系统保存的文件<br>• 库文件：<br>标准子程序及常用应用程序组成文件，允许用户使用但不能修改</p>
<p>2、文件的结构和存取方式<br>（1）流式文件（无结构文件）：<br>• 构成文件的基本单位是字符，文件是有逻辑意义的、无结构的一串字符的集合。<br>• 管理简单，操作方便，但查找比较麻烦，对基本信息单位操作不多的文件比较适合用字符流的无结构方式，比如源程序文件。<br>（2）记录式文件（有结构文件）：<br>• 文件是由若干个记录组成，每个记录有一个键，可按键进行查找，每条记录有其内部结构。<br>• 方便用户进行各种操作比如添加、删除、修改、查找等</p>
<p>2.1 文件的存取方法<br>常用存取方法：<br>①顺序存取。<br>顺序存取是按照文件的逻辑地址顺序存取。比如当前读取的记录为Ri，则下一条读取的记录被自动确定为Ri的下一个相邻的记录Ri+1。<br>②随机存取。<br>允许用户根据记录的编号来存取文件的任一记录。前两种方法用于一般OS，下面方法适用数据库系统。<br>③按键存取。</p>
<p>2.2 文件的物理结构<br>– 文件系统中，文件存储设备通常分块，每块1k或者512字节或其他大小，与此对应，文件信息也被划分为与物理块大小相等的逻辑块<br>（1）连续结构（顺序）<br>– 文件的信息存放在若干连续的物理块中。系统为每个文件都建立一个文件控制块FCB。对于顺序文件，只要从FCB中得到文件的第一个块的物理块<br>号和文件长度，便可确定位置。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osfile1.png?raw=true" alt="Image text"><br>– 优点: 简单<br>• 支持顺序存取和随机存取<br>• 顺序存取速度快<br>• 所需的磁盘寻道次数和寻道时间最少</p>
<p>– 缺点:<br>• 不利于文件动态增长重新分配和移动<br>• 不利于文件插入和删除（大量移动）<br>• 外部碎片问题</p>
<p>（2）链接结构<br>– 一个文件的信息存放在若干不连续的物理块中，各块之间通过指针连接，前一个物理块指向下一个物理块<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osfile2.png?raw=true" alt="Image text"><br>– 优点：<br>• 提高了磁盘空间利用率,不存在外部碎片问题<br>• 有利于文件插入和删除<br>• 有利于文件动态扩充</p>
<p>– 缺点：<br>• 存取速度慢，不适于随机存取<br>• 可靠性问题，如指针出错<br>• 更多的寻道次数和寻道时间<br>• 链接指针占用一定的空间</p>
<p>（3）索引结构<br>• 一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构——索引表，并将这些块的块号存放在一个索引表中。<br>• 一个索引表就是磁盘块地址数组,其中第i个条目指向文件的第i块<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osfile3.png?raw=true" alt="Image text"></p>
<p>– 优点：<br>• 保持了链接结构的优点，又解决了其缺点：既能顺序存取，又能随机存取<br>• 满足了文件动态增长、插入删除的要求<br>• 能充分利用外存空间<br>– 缺点：<br>• 较多的寻道次数和寻道时间<br>• 索引表本身带来了系统开销<br>• 存取文件时至少访问存储器两次，一次是获得地址，一次是对物理块的访问。为了提高速度，将索引表放入内存，减少访问磁盘次数</p>
<p>文件的物理结构:<br>UNIX文件系统采用的是多级索引结构。每个文件的索引表为13个索引项，每项2个字节。最前面10项直接登记存放文件信息的物理块号（直接寻址）</p>
<p>如果文件大于10块，则利用第11项指向一个物理块，该块中最多可放256个文件物理块的块号（一次间接寻址）。对于更大的文件还可利用第12和第13项作为二次和三次间接寻址</p>
<p>– UNIX中采用了三级索引结构后，文件最大可达16兆个物理块<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osfile4.png?raw=true" alt="Image text"></p>
<p>文件存储介质：<br>（1）物理块<br>在文件系统中，文件的存储设备常常划分为若干大小相等的物理块。同时也将文件信息划分成相同大小的逻辑块，所有块统一编号以块为单位进行信息的存储、传输、分配</p>
<p>（2）磁带<br>永久保存大容量数据<br>– 顺序存取设备：前面的物理块被存取访问之后，才能存取后续的物理块的内容<br>– 存取速度较慢，主要用于后备存储，或存储不经常用的信息</p>
<p>（3）磁盘<br>– 直接（随机）存取设备：<br>• 存取磁盘上任一物理块的时间不依赖于该物理块所处的位置</p>
<p>完成过程由三个动作组成：<br>• 寻道（时间）：磁头移动定位到指定磁道<br>• 旋转延迟（时间）：等待指定扇区从磁头下旋转经过<br>• 数据传输（时间）：数据在磁盘与内存之间的实际传输</p>
<p>3、文件目录<br>3.1 基本概念<br>– 文件控制块（FCB）：<br>• 文件控制块是操作系统为管理文件而设置的数据结构，存放了为管理文件所需的所有有关信息。<br>• 文件控制块是文件存在的标志</p>
<p>– 文件目录：<br>• 把所有的FCB组织在一起，就构成了文件目录，即文件控制块的有序集合。<br>– 目录项：<br>• 构成文件目录的项目（目录项就是FCB）。<br>– 目录文件：<br>• 为了实现对文件目录的管理，通常将文件目录以文件的形式保存在外存，这个文件就叫目录文件</p>
<p>目录结构：<br>（1）一级目录结构<br>– 为所有文件建立一个目录文件（组成一线性表）<br>– 优点：<br>• 简单，易实现</p>
<p>– 缺点：<br>• 限制了用户对文件的命名<br>• 文件平均检索时间长</p>
<p>（2）二级目录结构<br>– 为解决一级目录文件目录命名冲突，并提高对目录文件检索速度而改进。<br>– 目录分为两级：<br>• 一级称为主文件目录（MFD），给出用户名，用户子目录所在的物理位置；<br>• 二级称为用户文件目录（UFD），给出该用户所有文件的FCB<br>– 使用二级目录可以解决文件重名和文件共享问题，并可以获得较高的搜索速度。</p>
<p>– 优点：解决了文件的重名问题和共享问题<br>用户名|文件名<br>查找时间降低<br>– 缺点：增加了系统开销<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osfile5.png?raw=true" alt="Image text"></p>
<p>（3）多级目录结构（树型目录）<br>– 优点：<br>• 层次结构清晰，便于管理和保护；有利于文件分类；解决重名问题；提高文件检索速度；能进行存取权限的控制 。<br>– 缺点：<br>• 查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度。</p>
<p>（4）文件目录改进<br>– 为加快目录检索可采用目录项分解法：把FCB分成两部分：<br>– 符号目录顶<br>文件名，文件号<br>– 基本目录项<br>除文件名外的所有项目</p>
<p>3.2 文 件 存 储 空 间 管 理：<br>– 辅存空间分配常采用以下两种办法。<br>– 连续分配：<br>• 文件被存放在辅存空间连续存储区中，在建立文件时，用户必须给出文件大小；<br>• 然后，查找到能满足的连续存储区供使用；否则文件不能建立。<br>– 连续分配的优点是文件查找速度快，管理较为简单，但为了获得足够大的连续存储区。需定时进行‘碎片’收集。因而，不适宜于文件频繁进行动态扩充和缩小的情况，用户事先不知道文件长度也无法进行分配。</p>
<p>非连续分配：<br>• 一种非连续分配方法是以块（或扇区）为单位，按文件动态要求分配给它若干扇区，这些扇区不一定要连续。<br>• 另一种非连续分配方法是以簇为单位，簇是由若干个连续扇区组成的分配单位；实质上是连续分配和非连续分配的结合。各个簇可以用链指针、索<br>引表，位示图来管理。非连续分配的优点是辅存空间管理效率高，访问文件执行速度快，特别是以簇为单位的分配方法已被广泛使用。</p>
<p>3.3 文件系统的使用<br>– 在文件系统中提供对文件的各种操作，形式分别为：系统调用或命令。</p>
<ol>
<li><p>主要操作<br>– 提供设置和修改对用户文件存取权限<br>– 提供建立、修改、改变、删除目录的服务<br>– 提供文件共享，设置访问路径的服务<br>– 提供创建、打开、读、写、关闭、撤消文件等服务<br>– 文件系统维护</p>
</li>
<li><p>操作介绍<br>（1）建立文件<br>实质是建立文件的FCB，并建立必要的存储空间，分配空FCB，根据提供的参数及需要填写有关内容，返回一个文件描述。<br>目的：建立系统与文件的联系<br>（2）打开文件<br>使用文件的第一步，任何一个文件使用前都要先打开，即把FCB送到内存</p>
</li>
</ol>
<p>3.4 文件系统的可靠性<br>– 可靠性：<br>• 系统抵抗和预防各种物理性破坏和人为性破坏的能力。<br>– 备份<br>• 通过转储操作，形成文件或文件系统的多个副本</p>
<p>3.5 磁盘冗余阵列 RAID<br>– RAID(Reundant Array of Independent Disks)<br>– 它是利用一台磁盘阵列控制器统一管理和控制一组磁盘驱动器。<br>– 其策略是:用一组较小容量的、独立的、可并行工作的磁盘驱动器组成阵列来代替单一的大容量磁盘，独立的I/O请求能被并行地从多个磁盘驱动器同时存取数据，从而，改进了I/O性能和系统可靠性</p>
<p>3.6 文 件 系 统 的 性 能<br>（1） 磁盘调度<br>当多个访盘请求在等待时，采用一定的策略，对这些请求的服务顺序调整安排，旨在降低平均磁盘服务时间，达到公平、高效<br>– 公平：一个I/O请求在有限时间内满足<br>– 高效：减少设备机械运动所带来的时间浪费</p>
<p>（2）磁盘调度考虑的问题：<br>一次访盘时间 = 寻道时间+旋转延迟时间+存取时间<br>– 减少寻道时间<br>– 减少延迟时间</p>
<p>（3）磁盘调度算法<br>1） 先来先服务：按访问请求到达的先后次序服务<br>例：假设磁盘访问序列：98，183，37，122，14，124，65，67，读写头起始位置：53，安排磁头服务序列，计算磁头移动总距离（道数）<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osfile6.png?raw=true" alt="Image text"><br>– 优点：简单，公平；<br>– 缺点：效率不高，相临两次请求可能会造成最内到<br>最外的柱面寻道，使磁头反复移动，增加了服务时间，<br>对机械也不利。</p>
<p>2）最 短 寻 道 时 间 优 先<br>– 最短寻道时间优先：优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先<br>– 优点：改善了磁盘平均服务时间；<br>– 缺点：造成某些访问请求长期等待得不到服务</p>
<p>例：假设磁盘访问序列：98，183，37，122，14，124，65，67，读写头起始位置：53，安排磁头服务序列，计算磁头移动总距离（道数）<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osfile7.png?raw=true" alt="Image text"><br>– 采用最短寻道时间优先调度下的总移动道数：236<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osfile8.png?raw=true" alt="Image text"></p>
<p>3）电梯算法<br>克服了最短寻道优先的缺点，既考虑了距离，同时又考虑了方向。<br>– 当设备无访问请求时，磁头不动；当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osfile9.png?raw=true" alt="Image text"></p>
<p>4）单 向 扫 描 调 度 算 法<br>– 总是从0号磁道开始向里扫描<br>– 按照各自所要访问的磁道位置的次序去选择访问者<br>– 移动臂到达最后个一个磁道后，立即带动读写磁头快速返回到0号磁道<br>– 返回时不为任何的等待访问者服务<br>– 返回后可再次进行扫描</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/29/OS文件管理/" data-id="cjuc6lbcs000zlss69s7ugyu7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OS存储管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/29/OS存储管理/" class="article-date">
  <time datetime="2019-03-29T03:31:30.832Z" itemprop="datePublished">2019-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/29/OS存储管理/">操作系统-存储管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、存 储 概 述<br>由于任何程序、数据必须占用主存空间后才能执行，因此存储管理直接影响系统的性能。</p>
<p>– 主存储空间一般分为两部分：<br>• 一部分是系统区，存放操作系统常驻内存部分；<br>• 另一部分是用户区，存放用户的程序和数据等</p>
<p>存储管理主要是对用户区域进行管理，当然也包括对辅存的管理。目的是要尽可能地方便用户使用和提高主存储器的效率</p>
<p>存储层次结构<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey1.png?raw=true" alt="Image text"></p>
<p>存储管理应具有的四大功能:<br>1 ） 内存空间管理<br>– 记录每个内存单元的使用情况<br>– 内存分配<br>– 位示图：用一位（bit）表示一个空闲页面（0：空闲，1：占用）</p>
<p>2）地址变换（重定位，地址映射）<br>我们把用户编程时使用的地址称为逻辑地址，把程序在内存中的实际地址称为物理地址。为了保证程序的正确运行，必须把程序和数据的逻<br>辑地址转换为物理地址，这一工作称为地址转换或重定位。</p>
<p>– 静态地址转换<br>• 当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换。<br>• 一般在装入内存时由重定位装入程序完成。</p>
<p>– 动态地址转换<br>• 在程序运行过程中要访问数据时再进行地址变换（即在逐条指令执行时完成地址映射。一般为了提高效率，此工作由硬件地址映射机制来<br>完成。硬件支持，软硬件结合完成）。<br>• 一对寄存器（VR，BR）</p>
<p>静态重定位：<br>– 优点：无须硬件支持；<br>– 缺点：<br>（1）不支持虚拟存储，原因是执行期间程序不能移动，因而不能实现重新分配内存，而虚拟存储则将部分程序装入内存。<br>（2）不能共享。因为每个程序必须占用连续的内存空间，因此很难做到。</p>
<p>动态重定位：<br>– 过程：<br>（1）设置基址寄存器BR，虚拟地址寄存器VR<br>（2）将程序首址送入BR<br>（3）程序执行时，将需要访问的虚址送入VR<br>（4）将BR和VR相加，得到实际访问的地址。</p>
<p>– 优点：<br>（1）可以对内存进行非连续分配，对于不同程序段设置不同的BR即可。<br>（2）提供了实现虚拟存储的基础，动态重定位可以部分地、动态地分配内存。<br>（3）有利于共享。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey2.png?raw=true" alt="Image text"></p>
<p>3）内 存 扩 充<br>内存的容量是受实际的存储单元限制的，而运行的程序又不受内存大小的限制，这就需要有效的存储管理技术来实现内存的逻辑扩充，这种扩充不是增加实际的存储单元，而是通过虚拟存储技术、覆盖技术、交换技术等技术来实现的。</p>
<p>4）内存共享和保护<br>– 为了更有效地使用内存空间，要求共享内存<br>– 为多个程序共享内存提供保障，使在内存中的各道程序，只能访问它自己的区域，避免各道程序间相互干扰，特别是当一道程序发生错误时，不致于影响其他程序的运行<br>– 保护过程—-防止地址越界<br>– 保护过程—-防止操作越权</p>
<p>2、存储管理的一些技术<br>2.1 覆盖(overlay)<br>– 引入：其目标是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用<br>– 引入：其目标是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用<br>• 不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。(即不同时用的模块可共用一个分区)<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey3.png?raw=true" alt="Image text"></p>
<p>2.2 交换(swapping)<br>– 引入：多个程序并发执行，可以将暂时不能执行的程序送到外存中，从而获得空闲内存空间来装入新程序，或读入保存在外存中而目前到达就绪状态的进程。交换单位为整个进程的地址空间。<br>• 程序暂时不能执行的可能原因：处于阻塞状态，低优先级（确保高优先级程序执行）；</p>
<p>– 原理：暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swa pout）而将外存中由阻塞变为就绪的进程的地址空间读<br>入到内存中，并将该进程送到就绪队列（换入swap in）。</p>
<p>– 优点：增加并发运行的程序数目，并且给用户提供适当的响应时间；编写程序时不影响程序结构，对用户透明。<br>– 缺点：对换入和换出的控制增加处理机开销；程序整个地址空间都进行传送，没有考虑执行过程中地址访问的统计特性。<br>– 覆盖技术和交换技术的发展导致了虚拟存储技术的出现</p>
<p>2.3 虚拟存储技术<br>虚存：把内存与外存有机的结合起来使用，从而得到一个容量很大的“内存”，这就是虚存<br>– 实现思想：当进程运行时，先将一部分程序装入内存，另一部分暂时留在外存，当要执行的指令不在内存时，由系统自动完成将它们从外存调入内存工作<br>– 目的：提高内存利用率</p>
<p>虚存的物质基础：<br>系统要有足够大的外存；<br>– 要有一定容量的内存来存放运行作业的部分程序<br>– 要有动态地址转换机构，实现逻辑地址转换；</p>
<p>特征：<br>– 虚拟性：指逻辑上扩大了内存容量，使用户看到的内存空间大于实际空间；<br>– 离散性：指内存在分配时采用的是离散分配的方式，目的是为了避免内存空间的浪费；<br>– 多次性：指一个作业不是全部一次性装入内存，而是在需要时装入部分；<br>– 交换性：指在一个进程运行期间，将暂不使用的程序和数据从内存调至外存，被调出的程序和数据在需要时再调入内存中。<br>– 总容量不超过物理内存和外存交换区容量之和</p>
<p>3、分区存储管理<br>– 把内存分为一些大小相等或不等的分区(partition)，每个应用进程占用一个分区。操作系统占用其中一个分区。<br>– 问题：可能存在内碎片和外碎片。<br>• 内碎片：占用分区之内未被利用的空间<br>• 外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）。</p>
<p>3.1 固定分区(fixed partitioning)<br>– 把内存划分为若干个固定大小的连续分区。每个分区装一个且只能装一个作业。<br>• 分区大小相等：<br>• 分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey4.png?raw=true" alt="Image text"><br>优点：易于实现，开销小。<br>– 缺点：<br>• 内碎片造成浪费<br>• 分区总数固定，限制了并发执行的程序数目。</p>
<p>3.2 动态分区(dynamic partitioning)<br>基本思想:<br>• 作业装入时，根据作业的需求和内存空间的使用情况来决定是否分配<br>• 若有足够的空间，则按需要分割一部分分区给该进程；否则令其等待内存空间</p>
<p><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey5.png?raw=true" alt="Image text"></p>
<p>– 分区分配算法：寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区的先后次序通常是从内存低端到高端。<br>– 分区释放算法：需要将相邻的空闲分区合并成一个空闲分区。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）最先适应法(first-fit)：按分区的先后次序，从头查找，找到符合要求的第一个分区</span><br><span class="line"><span class="number">2</span>）下次适应法(next-fit)：按分区的先后次序，从上次分配的分区起查找（到最后分区时再回到开头），找到符合要求的第一个分区</span><br><span class="line"><span class="number">3</span>）最佳适应法(best-fit)：找到其大小与要求相差最小的空闲分区</span><br><span class="line"><span class="number">4</span>）最坏适应法(worst-fit)：找到最大的空闲分区</span><br></pre></td></tr></table></figure></p>
<p>3.3 碎 片 问 题<br>– 紧凑技术：通过在内存移动程序，将所有小的空闲区域合并为大的空闲区域<br>(内存紧凑(compaction)：将各个占用分区向内存一端移动。使各个空闲分区聚集在另一端，然后将各个空闲分区合并成为一个空闲分区)</p>
<p>3.4 分区的回收及保护<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）该空闲区的上下相邻分区都是空闲区。将三个空闲区合并，合并后的起始地址为上空闲区的起始地址，修改可用表或自由链（取消下，修改上）</span><br><span class="line"><span class="number">2</span>）该空闲区的上相邻区是空闲区。与上相邻区合并，合并后的起始地址为上空闲区的起始地址，修改可用表或自由链（修改上的大小）。</span><br><span class="line"><span class="number">3</span>）该空闲区的下相邻区是空闲区。与下相邻区合并，合并后的起始地址为释放区的起始地址，修改可用表或自由链（修改下的始址和大小）。</span><br><span class="line"><span class="number">4</span>）该空闲区不与其他空闲区相邻,作为一个新空闲区插入可用表或自由链</span><br></pre></td></tr></table></figure></p>
<p>4、页式存储管理<br>4.1 基本思想:<br>– 用户程序划分<br>• 把用户程序按逻辑页划分成大小相等的部分，称为页。从0开始编制页号，页内地址是相对于0编址<br>– 逻辑地址<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey6.png?raw=true" alt="Image text"><br>内存空间<br>• 按页的大小划分为大小相等的区域，称为内存块（物理页面）<br>– 内存分配<br>• 以页为单位进行分配，并按作业的页数多少来分配。<br>• 逻辑上相邻的页，物理上不一定相邻</p>
<p><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey7.png?raw=true" alt="Image text"></p>
<p>4.2 管理<br>– 页表：系统为每个进程建立一个页表，页表给出逻辑页号和具体内存块号相应的关系<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey8.png?raw=true" alt="Image text"></p>
<p>地址映射机制：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey9.png?raw=true" alt="Image text"></p>
<p>地址映射机制（含快表）：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey10.png?raw=true" alt="Image text"></p>
<p>4.3 静态页式管理<br>– 将程序的逻辑地址空间和物理内存划分为固定大小的页或页面(Page or Page frame)，程序加载时，分配其所需的所有页，这些页不必连续<br>静态页式管理的地址变换：<br>– 指令所给出地址分为两部分：逻辑页号，页内偏移地址－&gt;查进程页表，得物理页号－&gt;物理地址</p>
<p>– 优点：<br>• 没有外碎片，每个内碎片不超过页大小（因为页面大小固定 要多少有多少）。<br>• 一个程序不必连续存放。<br>• 便于改变程序占用空间的大小。即随着程序运行<br>而动态生成的数据增多，地址空间可相应增长。<br>– 缺点：<br>• 程序全部装入内存，受到内存可用页面数的限制。</p>
<p>4.4 动态（请求）页式管理<br>– 在进程开始运行之前，不是装入全部页面，而是装入部分页面，之后根据进程运行的需要，动态装入其它页面；当内存空间已满，而又需要装入新的页面时，则根据某种算法淘汰某个页面，以便装入新的页面。</p>
<p>页表表项：<br>– 页号、驻留位、内存块号、外存始址、访问位、修改位<br>– 驻留位（中断位）：表示该页是在内存还是在外存<br>– 访问位：根据访问位来决定淘汰哪页（由不同的算法决定）<br>– 修改位：查看此页是否在内存中被修改过<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey11.png?raw=true" alt="Image text"></p>
<p>缺页中断处理：<br>在地址映射过程中，在页表中发现所要访问的页不在内存，则产生缺页中断。操作系统接到此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使作业继续运行下去<br>– 如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应表项<br>– 若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey12.png?raw=true" alt="Image text"></p>
<p>页面置换算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">– 随机置换算法</span><br><span class="line">– 先进先出算法(FIFO)</span><br><span class="line">– 最近最久未使用算法(LRU, Least Recently Used)</span><br><span class="line">– 时钟页面替换算法(Clock Policy) </span><br><span class="line">– 最佳置换算法(OPT, optimal)</span><br></pre></td></tr></table></figure></p>
<p>1）先进先出算法( F I F O )<br>– 选择建立最早的页面被置换，性能较差，较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出。<br>– 并且有Belady现象。<br>– Belady现象：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多，缺页率反而提高的异常现象。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey13.png?raw=true" alt="Image text"></p>
<p>2）最近最久未使用算法( L R U )<br>– 该算法淘汰的页面是在最近一段时间里较久未被访问的那一页。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey14.png?raw=true" alt="Image text"></p>
<p>3）最佳算法(OPT, optimal)<br>– 选择“未来不再使用的”或“在离当前最远位置上出现的”页面被置换，这是一种理想情况。<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey15.png?raw=true" alt="Image text"></p>
<p>影 响 缺 页 次 数 的 因 素：<br>(1) 分配给进程的物理页面数<br>(2) 页面本身的大小<br>(3) 程序的编制方法<br>(4) 页面淘汰算法</p>
<p>4.5 页式管理的优缺点<br>– 相对于分区管理而言，静态页式有效的解决了外部碎片的问题（当然有少量的内部碎片）；<br>– 但是，静态页式要求全部装入，不支持虚拟存储，因而有了请求（动态）页式，允许部分装入；<br>– 显然地，请求页式更能有效利用有限的内存页面，不过，这种方式需要有效解决缺页率的问题，尤其是页面置换的问题；</p>
<p>5、段式存储管理<br>5.1 基本原理<br>用户程序划分<br>•按程序自身的逻辑关系划分为若干个程序段，每个程序段都有一个段名，且有一个段号。段号从0开始，每一段也从0开始编址，段内地址是连续的</p>
<p>– 逻辑地址（二维地址）<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey16.png?raw=true" alt="Image text"></p>
<p>基本原理：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey17.png?raw=true" alt="Image text"></p>
<p>内存划分方式：<br>– 内存划分<br>内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定<br>– 内存分配<br>以段为单位分配内存，每一个段在内存中占据连续空间（内存随机分割，需要多少分配多少），但各段之间可以不连续存放</p>
<p>段式管理：<br>(1) 段表：每进程一个<br>(2) 空闲表：系统一个（管理同动态分区）array of (addr,size)<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey18.png?raw=true" alt="Image text"></p>
<p>内存分配：<br>（1）有足够空闲区（同动态分区）<br>最先适应<br>最佳适应<br>最坏适应<br>（2）没有足够空闲区（同请求页式）<br>FIFO，LRU，如果淘汰一段不能满足要求，就要进行多次淘汰</p>
<p>地址映射：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey19.png?raw=true" alt="Image text"></p>
<p>页式管理与段式管理的比较：<br>– 分页是出于系统管理的需要，分段是出于用户应用的需要<br>– 页大小是系统固定的，而段大小则通常不固定。<br>– 逻辑地址表示：<br>• 分页是一维的，各个模块在链接时必须组织成同一个地址空间；<br>• 分段是二维的，各个模块在链接时可以每个段组织成一个地址空间。<br>– 通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</p>
<p>6、段页式存储管理<br>– 分段结构具有逻辑上清晰的优点，但它的一个致命弱点是每个段必须占据主存储器的连续区域，为了克服这个缺点，可兼用分段和分页的方法，构成段页式存储管理。<br>– 每个作业仍按逻辑分段，把每个段再分成若干个页面，每一段不必占据连续的主存空间，可把它按页存放在不连续的主存块中。</p>
<p>6.1  基 本 思 想<br>– 用户程序划分：按段式划分（对用户来讲，按段的逻辑关系进行划分；对系统讲，按页划分每一段）<br>内存划分：按页式存储管理方案<br>内存分配：以页为单位进行分配<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey20.png?raw=true" alt="Image text"></p>
<p>段 表 和 页 表：<br>（1）在段页式系统中,每个分段又被分成若干个固定大小的页面，那么每个段又必须建立一张页表把段中的虚页变换成内存中的实际页面。显然，与页式管理时相同，页表中也要有相应的实现缺页中断处理和页面保护等功能表项。<br>（2）每个段有一个页表，段表中应有专项指出该段所对应页表的页表始址和页表长度</p>
<p>段 表 、 页 表 与 内 存 关 系：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey21.png?raw=true" alt="Image text"></p>
<p>段页式地址变换：<br>注：在段页式系统中，为了获取一条指令或数据，需三次访问内存。<br>• 第一次访问，是访问内存中的段表，从中取得页表始址<br>• 第二次访问，是访问内存中的页表，从中取得物理块号，并将该块号与页内地址一起形成指令或数据的物理地址<br>• 第三次访问，才是真正从第二次访问的地址中，取得指令和数据</p>
<p>抖 动：<br>– 虚存中，页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行的时间还多，此时系统效率急剧下降，甚至导致系统崩溃。这种现象称为颠簸或抖动<br>– 原因：<br>• 页面淘汰算法不合理<br>• 分配给进程的物理页面数</p>
<p>一点总结：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey22.png?raw=true" alt="Image text"><br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey23.png?raw=true" alt="Image text"><br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osmey24.png?raw=true" alt="Image text"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/29/OS存储管理/" data-id="cjuc6lbd00011lss6hlktyk10" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OS处理机管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/28/OS处理机管理/" class="article-date">
  <time datetime="2019-03-28T09:56:31.303Z" itemprop="datePublished">2019-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/28/OS处理机管理/">操作系统-处理机管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、调度的性能准则:<br>– （平均）周转时间：作业从提交到完成的时间（用户角度）<br>周转时间：Ti=Tc-Ts<br>Tc作业完成时刻；<br>Ts作业进入系统时刻</p>
<p>平均周转时间：（T1+T2+…+Tn)/n</p>
<p>– （平均）带权周转时间：周转时间 / CPU运行时间（用户角度）<br>带权周转时间:<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi7.png?raw=true" alt="Image text"></p>
<p>平均带权周转时间：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi8.png?raw=true" alt="Image text"></p>
<p>– 吞吐量：单位时间内所完成的作业数<br>– 处理机利用率：CPU运行时间 / 总时间<br>– 各种设备的均衡利用：如CPU繁忙的作业和I/O繁忙的作业搭配</p>
<p>调度的类型:<br>– 作业：又称为”宏观调度”、”高级调度”。从用户工作流程的角度，一次提交的若干个流程。<br>– 内外存交换：又称为”中级调度”。从存储器资源的角度。将进程的部分或全部换出到外存上，将当前所需部分换入到内存。指令和数据必须在内存里才能被CPU直接访问。<br>– 进程：又称为”微观调度”<br>、<br>“低级调度”。从CPU资源<br>的角度，执行的单位。时间上通常是毫秒。因为执行频<br>繁，要求在实现时达到高效率</p>
<p>2、处理机调度算法<br>2.1 先 来 先 服 务（非抢占方式）<br>按先后顺序进行调度</p>
<p>2.2 短 作 业 优 先（非抢占方式）<br>又称为“短进程优先”SPN(Shortest Process<br>Next)；这是对FCFS算法的改进，其目标是减少平均周<br>转时间</p>
<p>– 优点：<br>• 比FCFS改善平均周转时间和平均带权周转时间，缩短作业<br>的等待时间；<br>• 提高系统的吞吐量；<br>– 缺点：<br>• 对长作业非常不利，可能长时间得不到执行；<br>• 未能依据作业的紧迫程度来划分执行的优先级；<br>• 难以准确估计作业（进程）的执行时间，从而影响调度性<br>能</p>
<p>2.3 最短剩余时间优先（抢占式）<br>允许比当前进程剩余时间更短的进程来抢占</p>
<p>2.4 最高响应比优先（非抢占方式）<br>• 响应比R = (等待时间 + 要求执行时间) / 要求执行时间<br>• 是FCFS和SJF的折衷</p>
<p>2.5 时间片轮转(Round Robin)算法<br>本算法主要用于微观调度，说明怎样并发运行，即切换的方式；设计目标是提高资源利用率。<br>其基本思路是通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率；</p>
<p>2.6 多级队列算法(Multiple-level Queue)<br>各队列的不同处理：不同队列可有不同的优先级、时间片长度、调度策略等</p>
<p>2.7 优先级算法(Priority Scheduling)（可分成抢先式和非抢先式）<br>1）静态优先级<br>– 创建进程时就确定，直到进程终止前都不改变。通常是一个整数</p>
<p>2）动态优先级<br>在就绪队列中，等待时间延长则优先级提高，从而使优先级较低的进程在等待足够的时间后，其优先级提高到可被调度执行；<br>– 进程每执行一个时间片，就降低其优先级，从而一个进程持续执行时，其优先级降低到出让CPU</p>
<p>注意：<br>I/O型进程：让其进入最高优先级队列，以及时响应I/O交互。通常执行一个小时间片，要求可处理完一次I/O请求的数据，然后转入到阻塞队列。<br>– 计算型进程：每次都执行完时间片，进入更低级队列。最终采用最大时间片来执行，减少调度次数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/28/OS处理机管理/" data-id="cjuc6lbat0002lss620bbi8mb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OS进程管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/28/OS进程管理/" class="article-date">
  <time datetime="2019-03-28T08:35:47.114Z" itemprop="datePublished">2019-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/28/OS进程管理/">操作系统-进程管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、程序<br>1.1 顺序程序<br>我们把一个具有独立功能的程序独占处理机直至最终结束的过程称为程序的顺序执行</p>
<p>特征：<br>– 顺序性：各条指令按照严格的顺序执行。<br>– 封闭性：程序执行得到的最终结果由给定的初始条<br>件决定，独占资源，不受外界影响。<br>– 可再现性：初始条件相同，则重复执行的结果相同<br>（与执行速度无关）。</p>
<p> 1.2 并发程序<br> – 并发的目的：增强处理能力，提高资源利用率。<br>– 并发的含义：在一定时间内有多个程序同时处于运<br>行但尚未结束的状态，并且次序事先确定的</p>
<p>特征：<br>– 间断(异步)性：由于并发程序之间的制约，导致<br>“走走停停”，一个程序可能走到中途停下来；<br>– 失去封闭性：共享资源，受其他程序的影响。如：<br>一个程序写到存储器中的数据可能被另一个程序修改，<br>失去原有的不变特征。<br>– 失去可再现性：失去封闭性 －&gt;失去可再现性；外<br>界环境在程序的两次执行期间发生变化，失去原有的可<br>重复特征。</p>
<p>2、进 程<br>2.1 定义：Process<br>程序在执行过程中分配和管理资源的基本单位<br>（这里的程序指的是一组操作序列，具有动态特性）。</p>
<p>2.2 程序与进程之间的区别：<br>– 程序是静态的，进程是动态的，强调执行过程<br>– 进程具有并行特征，即不考虑资源共享的情况下，<br>各个进程的执行是独立的，执行速度是异步的。而程序<br>不反映执行过程，不具有并行特征<br>– 进程是竞争系统资源的基本单位<br>– 不同的进程可以包含同一程序，只要对应的数据集<br>不同</p>
<p>2.3 进程的特征<br>（1）并发性。可以同其他进程一道向前推进。<br>（2）动态性。进程是程序的执行过程，动态产生，<br>动态消亡，状态变换。<br>（3）独立性。一个进程是一个相对完整的资源分配<br>单位。<br>（4）交往性。进程之间的相互作用。<br>（5）异步性。各个进程按照各自独立的、不可预知<br>的速度向前推进。</p>
<p>2.4 进 程 的 描 述<br>进程的静态描述由三部分组成：PCB，程序段，数据<br>集。<br>• PCB是系统感知进程的唯一实体；<br>• 程序描述进程所需要完成的功能；<br>• 而数据集是程序执行的对象</p>
<p>2.5 进程控制块(Process Control Block)<br>– 系统为了管理进程设置的一个专门的数据结构，用<br>它来记录进程的外部特征，描述进程的运动变化过程<br>– 系统利用PCB来控制和管理进程，所以PCB是系统感<br>知进程存在的唯一标志<br>– 进程与PCB是一一对应的</p>
<p>2.6 进 程 状 态 及 其 转 换<br>– 运行态（Running）：<br>进程占有CPU，并在CPU上运行<br>– 就绪态（Ready）：<br>一个进程已经具备运行条件，但由于无CPU暂<br>时不能运行的状态（当调度给其CPU时，立即可以<br>运行）<br>– 等待态（Waiting/Blocked）：<br>指进程因等待某种事件的发生而暂时不能运行<br>的状态（即使CPU空闲，该进程也不可运行）</p>
<p>1）三状态图：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro1.png?raw=true" alt="Image text"></p>
<p>2）五状态图：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro2.png?raw=true" alt="Image text"></p>
<p>3）七状态图：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro3.png?raw=true" alt="Image text"></p>
<p>3、线 程<br>进程：资源分配单位（存储器、文件）和CPU调度（分派）单位。<br>又称为”任务(task) “</p>
<p>线程：作为CPU调度单位，而进程作为其他资源分配单位。一个进<br>程内的基本调度单位。（轻权进程）</p>
<p>–线程：有时称轻量级进程<br>• 进程中的一个运行实体<br>• 是一个CPU调度单位<br>• 只拥有必不可少的资源，如：线程状态、寄存器上下文和栈<br>• 同样具有就绪、阻塞和执行三种基本状态</p>
<p>线程的优点：减小并发执行的时间和空间开销（线程的创建、退<br>出和调度），因此容许在系统中建立更多的线程来提高并发程度（进<br>程间的并发到进程内的并发）。提高系统执行效率，减少处理机空转<br>时间。<br>• 线程的创建时间比进程短；<br>• 线程的终止时间比进程短；<br>• 同进程内的线程切换时间比进程短；<br>• 由于同进程内线程间共享内存和文件资源，可直接进行不通过<br>内核的通信</p>
<p>4、进程与线程比较<br>– 进程：<br>• 资源分配的基本单位（PCB）；<br>• 抢占处理机的调度单位；<br>• 完整的虚拟地址空间；<br>• 由正文集，数据集和PCB组成；<br>• 进程切换时，涉及到有关资源信息的保存和地址空间的变化<br>• 进程调度与切换：操作系统内核完成；<br>– 线程：<br>• 与资源分配无关，与所属进程内的其他线程共享进程资源；<br>• 与所属进程内的其他线程共享同一地址空间；<br>• 由相关堆栈（系统栈或用户栈）寄存器和TCB组成，寄存器用来存放<br>存储在线程内的局部量；<br>• 线程切换时，不涉及到资源信息的保存和地址空间的变化，减少系统<br>的开销；<br>• 线程调度与切换：既可由操作系统内核完成，也可由用户程序进行；</p>
<p>线 程 的 分 类：<br>– 基本类型<br>• 用户级线程<br>• 系统级线程（核心级、内核级</p>
<p>4、进 程 控 制<br>– 所谓进程控制，就是系统使用一些具有特定功能的程序段来创建、撤销进程以及完成进程各状态间的转换，从而达到多进程高效率并发执行和协调，实现资源共享的目的。</p>
<p>– 原语：把系统下执行的某些具有特定功能的程序段称为原语，原语是不能被中断的。用于进程控制的原语有创建原语、撤销原语、阻塞原语、唤醒原语等等。</p>
<p>– 临界区：把系统中不允许同时多个进程访问的资源称为临界资源，而在进程中访问临界资源的那段程序称为临界区<br>注意：临界区不是资源，而是程序段</p>
<p>– 互斥：把不允许两个以上的共享某公有资源的并发进程同时进入临界区称为互斥<br>互斥的原则：<br>（1）空闲让进<br>（2）忙则等待<br>（3）有限等待<br>（4）让权等待</p>
<p>5、信 号量 和 P,V原 语<br>信号量（Semaphore）：信号量是一种特殊的变量，它的表面形式是一个整数附加一个队列。<br>信号量用于管理临界区的公有资源，信号量sem是一个整数<br>• sem大于等于0时代表可供并发进程使用的资源实体数<br>• sem小于0时则表示正在等待使用临界区的进程数。</p>
<p>P 原 语：(堵塞条件：s.value &lt; 0)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore s;</span><br><span class="line">P(s)</span><br><span class="line">&#123;</span><br><span class="line">封锁中断；<span class="comment">//该原语执行过程中不允许中断</span></span><br><span class="line">s.value = s.value – <span class="number">1</span>；</span><br><span class="line"><span class="keyword">if</span> (s.value &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">保护当前进程CPU现场；</span><br><span class="line">该进程状态置为等待状态；</span><br><span class="line">将该进程的PCB插入相应的等待队列末尾s.queue；</span><br><span class="line">转进程调度；</span><br><span class="line">&#125;</span><br><span class="line">开中断；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>V 原 语:(唤醒条件：s.value &lt;= 0)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore s;</span><br><span class="line">V(s)</span><br><span class="line">&#123;</span><br><span class="line">封锁中断；</span><br><span class="line">s.value = s.value + <span class="number">1</span>；</span><br><span class="line"><span class="keyword">if</span> (s.value &lt; = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">唤醒相应等待队列s.queue中的一个等待进程；</span><br><span class="line">改变其状态为就绪态；</span><br><span class="line">并将其插入就绪队列；</span><br><span class="line">转进程调度；</span><br><span class="line">&#125;</span><br><span class="line">开中断；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6、进 程 同 步<br>进程同步：把一组并发进程，因直接制约而相互发送消息进行互相合作，互相等待，使得各进程按一定的速度执行的过程称为进程间的同步<br>私 用 信 号 量：一般来说，也可以把各进程之间发送的消息作为信号量看待。与进程互斥时不同的是，这里的信号量只与制约进程及被制约进程有关，而不是与整组并发进程有关。因此，该信号量为私用信号量。<br>互斥时使用的信号量为公用信号量，同步时使用的信号量为私用信号量。</p>
<p>举例：司 机 — 售 票 员 问 题<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro4.png?raw=true" alt="Image text"><br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro5.png?raw=true" alt="Image text"></p>
<p>7、管 程<br>定义：指关于共享资源的数据及在其上操作的一组过程或共享数据结构及其规定的所有操作</p>
<p>管程有如下几个要素：<br>（一）管程中的共享变量在管程外部是不可见的，外部只能通过调用管程中所说明的外部过程（函数）来间接地访问管程中的共享变量<br>（二）为了保证管程共享变量的数据完整性，规定管程互斥进入<br>（三）管程通常是用来管理资源的，因而在管程中应当设有进程等待队列以及相应的等待及唤醒操作</p>
<p>8、进 程 通 信<br>进程通信：进程之间互相交换信息的工作称之为进程通信IPC(InterProcess Communication)。<br>8.1 进程间通信的类型<br>– 低级通信：只能传递状态和整数值（控制信息），包括进程互斥和同步所采用的信号量机制。<br>– 高级通信：能够传送任意数量的数据，包括三类：共享存储区、管道、消息。<br>– 直接通信：信息直接传递给接收方，如管道。<br>间接通信：借助于收发双方进程之外的共享数据结构作为通信中转，如消息队列。</p>
<p>8.2 共享存储区通信机制<br>内存中开辟一个共享存储区，诸进程通过该区实现通信,这是进程通信中最快的方法。</p>
<p>8.3 管 道 通 信 机 制<br>管道(pipe)是连接读写进程的一个特殊文件，允许进程按先进先出方式传送数据。发送进程以字符流形式<br>把大量数据送入管道，接收进程从管道中接收数据，所以，也叫管道通信<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro6.png?raw=true" alt="Image text"></p>
<p>8.4 消息传递机制<br>1）直接通信方式<br>在直接通信方式下，企图发送或接收消息的每个进程必须指出信件发给谁或从谁那里接收消息，可用send原语和receive原语为实现进程之间的通信<br>2）间接通信方式<br>采用间接通信方式时，进程间发送或接收消息通过一个信箱来进行，消息可以被理解成信件，每个信箱有一个唯一的标识符。</p>
<p>9、死锁<br>现象：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro7.png?raw=true" alt="Image text"></p>
<p>定义：一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到资源，这种现象称为进程死锁，这一组进程就称为死锁进程<br>– 参与死锁的进程最少是两个（两个以上进程才会出现死锁）<br>– 参与死锁的进程至少有两个已经占有资源<br>– 参与死锁的所有进程都在等待资源<br>– 参与死锁的进程是当前系统中所有进程的子集</p>
<p>资源：<br>– 永久性资源：可以被多个进程多次使用（可重用资<br>源）<br>• 可抢占资源<br>• 不可抢占资源<br>– 临时性资源：只可使用一次的资源；如信号量,中断<br>信号，同步信号等（可消耗性资源）<br>• “申请–分配–使用–释放”模式</p>
<p>例 子：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro8.png?raw=true" alt="Image text"><br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro9.png?raw=true" alt="Image text"></p>
<p>10、产生死锁的四个必要条件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">互斥使用（资源独占）</span><br><span class="line">不可强占（不可剥夺）</span><br><span class="line">请求和保持（部分分配，占有已分配）</span><br><span class="line">循环等待（环路等待）</span><br></pre></td></tr></table></figure></p>
<p>解决死锁的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 不考虑此问题（鸵鸟政策）</span><br><span class="line"><span class="number">2</span>) 预防死锁（破坏死锁条件）</span><br><span class="line"><span class="number">3</span>) 避免死锁（分配过程中采用策略）</span><br><span class="line"><span class="number">4</span>) 检测死锁（允许发生死锁）</span><br><span class="line"><span class="number">5</span>) 解除死锁（与检测死锁配套）</span><br></pre></td></tr></table></figure></p>
<p>1）鸵鸟政策<br>最简单的方法是象鸵鸟一样对死锁视而不见。</p>
<p>2) 死锁预防（破坏死锁条件）<br>在系统设计时确定资源分配算法，限制进程对资源的申请，从而保证不发生死锁。<br>具体的办法是破坏产生死锁的必要条件：<br>（1）破坏“不可剥夺”条件<br>一个进程在申请新资源的要求不能立即得到满足时，便处于等待状态。而一个处于等待状态的进程的全部资源可以被剥夺。该进程重新获得它原有的资源以及得到新申请的资源时，才能重新启动执行。</p>
<p>（2）破坏“请求和保持”条件<br>方法一：采用静态分配策略<br>每个进程在开始执行前就申请他所需要的所有资源，只有当系统能够把资源一次性分配，该进程才能执行。<br>缺点：资源浪费严重。<br>方法二：<br>如果进程已经占用资源同时再去申请资源，则它应该首先释放已占有的资源再重新申请新资源</p>
<p>（3）破坏“循环等待”条件<br>采用资源有序分配法：<br>把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进行，否则操作系统不予分配；释放资源时，应按编号递减次序进行。</p>
<p>3) 死锁避免（分配过程中采用策略）<br>在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配</p>
<p>与死锁预防的区别：<br>死锁预防是设法破坏产生死锁的必要条件，严格防止死锁的发生。而死锁避免则没有这么严格，它是一种动态策略</p>
<p>安全状态：<br>如果存在一个由系统中所有进程构成的安全序列P1，„Pn，则系统处于安全状态。<br>一个进程序列{P1，„，Pn}是安全的，如果对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和，系统处于安全状态，不会发生死锁。</p>
<p>不安全状态:<br>不存在一个安全序列，不安全状态不一定导致死锁</p>
<p>银行家算法：<br>银行家算法的基本思想是：<br>在安全状态下系统收到一个进程的资源请求后,先把资源试探性分配给它。在进程集合中找到剩余资源能满足最大需求量的进程,从而保证这个进程运行完毕并归还全部资源。这时,把这个进程从集合中去掉, 系统的剩余资源更多了,再反复执行上述步骤。<br>最后,检查进程集合,若为空表明本次申请可行,系统处于安全状态,可真正实施本次分配;否则,有进程执行不完，系统处于不安全状态,本次资源分配暂不实施,让申请进程等待。</p>
<p>银行家例子：第一次分配后的系统状态<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro10.png?raw=true" alt="Image text"><br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro11.png?raw=true" alt="Image text"></p>
<p>新 的 系 统 状 态：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro12.png?raw=true" alt="Image text"></p>
<p>4）死锁检测<br>允许死锁发生，操作系统不断监视系统进展情况，判断死锁是否发生。<br>最常用的检测死锁的方法就是对资源分配图进行化简。<br>①在图中找一个请求边均能立即满足的一个进程顶点Pi；<br>②若找到了这样的Pi，则将与Pi相连的边全部删去，转①</p>
<p>如果化简后所有的进程顶点都成了孤立点，则称该图可完全化简，否则不可完全化简(是产生死锁的充分必要条件，非孤立点的进程处于死锁状态。</p>
<p>5）死锁解除<br>一般通过破坏循环等待条件<br>从死锁进程集合中选择一个或多个进程予以删除，并剥夺它们的资源给其它的进程使用。选择要删除的进程时，一般从优先级、已运行时间及已用多少资源等几个方面去考虑，使系统损失最小</p>
<p>6）死锁的综合处理<br>一般来说，无论哪种方法都无法适用于每类资源，可以把系统中的全部资源分成几大类，整体上采用有序资源分配法，再对每类资源根据其特点选择最合适的方法。<br>例如，系统中有以下几类资源：<br>①主存；<br>②作业资源(打印机、磁带驱动器、文件等)；<br>③辅存。<br>将①②③类资源编号为1、2、3，按有序资源申请。对第①类<br>采用剥夺法；<br>对第②类采用死锁避免法；<br>对第③类采用静态资源分配法；</p>
<p>11、资 源 分 配 图<br>资源类（资源的不同类型）<br>-用方框表示<br>资源实例（存在于每个资源中）<br>-用方框中的黑圆点表示<br>进程<br>-用圆圈中加进程名表示<br>分配边：<br>资源实例→进程的一条有向边<br>申请边：<br>进程→资源类的一条有向边</p>
<p>11.1 有环有死锁<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro13.png?raw=true" alt="Image text"></p>
<p>11.2 有环无死锁<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/ospro14.png?raw=true" alt="Image text"></p>
<p>11.3 死锁定理<br>如果资源分配图中没有环路，则系统中没有死锁，如果图中存在环路则系统中可能存在死锁<br>如果每个资源类中只包含一个资源实例，则环路是死锁存在的充分必要条件</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/28/OS进程管理/" data-id="cjuc6lbd00013lss67i6zi5kw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/10/设计模式-备忘录模式/">设计模式-备忘录模式</a>
          </li>
        
          <li>
            <a href="/2019/04/05/设计模式-策略模式/">设计模式-策略模式</a>
          </li>
        
          <li>
            <a href="/2019/04/05/设计模式-RMI/">设计模式总结</a>
          </li>
        
          <li>
            <a href="/2019/04/01/Java-对象导论/">Thinking in Java - 对象导论</a>
          </li>
        
          <li>
            <a href="/2019/03/30/数据库总结/">数据库总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>