<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-21T14:11:10.723Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GO：2.5 使用函数的正确姿势</title>
    <link href="http://yoursite.com/2020/07/21/GO%EF%BC%9A2-5-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/2020/07/21/GO%EF%BC%9A2-5-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</id>
    <published>2020-07-21T10:20:24.000Z</published>
    <updated>2020-07-21T14:11:10.723Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、函数是一等的数据类型"><a href="#1、函数是一等的数据类型" class="headerlink" title="1、函数是一等的数据类型"></a>1、函数是一等的数据类型</h3><p>在 Go 语言中，函数类型是一等的数据类型。</p><p>简单来说，这意味着函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等，就像切片和字典的值那样。</p><p>深层次的含义就是：函数值可以由此成为能够被随意传播的独立逻辑组件（或者说功能模块）。</p><p>对于函数类型来说，它是一种对一组输入、输出进行模板化的重要工具，它比接口类型更加轻巧、灵活，它的值也借此变成了可被热替换的逻辑组件。<br>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Printer <span class="function"><span class="keyword">func</span><span class="params">(contents <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">//先声明一个函数类型Printer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printToStd</span><span class="params">(contents <span class="keyword">string</span>)</span> <span class="params">(bytesNum <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">//定义一个函数printToStd</span></span><br><span class="line">  <span class="keyword">return</span> fmt.Println(contents)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> p Printer</span><br><span class="line">  p = printToStd</span><br><span class="line">  p(<span class="string">"something"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可以说它们是一样的函数，或者说是实现了同一个函数类型的函数。</p><hr><p><strong>*函数的签名其实就是函数的参数列表和结果列表的统称，它定义了可用来鉴别不同函数的那些特征，同时也定义了我们与函数交互的方式</strong>。*</p><hr><p>注意，各个参数和结果的<strong>名称</strong>不能算作函数签名的一部分，甚至对于结果声明来说，没有名称都可以。</p><p>严格来说，函数的名称也不能算作函数签名的一部分，它只是我们在调用函数时，需要给定的标识符而已。</p><p>所以函数Printer的签名与printToStd的是一致的，printToStd可以看作是Printer的一个实现，即使它们的名称以及有的结果名称是不同的。</p><p>通过main函数中的代码，我们就可以证实这两者的关系了，顺利地把printToStd函数赋给了Printer类型的变量p，并且成功地调用了它。</p><h3 id="2、高阶函数"><a href="#2、高阶函数" class="headerlink" title="2、高阶函数"></a>2、高阶函数</h3><h4 id="1、什么是高阶函数？"><a href="#1、什么是高阶函数？" class="headerlink" title="1、什么是高阶函数？"></a>1、什么是高阶函数？</h4><p>简单地说，高阶函数可以满足下面的两个条件：</p><ul><li>1、<strong>接受其他的函数作为参数传入；</strong></li><li>2、<strong>把其他的函数作为结果返回。</strong></li></ul><p>只要满足了其中任意一个特点，我们就可以说这个函数是一个高阶函数。高阶函数也是函数式编程中的重要概念和特征。</p><p>例：编写calculate函数来实现两个整数间的加减乘除运算，但是希望两个整数和具体的操作都由该函数的调用方给出，那么，这样一个函数应该怎样编写呢？<br>1、首先声明一个名叫operate的函数类型，它有两个参数和一个结果，都是int类型的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> operate <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure></p><p>2、然后编写calculate函数的签名部分。这个函数除了需要两个int类型的参数之外，还应该有一个operate类型的参数。</p><p>该函数的结果应该有两个，一个是int类型的，代表真正的操作结果，另一个应该是error类型的，因为如果那个operate类型的参数值为nil，那么就应该直接返回一个错误。（函数类型是引用类型，它的零值是nil）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>, op operate)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> op == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"invalid operation"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> op(x, y), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>calculate函数实现：先用卫述语句检查一下参数，如果operate类型的参数op为nil，那么就直接返回0和一个代表了具体错误的error类型值。如果检查无误，那么就调用op并把那两个操作数传给它，最后返回op返回的结果和代表没有错误发生的nil。</p><hr><p><em>卫述语句是指被用来检查关键的先决条件的合法性，并在检查未通过的情况下立即终止当前代码块执行的语句。在 Go 语言中，if 语句常被作为卫述语句。</em></p><hr><p>3、在该例中，重点是：让函数在其他函数间传递。<br>calculate函数的第三个参数是operate类型，而且operate类型就是一个函数类型。在调用calculate函数的时候，我们需要传入一个operate类型的函数值。这个函数值应该怎么写？</p><p>只要它的签名与operate类型的签名一致，并且实现得当就可以了。我们可以像上一个例子那样先声明好一个函数，再把它赋给一个变量，也可以直接编写一个实现了operate类型的匿名函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">op := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>calculate函数就是一个高阶函数。但是我们说高阶函数的特点有两个，而该函数只展示了其中一个特点，即：<strong>接受其他的函数作为参数传入</strong>。</p><p>那另一个特点，把其他的函数作为结果返回。如下;<br>声明函数类型calculateFunc和函数genCalculator。其中，genCalculator函数的唯一结果的类型就是calculateFunc。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> operate <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案1。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>, op operate)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> op == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"invalid operation"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> op(x, y), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案2。</span></span><br><span class="line"><span class="keyword">type</span> calculateFunc <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genCalculator</span><span class="params">(op operate)</span> <span class="title">calculateFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> op == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"invalid operation"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> op(x, y), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 方案1。</span></span><br><span class="line">x, y := <span class="number">12</span>, <span class="number">23</span></span><br><span class="line">op := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">result, err := calculate(x, y, op)</span><br><span class="line">fmt.Printf(<span class="string">"The result: %d (error: %v)\n"</span>,</span><br><span class="line">result, err)</span><br><span class="line">result, err = calculate(x, y, <span class="literal">nil</span>)</span><br><span class="line">fmt.Printf(<span class="string">"The result: %d (error: %v)\n"</span>,</span><br><span class="line">result, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案2。</span></span><br><span class="line">x, y = <span class="number">56</span>, <span class="number">78</span></span><br><span class="line">add := genCalculator(op)</span><br><span class="line">result, err = add(x, y)</span><br><span class="line">fmt.Printf(<span class="string">"The result: %d (error: %v)\n"</span>,</span><br><span class="line">result, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、如何实现闭包？"><a href="#3、如何实现闭包？" class="headerlink" title="3、如何实现闭包？"></a>3、如何实现闭包？</h3><p>1、闭包是什么？<br>你可以想象一下，在一个函数中存在对外来标识符的引用。所谓的外来标识符，既不代表当前函数的任何参数或结果，也不是函数内部声明的，它是直接从外边拿过来的。</p><p>还有个专门的术语称呼它，叫<strong>自由变量</strong>，可见它代表的肯定是个变量。实际上，如果它是个常量，那也就形成不了闭包了，因为常量是不可变的程序实体，而<strong>闭包体现的却是由“不确定”变为“确定”的一个过程</strong>。</p><p>这个函数（以下简称<strong>闭包函数</strong>）就是因为引用了自由变量，而呈现出了一种“不确定”的状态，也叫“开放”状态。</p><p>也就是说，它的内部逻辑并不是完整的，有一部分逻辑需要这个自由变量参与完成，而后者到底代表了什么在闭包函数被定义的时候却是未知的。</p><p>即使对于像 Go 语言这种静态类型的编程语言而言，我们在定义闭包函数的时候最多也只能知道自由变量的类型。</p><p>在genCalculator函数内部，实际上就实现了一个闭包，而genCalculator函数也是一个高阶函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genCalculator</span><span class="params">(op operate)</span> <span class="title">calculateFunc</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> op == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"invalid operation"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> op(x, y), <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>enCalculator函数只做了一件事，那就是定义一个匿名的、calculateFunc类型的函数并把它作为结果值返回。</p><p>而这个匿名的函数就是一个闭包函数。它里面使用的变量op既不代表它的任何参数或结果，也不是它自己声明的，而是定义它的genCalculator函数的参数，所以是一个自由变量。</p><p>只有给定了该函数的参数op，我们才能知道它返回给我们的闭包函数可以用于什么运算。</p><p>看到if op == nil {那一行了吗？Go 语言编译器读到这里时会试图去寻找op所代表的东西，它会发现op代表的是genCalculator函数的参数，然后，它会把这两者联系起来。这时可以说，自由变量op被“<strong>捕获</strong>”了。</p><p>当程序运行到这里的时候，op就是那个参数值了。如此一来，这个闭包函数的状态就由“不确定”变为了“确定”，或者说转到了“闭合”状态，至此也就真正地形成了一个闭包。</p><p>我们在用高阶函数实现闭包。这也是高阶函数的一大功用。<br><img src="/2020/07/21/GO：2-5-使用函数的正确姿势/fun1.png" alt="fun1"><br>（高阶函数与闭包）</p><p>那么，实现闭包的意义又在哪里呢？<br>表面上看，我们只是延迟实现了一部分程序逻辑或功能而已，但实际上，我们是在动态地生成那部分程序逻辑。</p><h3 id="4、传入函数的那些参数值后来怎么样了？"><a href="#4、传入函数的那些参数值后来怎么样了？" class="headerlink" title="4、传入函数的那些参数值后来怎么样了？"></a>4、传入函数的那些参数值后来怎么样了？</h3><p>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  array1 := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"The array: %v\n"</span>, array1)</span><br><span class="line">  array2 := modifyArray(array1)</span><br><span class="line">  fmt.Printf(<span class="string">"The modified array: %v\n"</span>, array2)</span><br><span class="line">  fmt.Printf(<span class="string">"The original array: %v\n"</span>, array1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(a [3]<span class="keyword">string</span>)</span> [3]<span class="title">string</span></span> &#123;</span><br><span class="line">  a[<span class="number">1</span>] = <span class="string">"x"</span></span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The array: [a b c]</span><br><span class="line">The modified array: [a x c]</span><br><span class="line">The original array: [a b c]</span><br></pre></td></tr></table></figure></p><p>由输出结果知：<br>数组不会改变，因为<strong>所有传给函数的参数值都会被复制</strong>，<strong>函数在其内部使用的并不是参数值的原值，而是它的副本</strong>。</p><p>由于<strong>数组是值类型</strong>，所以每一次复制都会拷贝它，以及它的所有元素值。我在modify函数中修改的只是原数组的副本而已，并不会对原数组造成任何影响。</p><p>注意，对于引用类型，比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。也就是说，这时只是浅表复制，而不是深层复制。</p><p>以<strong>切片</strong>值为例，如此复制的时候，只是<strong>拷贝了它指向底层数组中某一个元素的指针</strong>，以及它的<strong>长度值</strong>和<strong>容量值</strong>，而它的<strong>底层数组并不会被拷贝</strong>。</p><p>另外还要注意，就算我们传入函数的是一个值类型的参数值，但如果这个参数值中的某个元素是引用类型的，那么我们仍然要小心。<br>如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">complexArray1 := [<span class="number">3</span>][]<span class="keyword">string</span>&#123;</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complexArray2 := modifyArray(complexArray1)</span><br><span class="line">fmt.Printf(<span class="string">"The modified array: %v\n"</span>, complexArray2)</span><br><span class="line">fmt.Printf(<span class="string">"The original array: %v\n"</span>, complexArray1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(a [3][]<span class="keyword">string</span>)</span> [3][]<span class="title">string</span></span> &#123;</span><br><span class="line">a[<span class="number">0</span>]=[]<span class="keyword">string</span>&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量complexArray1是[3][]string类型的，也就是说，虽然它是一个数组，但是其中的每个元素又都是一个切片。</p><p>这样一个值被传入函数的话，函数中对该参数值的修改会影响到complexArray1本身吗？<br>答案是会的</p><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The modified array: [[a b c] [g h i] [j k l]]</span><br><span class="line">The original array: [[d e f] [g h i] [j k l]]</span><br></pre></td></tr></table></figure></p><p>函数传参相关原则：既不要把你程序的细节暴露给外界，也尽量不要让外界的变动影响到你的程序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、函数是一等的数据类型&quot;&gt;&lt;a href=&quot;#1、函数是一等的数据类型&quot; class=&quot;headerlink&quot; title=&quot;1、函数是一等的数据类型&quot;&gt;&lt;/a&gt;1、函数是一等的数据类型&lt;/h3&gt;&lt;p&gt;在 Go 语言中，函数类型是一等的数据类型。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GO：2.4 通道channel</title>
    <link href="http://yoursite.com/2020/07/20/GO%EF%BC%9A2-4-%E9%80%9A%E9%81%93channel/"/>
    <id>http://yoursite.com/2020/07/20/GO%EF%BC%9A2-4-%E9%80%9A%E9%81%93channel/</id>
    <published>2020-07-20T13:54:35.000Z</published>
    <updated>2020-07-21T10:18:54.023Z</updated>
    
    <content type="html"><![CDATA[<p>作为 Go 语言最有特色的数据类型，通道（channel）完全可以与 goroutine（也可称为 go 程）并驾齐驱，共同代表 Go 语言独有的并发编程模式和编程哲学。</p><hr><p><em>Don’t communicate by sharing memory; share memory by communicating. （不要通过共享内存来通信，而应该通过通信来共享内存。）</em></p><hr><p>这句话充分体现了 Go 语言最重要的编程理念。通道类型是后半句话的完美实现，我们可以利用通道在多个 goroutine 之间传递数据。</p><h3 id="1、通道的基础知识"><a href="#1、通道的基础知识" class="headerlink" title="1、通道的基础知识"></a>1、通道的基础知识</h3><p><strong>通道类型的值本身就是并发安全的</strong>，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。它使用起来十分简单，并不会徒增我们的心智负担。</p><p>在声明并初始化一个通道的时候，我们需要用到 Go 语言的内建函数make。就像用make初始化切片那样，我们传给这个函数的第一个参数代表通道的具体类型的类型字面量。</p><p>在声明一个通道类型变量的时候，我们首先要确定该通道类型的元素类型，这决定了我们可以通过这个通道传递什么类型的数据。</p><p>比如，类型字面量chan int，其中的chan是表示通道类型的关键字，而int则说明了该通道类型的元素类型。又比如，chan string代表了一个元素类型为string的通道类型。</p><p>在初始化通道的时候，make函数除了必须接收这样的类型字面量作为参数，还可以接收一个int类型的参数。</p><p>后者是可选的，用于表示该通道的容量。所谓通道的容量，就是指通道最多可以缓存多少个元素值。由此，虽然这个参数是int类型的，但是它是不能小于0的。</p><p>当<strong>容量为0</strong>时，我们可以称<strong>通道为非缓冲通道</strong>，也就是不带缓冲的通道。而当<strong>容量大于0</strong>时，我们可以称为<strong>缓冲通道</strong>，也就是带有缓冲的通道。非缓冲通道和缓冲通道有着不同的数据传递方式。</p><p><strong>一个通道相当于一个先进先出（FIFO）的队列</strong>。也就是说，<strong>通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收</strong>。元素值的发送和接收都需要用到操作符&lt;-。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">  ch1 &lt;- <span class="number">2</span></span><br><span class="line">  ch1 &lt;- <span class="number">1</span></span><br><span class="line">  ch1 &lt;- <span class="number">3</span></span><br><span class="line">  elem1 := &lt;-ch1</span><br><span class="line">  fmt.Printf(<span class="string">"The first element received from channel ch1: %v\n"</span>,</span><br><span class="line">    elem1)<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>声明并初始化了一个元素类型为int、容量为3的通道ch1，并用三条语句，向该通道先后发送了三个元素值2、1和3。</p><p>由于该通道的容量为 3，所以，我可以在通道不包含任何元素值的时候，连续地向该通道发送三个值，此时这三个值都会被缓存在通道之中。</p><h3 id="2、对通道的发送和接收操作都有哪些基本的特性？"><a href="#2、对通道的发送和接收操作都有哪些基本的特性？" class="headerlink" title="2、对通道的发送和接收操作都有哪些基本的特性？"></a>2、对通道的发送和接收操作都有哪些基本的特性？</h3><p>它们的基本特性如下：</p><ul><li><p>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。</p></li><li><p>发送操作和接收操作中对元素值的处理都是不可分割的。</p></li><li><p>发送操作在完全完成之前会被阻塞。接收操作也是如此。</p></li></ul><h4 id="1、第一个基本特性"><a href="#1、第一个基本特性" class="headerlink" title="1、第一个基本特性"></a>1、第一个基本特性</h4><p> 在同一时刻，Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通道的任意个发送操作中的某一个。</p><p> 直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。</p><p> 类似的，在同一时刻，运行时系统也只会执行，对同一个通道的任意个接收操作中的某一个。</p><p> 直到这个元素值完全被移出该通道之后，其他针对该通道的接收操作才可能被执行。即使这些操作是并发执行的也是如此。</p><p> 这里所谓的并发执行，你可以这样认为，多个代码块分别在不同的 goroutine 之中，并有机会在同一个时间段内被执行。</p><p> 另外，<strong>对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的</strong>。例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，但是这时它绝不会被想接收它的一方看到和取走。</p><p> 这里要注意的一个细节是，<strong>元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。</strong></p><p> 另一方面，元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，<strong>第一步是生成正在通道中的这个元素值的副本，并准备给到接收方</strong>，<strong>第二步是删除在通道中的这个元素值。</strong></p><h4 id="2、第二个基本特性"><a href="#2、第二个基本特性" class="headerlink" title="2、第二个基本特性"></a>2、第二个基本特性</h4><p> 这里的“不可分割”的意思是，它们<strong>处理元素值时都是一气呵成</strong>的，绝不会被打断。</p><p> 例如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分的情况。</p><p> 又例如，接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。</p><p> 这既是为了保证通道中元素值的完整性，也是为了保证通道操作的唯一性。对于通道中的同一个元素值来说，它只可能是某一个发送操作放入的，同时也只可能被某一个接收操作取出。</p><h4 id="3、第三个基本特性"><a href="#3、第三个基本特性" class="headerlink" title="3、第三个基本特性"></a>3、第三个基本特性</h4><p> 一般情况下，<strong>发送操作</strong>包括了“<strong>复制元素值</strong>”和“<strong>放置副本到通道内部</strong>”这两个步骤。</p><p> 在这两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。</p><p> 更细致地说，在通道完成发送操作之后，运行时系统会通知这句代码所在的 goroutine，以使它去争取继续运行代码的机会。</p><p> 另外，<strong>接收操作</strong>通常包含了“<strong>复制通道内的元素值</strong>”“<strong>放置副本到接收方</strong>”“<strong>删掉原值</strong>”三个步骤。</p><p> 在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的 goroutine 收到了运行时系统的通知并重新获得运行机会为止。</p><p> <strong>如此阻塞代码其实就是为了实现操作的互斥和元素值的完整。</strong></p><h3 id="3、发送操作和接收操作在什么时候可能被长时间的阻塞？"><a href="#3、发送操作和接收操作在什么时候可能被长时间的阻塞？" class="headerlink" title="3、发送操作和接收操作在什么时候可能被长时间的阻塞？"></a>3、发送操作和接收操作在什么时候可能被长时间的阻塞？</h3><h4 id="1、针对缓冲通道"><a href="#1、针对缓冲通道" class="headerlink" title="1、针对缓冲通道"></a>1、针对缓冲通道</h4><p>如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。</p><p>这时，通道会优先通知最早因此而等待的、那个发送操作所在的 goroutine，后者会再次执行发送操作。</p><p>由于发送操作在这种情况下被阻塞后，它们所在的 goroutine 会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。</p><p>相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，并使它再次执行接收操作。</p><p>因此而等待的、所有接收操作所在的 goroutine，都会按照先后顺序被放入通道内部的接收等待队列。</p><h4 id="2、针对非缓冲通道"><a href="#2、针对非缓冲通道" class="headerlink" title="2、针对非缓冲通道"></a>2、针对非缓冲通道</h4><p>情况要简单一些。</p><p>无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。</p><p>由此可见，<strong>非缓冲通道</strong>是在用<strong>同步</strong>的方式传递数据。也就是说，<strong>只有收发双方对接上了，数据才会被传递</strong>。并且，<strong>数据是直接从发送方复制到接收方的</strong>，中间并不会用非缓冲通道做中转。</p><p>相比之下，<strong>缓冲通道</strong>则在用<strong>异步</strong>的方式传递数据。在大多数情况下，<strong>缓冲通道会作为收发双方的中间件</strong>。</p><p>正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。</p><p>但是，<strong>当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方</strong>。以上说的都是在正确使用通道的前提下会发生的事情。</p><p>下面我特别说明一下，由于错误使用通道而造成的阻塞。</p><p>对于<strong>值为nil的通道</strong>，<strong>不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态</strong>。它们所属的 goroutine 中的任何代码，都不再会被执行。</p><p>注意，由于<strong>通道类型是引用类型，所以它的零值就是nil</strong>。换句话说，<strong>当我们只声明该类型的变量但没有用make函数对它进行初始化时，该变量的值就会是nil</strong>。我们一定不要忘记初始化通道！</p><h3 id="4、发送操作和接收操作在什么时候会引发-panic？"><a href="#4、发送操作和接收操作在什么时候会引发-panic？" class="headerlink" title="4、发送操作和接收操作在什么时候会引发 panic？"></a>4、发送操作和接收操作在什么时候会引发 panic？</h3><p>1、对于一个<strong>已初始化，但并未关闭的通道</strong>来说，<strong>收发操作</strong>一定不会引发 panic。但是<strong>通道一旦关闭</strong>，再对它进行<strong>发送操作</strong>，就会引发 <strong>panic</strong>。</p><p>2、另外，如果我们<strong>试图关闭一个已经关闭了的通道</strong>，也会引发 panic。注意，<strong>接收操作</strong>是<strong>可以感知到通道的关闭的，并能够安全退出</strong>。</p><p>更具体地说，当我们把接收表达式的结果同时赋给两个变量时，第二个变量的类型就是一定bool类型。它的值如果为false就说明通道已经关闭，并且再没有元素值可取了。</p><p>注意，如果<strong>通道关闭时</strong>，里面<strong>还有元素值未被取出</strong>，那么<strong>接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是true。</strong></p><p>因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。</p><p>由于通道的收发操作有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事。</p><h3 id="5、单向通道"><a href="#5、单向通道" class="headerlink" title="5、单向通道"></a>5、单向通道</h3><p>我们在说“<strong>通道</strong>”的时候指的都是<strong>双向通道</strong>，即：<strong>既可以发也可以收的通道。</strong></p><p>所谓<strong>单向通道</strong>就是，<strong>只能发不能收</strong>，或者<strong>只能收不能发的通道</strong>。一个通道是双向的，还是单向的是由它的类型字面量体现的。</p><p>接收操作符&lt;-，把它用在通道的类型字面量中，那么它代表的就不是“发送”或“接收”的动作，而是表示通道的方向。<br>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uselessChan = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//1、声明并初始化uselessChan变量，类型是chan&lt;- int，容量是1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、chan&lt;-，表示通道是单向的，并且只能发而不能收，称为发送通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、如果&lt;-chan，单向通道，只能收不能发，称为接收通道</span></span><br></pre></td></tr></table></figure></p><p>注意，与发送操作和接收操作对应，这里的“发”和“收”都是站在操作通道的代码的角度上说的。</p><p>从上述变量的名字上你也能猜到，这样的通道是没用的。通道就是为了传递数据而存在的，声明一个只有一端（发送端或者接收端）能用的通道没有任何意义。那么，单向通道的用途究竟在哪儿呢？</p><h3 id="6、单向通道有什么应用价值？"><a href="#6、单向通道有什么应用价值？" class="headerlink" title="6、单向通道有什么应用价值？"></a>6、单向通道有什么应用价值？</h3><p>单向通道最主要的用途就是<strong>约束其他代码的行为</strong>。</p><p>这需要从两个方面讲，都跟函数的声明有些关系。</p><h4 id="1、第一个方面"><a href="#1、第一个方面" class="headerlink" title="1、第一个方面"></a>1、第一个方面</h4><p>先来看下面的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendInt</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  ch &lt;- rand.Intn(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用func关键字声明了一个叫做SendInt的函数。这个函数只接受一个chan&lt;- int类型的参数。在这个函数中的代码只能向参数ch发送元素值，而不能从它那里接收元素值。这就起到了约束函数行为的作用。</p><p>你可能会问，我自己写的函数自己肯定能确定操作通道的方式，为什么还要再约束？这个例子可能过于简单了，在实际场景中，这种约束一般会出现在接口类型声明中的某个方法定义上。请看这个叫Notifier的接口类型声明：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">  SendInt(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在接口类型声明的花括号中，每一行都代表着一个方法的定义。接口中的方法定义与函数声明很类似，但是只包含了方法名称、参数列表和结果列表。</p><p>一个类型如果想成为一个接口类型的实现类型，那么就必须实现这个接口中定义的所有方法。因此，如果我们在某个方法的定义中使用了单向通道类型，那么就相当于在对它的所有实现做出约束。</p><p>在这里，Notifier接口中的SendInt方法只会接受一个发送通道作为参数，所以，在该接口的所有实现类型中的SendInt方法都会受到限制。这种约束方式还是很有用的，尤其是在我们编写模板代码或者可扩展的程序库的时候。</p><p>顺便说一下，我们在调用SendInt函数的时候，只需要把一个元素类型匹配的双向通道传给它就行了，没必要用发送通道，因为 Go 语言在这种情况下会<strong>自动地把双向通道转换为函数所需的单向通道。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intChan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">SendInt(intChan1)</span><br></pre></td></tr></table></figure><h4 id="2、第二个方面"><a href="#2、第二个方面" class="headerlink" title="2、第二个方面"></a>2、第二个方面</h4><p>我们还可以在函数声明的结果列表中使用单向通道。如下所示：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntChan</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  num := <span class="number">5</span></span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, num)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">    ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(ch)</span><br><span class="line">  <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数getIntChan会返回一个&lt;-chan int类型的通道，这就意味着得到该通道的程序，只能从通道中接收元素值。这实际上就是对函数调用方的一种约束了。</p><p>另外，我们在 Go 语言中还可以声明函数类型，如果我们在函数类型中使用了单向通道，那么就相等于在约束所有实现了这个函数类型的函数。</p><p>我们再顺便看一下调用getIntChan的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intChan2 := getIntChan()</span><br><span class="line"><span class="keyword">for</span> elem := <span class="keyword">range</span> intChan2 &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"The element in intChan2: %v\n"</span>, elem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我把调用getIntChan得到的结果值赋给了变量intChan2，然后用for语句循环地取出了该通道中的所有元素值，并打印出来。</p><p>这里的for语句也可以被称为带有range子句的for语句。它的用法我在后面讲for语句的时候专门说明。现在你只需要知道关于它的三件事：</p><ul><li>1、上述for语句会不断地尝试从通道intChan2中取出元素值。即使intChan2已经被关闭了，它也会在取出所有剩余的元素值之后再结束执行。</li><li>2、通常，当通道intChan2中没有元素值时，这条for语句会被阻塞在有for关键字的那一行，直到有新的元素值可取。不过，由于这里的getIntChan函数会事先将intChan2关闭，所以它在取出intChan2中的所有元素值之后会直接结束执行。</li><li>3、倘若通道intChan2的值为nil，那么这条for语句就会被永远地阻塞在有for关键字的那一行。</li></ul><p>这就是带range子句的for语句与通道的联用方式。不过，它是一种用途比较广泛的语句，还可以被用来从其他一些类型的值中获取元素。除此之外，Go 语言还有一种专门为了操作通道而存在的语句：<strong>select</strong>语句。</p><h3 id="7、select语句与通道怎样联用，应该注意些什么？"><a href="#7、select语句与通道怎样联用，应该注意些什么？" class="headerlink" title="7、select语句与通道怎样联用，应该注意些什么？"></a>7、select语句与通道怎样联用，应该注意些什么？</h3><p>select语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行。</p><p>select语句的分支分为两种，一种叫做<strong>候选分支</strong>，另一种叫做<strong>默认分支</strong>。<strong>候选分支总是以关键字case开头</strong>，后跟一个case表达式和一个冒号，然后我们可以从下一行开始写入当分支被选中时需要执行的语句。</p><p><strong>默认分支其实就是 default case</strong>，因为，当且仅当没有候选分支被选中时它才会被执行，所以它以关键字default开头并直接后跟一个冒号。同样的，我们可以在default:的下一行写入要执行的语句。</p><p>由于select语句是专为通道而设计的，所以每个case表达式中都只能包含操作通道的表达式，比如接收表达式。</p><p>当然，如果我们需要把接收表达式的结果赋给变量的话，还可以把这里写成赋值语句或者短变量声明。下面展示一个简单的例子。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备好几个通道。</span></span><br><span class="line">intChannels := [<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">int</span>&#123;</span><br><span class="line">  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 随机选择一个通道，并向它发送元素值。</span></span><br><span class="line">index := rand.Intn(<span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">"The index: %d\n"</span>, index)</span><br><span class="line">intChannels[index] &lt;- index</span><br><span class="line"><span class="comment">// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-intChannels[<span class="number">0</span>]:</span><br><span class="line">  fmt.Println(<span class="string">"The first candidate case is selected."</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-intChannels[<span class="number">1</span>]:</span><br><span class="line">  fmt.Println(<span class="string">"The second candidate case is selected."</span>)</span><br><span class="line"><span class="keyword">case</span> elem := &lt;-intChannels[<span class="number">2</span>]:</span><br><span class="line">  fmt.Printf(<span class="string">"The third candidate case is selected, the element is %d.\n"</span>, elem)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">"No candidate case is selected!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1、在使用select语句的时候，我们首先需要注意下面几个事情。"><a href="#1、在使用select语句的时候，我们首先需要注意下面几个事情。" class="headerlink" title="1、在使用select语句的时候，我们首先需要注意下面几个事情。"></a>1、在使用select语句的时候，我们首先需要注意下面几个事情。</h4><ul><li>1、如果像上述示例那样加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，select语句都不会被阻塞。如果那几个表达式都阻塞了，或者说都没有满足求值的条件，那么默认分支就会被选中并执行。</li><li>2、如果没有加入默认分支，那么一旦所有的case表达式都没有满足求值条件，那么select语句就会被阻塞。直到至少有一个case表达式满足条件为止。</li><li>3、我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多时候，我们需要通过接收表达式的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对于程序逻辑和程序性能都是有好处的。</li><li>4、select语句只能对其中的每一个case表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要通过在for语句中嵌入select语句的方式实现。但这时要注意，<strong>简单地在select语句的分支中使用break语句，只能结束当前的select语句的执行，而并不会对外层的for语句产生作用</strong>。这种错误的用法可能会让这个for语句无休止地运行下去。</li></ul><p>示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 一秒后关闭通道。</span></span><br><span class="line">time.AfterFunc(time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">close</span>(intChan)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> _, ok := &lt;-intChan:</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"The candidate case is closed."</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">"The candidate case is selected."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The candidate <span class="keyword">case</span> is closed.</span><br></pre></td></tr></table></figure></p><h3 id="8、select语句的分支选择规则都有哪些？"><a href="#8、select语句的分支选择规则都有哪些？" class="headerlink" title="8、select语句的分支选择规则都有哪些？"></a>8、select语句的分支选择规则都有哪些？</h3><p>规则如下面所示。</p><ul><li>1、对于每一个case表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。比如，如果case表达式是包含了接收表达式的短变量声明时，那么在赋值符号左边的就可以是一个或两个表达式，不过此处的表达式的结果必须是可以被赋值的。当这样的case表达式被求值时，它包含的多个表达式总会以从左到右的顺序被求值。</li><li>2、select语句包含的候选分支中的<strong>case表达式都会在该语句执行开始时先被求值</strong>，并且求值的顺序是依从代码编写的顺序从上到下的。结合上一条规则，在select语句开始执行时，排在最上边的候选分支中最左边的表达式会最先被求值，然后是它右边的表达式。仅当最上边的候选分支中的所有表达式都被求值完毕后，从上边数第二个候选分支中的表达式才会被求值，顺序同样是从左到右，然后是第三个候选分支、第四个候选分支，以此类推。</li><li>3、对于每一个case表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该case表达式的求值就是不成功的。在这种情况下，我们可以说，这个case表达式所在的候选分支是不满足选择条件的。</li><li>4、<strong>仅当select语句中的所有case表达式都被求值完毕后，它才会开始选择候选分支</strong>。这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行。如果这时没有默认分支，那么select语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止。一旦有一个候选分支满足选择条件，select语句（或者说它所在的 goroutine）就会被唤醒，这个候选分支就会被执行。</li><li>5、<strong>如果select语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行</strong>。注意，<strong>即使select语句是在被唤醒时发现的这种情况，也会这样做</strong>。</li><li>6、一条select语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关。</li><li>7、<strong>select语句的每次执行，包括case表达式求值和分支选择，都是独立的</strong>。不过，至于它的执行是否是并发安全的，就要看其中的case表达式以及分支中，是否包含并发不安全的代码了。<br>例：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channels = [<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">int</span>&#123;</span><br><span class="line"><span class="literal">nil</span>,</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line"><span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numbers = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> getChan(<span class="number">0</span>) &lt;- getNumber(<span class="number">0</span>):</span><br><span class="line">fmt.Println(<span class="string">"The first candidate case is selected."</span>)</span><br><span class="line"><span class="keyword">case</span> getChan(<span class="number">1</span>) &lt;- getNumber(<span class="number">1</span>):</span><br><span class="line">fmt.Println(<span class="string">"The second candidate case is selected."</span>)</span><br><span class="line"><span class="keyword">case</span> getChan(<span class="number">2</span>) &lt;- getNumber(<span class="number">2</span>):</span><br><span class="line">fmt.Println(<span class="string">"The third candidate case is selected"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"No candidate case is selected!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNumber</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"numbers[%d]\n"</span>, i)</span><br><span class="line"><span class="keyword">return</span> numbers[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getChan</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"channels[%d]\n"</span>, i)</span><br><span class="line"><span class="keyword">return</span> channels[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>运行：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">channels[<span class="number">0</span>]</span><br><span class="line">numbers[<span class="number">0</span>]</span><br><span class="line">channels[<span class="number">1</span>]</span><br><span class="line">numbers[<span class="number">1</span>]</span><br><span class="line">channels[<span class="number">2</span>]</span><br><span class="line">numbers[<span class="number">2</span>]</span><br><span class="line">No candidate <span class="keyword">case</span> is selected!</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为 Go 语言最有特色的数据类型，通道（channel）完全可以与 goroutine（也可称为 go 程）并驾齐驱，共同代表 Go 语言独有的并发编程模式和编程哲学。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;Don’t communicate by sharing memory
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GO：2.3 字典的操作和约束</title>
    <link href="http://yoursite.com/2020/07/20/GO%EF%BC%9A2-3-%E5%AD%97%E5%85%B8%E7%9A%84%E6%93%8D%E4%BD%9C%E5%92%8C%E7%BA%A6%E6%9D%9F/"/>
    <id>http://yoursite.com/2020/07/20/GO%EF%BC%9A2-3-%E5%AD%97%E5%85%B8%E7%9A%84%E6%93%8D%E4%BD%9C%E5%92%8C%E7%BA%A6%E6%9D%9F/</id>
    <published>2020-07-20T12:38:58.000Z</published>
    <updated>2020-07-20T13:51:07.260Z</updated>
    
    <content type="html"><![CDATA[<p>字典（map）存储的不是单一值的集合，而是键值对的集合。</p><hr><p>什么是键值对？</p><p><strong><em>它是从英文 key-value pair 直译过来的一个词。顾名思义，一个键值对就代表了一对键和值。<br>注意，一个“键”和一个“值”分别代表了一个从属于某一类型的独立值，把它们两个捆绑在一起就是一个键值对了。</em></strong></p><hr><p>在 Go 语言规范中，应该是为了避免歧义，他们将键值对换了一种称呼，叫做：“键 - 元素对”。我们也沿用这个看起来更加清晰的词来讲解。</p><h3 id="1、为什么字典的键类型会受到约束？"><a href="#1、为什么字典的键类型会受到约束？" class="headerlink" title="1、为什么字典的键类型会受到约束？"></a>1、为什么字典的键类型会受到约束？</h3><p>Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，<strong>键的类型是受限的，而元素却可以是任意类型的。</strong></p><p>如果要探究限制的原因，我们就先要了解哈希表中最重要的一个过程：<strong>映射</strong>。</p><p>你可以<strong>把键理解为元素的一个索引</strong>，我们可以在哈希表中通过键查找与它成对的那个元素。</p><p>键和元素的这种对应关系，在数学里就被称为“映射”，这也是“map”这个词的本意，哈希表的映射过程就存在于对键 - 元素对的增、删、改、查的操作之中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">aMap := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">  <span class="string">"one"</span>:    <span class="number">1</span>,</span><br><span class="line">  <span class="string">"two"</span>:    <span class="number">2</span>,</span><br><span class="line">  <span class="string">"three"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">k := <span class="string">"two"</span></span><br><span class="line">v, ok := aMap[k]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"The element of key %q: %d\n"</span>, k, v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Not found!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，我们要在哈希表中查找与某个键值对应的那个元素值，那么我们需要先把键值作为参数传给这个哈希表。</p><p>哈希表会<strong>先用哈希函数（hash function）把键值转换为哈希值</strong>。哈希值通常是一个无符号的整数。一个哈希表会持有一定数量的桶（bucket），我们也可以叫它哈希桶，这些哈希桶会均匀地储存其所属哈希表收纳的键 - 元素对。</p><p>因此，哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。</p><p>由于键 - 元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素值。随后，哈希表就会把相应的元素值作为结果返回。</p><p>只要这个键 - 元素对存在哈希表中就一定会被查找到，因为哈希表增、改、删键 - 元素对时的映射过程，与前文所述如出一辙。</p><p>现在我们知道了，<strong>映射过程的第一步就是：把键值转换为哈希值。</strong></p><p>在 Go 语言的字典中，每一个键值都是由它的哈希值代表的。也就是说，字典不会独立存储任何键的值，但会独立存储它们的哈希值。</p><h3 id="2、字典的键类型不能是哪些类型？"><a href="#2、字典的键类型不能是哪些类型？" class="headerlink" title="2、字典的键类型不能是哪些类型？"></a>2、字典的键类型不能是哪些类型？</h3><p>Go 语言字典的键类型不可以是<strong>函数类型、字典类型和切片类型</strong>。</p><p>Go 语言规范规定，<strong>在键类型的值之间必须可以施加操作符==和!=</strong>。换句话说，键类型的值必须要支持<strong>判等</strong>操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。</p><p>另外，<strong>如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型</strong>，否则在程序运行过程中会引发 panic（即运行时恐慌）。<br>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> badMap2 = <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>&#123;</span><br><span class="line">  <span class="string">"1"</span>:   <span class="number">1</span>,</span><br><span class="line">  []<span class="keyword">int</span>&#123;<span class="number">2</span>&#125;: <span class="number">2</span>, <span class="comment">// 这里会引发panic。</span></span><br><span class="line">  <span class="number">3</span>:    <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的变量badMap2的类型是键类型为interface{}、值类型为int的字典类型。这样声明并不会引起什么错误。或者说，我通过这样的声明躲过了 Go 语言编译器的检查。</p><p>注意，我用字面量在声明该字典的同时对它进行了初始化，使它包含了三个键 - 元素对。其中第二个键 - 元素对的键值是[]int{2}，元素值是2。这样的键值也不会让 Go 语言编译器报错，因为从<strong>语法上说，这样做是可以的</strong>。</p><p>但是，当我们<strong>运行</strong>这段代码的时候，Go 语言的运行时（runtime）系统就会发现这里的问题，它会<strong>抛出一个 panic</strong>，并把根源指向字面量中定义第二个键 - 元素对的那一行。我们越晚发现问题，修正问题的成本就会越高，所以最好不要把字典的键类型设定为任何接口类型。如果非要这么做，请一定确保代码在可控的范围之内。</p><p>还要注意<strong>，如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型。</strong></p><p>比如，由于类型[1][]string的元素类型是[]string，所以它就不能作为字典类型的键类型。另外，如果键的类型是结构体类型，那么还要保证其中字段的类型的合法性。无论不合法的类型被埋藏得有多深，比如map[[1][2][3][]string]int，Go 语言编译器都会把它揪出来。</p><ul><li>你可能会有疑问，为什么键类型的值必须支持判等操作？我在前面说过，Go 语言一旦定位到了某一个哈希桶，那么就会试图在这个桶中查找键值。具体是怎么找的呢？</li></ul><p>首先，每个哈希桶都会把自己包含的所有键的哈希值存起来。Go 语言会用被查找键的哈希值与这些哈希值逐个对比，看看是否有相等的。如果一个相等的都没有，那么就说明这个桶中没有要查找的键值，这时 Go 语言就会立刻返回结果了。</p><p>如果有相等的，那就再用键值本身去对比一次。为什么还要对比？原因是，不同值的哈希值是可能相同的。这有个术语，叫做“<strong>哈希碰撞</strong>”。</p><p>所以，即使哈希值一样，键值也不一定一样。如果键类型的值之间无法判断相等，那么此时这个映射的过程就没办法继续下去了。最后，只有键的哈希值和键值都相等，才能说明查找到了匹配的键 - 元素对。</p><h3 id="3、应该优先考虑哪些类型作为字典的键类型？"><a href="#3、应该优先考虑哪些类型作为字典的键类型？" class="headerlink" title="3、应该优先考虑哪些类型作为字典的键类型？"></a>3、应该优先考虑哪些类型作为字典的键类型？</h3><p>在 Go 语言中，有些类型的值是支持判等的，有些是不支持的。那么在这些值支持判等的类型当中，哪些更适合作为字典的键类型呢？</p><p>这里先抛开我们使用字典时的上下文，只从性能的角度看。在前文所述的映射过程中，<strong>“把键值转换为哈希值”以及“把要查找的键值与哈希桶中的键值做对比”， 明显是两个重要且比较耗时的操作</strong>。</p><p>因此，可以说，<strong>求哈希和判等操作的速度越快，对应的类型就越适合作为键类型</strong>。</p><hr><p><em>对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go 语言都有一套算法与之对应。这套算法中就包含了<strong>哈希和判等</strong>。以求哈希的操作为例，<strong>宽度越小的类型速度通常越快</strong>。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。<strong>对于字符串类型</strong>，由于它的宽度是不定的，所以要看它的值的具体长度，<strong>长度越短求哈希越快</strong>。</em></p><hr><p>类型的宽度是指它的单个值需要占用的字节数。比如，bool、int8和uint8类型的一个值需要占用的字节数都是1，因此这些类型的宽度就都是1。</p><p>以上说的都是基本类型，再来看高级类型。</p><p><strong>对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并</strong>，所以<strong>速度就取决于它的元素类型以及它的长度</strong>。细则同上。</p><p>与之类似，对<strong>结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并</strong>，所以关键在于<strong>它的各个字段的类型以及字段的数量</strong>。而对于接口类型，具体的哈希算法，则由值的实际类型决定。</p><p>我不建议你使用这些高级数据类型作为字典的键类型，不仅仅是因为对它们的值求哈希，以及判等的速度较慢，更是因为在它们的值中存在变数。</p><p>比如，对一个数组来说，我可以任意改变其中的元素值，但在变化前后，它却代表了两个不同的键值。</p><p>对于结构体类型的值情况可能会好一些，因为如果我可以控制其中各字段的访问权限的话，就可以阻止外界修改它了。把接口类型作为字典的键类型最危险。</p><p>如果在这种情况下 Go 运行时系统发现某个键值不支持判等操作，那么就会立即抛出一个 panic。在最坏的情况下，这足以使程序崩溃。</p><ul><li>那么，在那些基本类型中应该优先选择哪一个？<br>答案是，<strong>优先选用数值类型和指针类型</strong>，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。</li></ul><ul><li>那什么是不通常的情况？笼统地说，Go<br>语言有时会对字典的增、删、改、查操作做一些优化。</li></ul><p>比如，在字典的键类型为字符串类型的情况下；又比如，在字典的键类型为宽度为4或8的整数类型的情况下。</p><h3 id="4、在值为nil的字典上执行读操作会成功吗，那写操作呢？"><a href="#4、在值为nil的字典上执行读操作会成功吗，那写操作呢？" class="headerlink" title="4、在值为nil的字典上执行读操作会成功吗，那写操作呢？"></a>4、在值为nil的字典上执行读操作会成功吗，那写操作呢？</h3><p>由于<strong>字典是引用类型</strong>，所以当我们<strong>仅声明而不初始化一个字典类型的变量的时候，它的值会是nil</strong>。</p><ul><li>在这样一个变量上试图通过键值获取对应的元素值，或者添加键 - 元素对，会成功吗？<br>这个问题虽然简单，但却是我们必须铭记于心的，因为这涉及程序运行时的稳定性。</li></ul><p><strong>除了添加键 - 元素对，我们在一个值为nil的字典上做任何操作都不会引起错误</strong>。当我们试图在一个值为nil的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。你可以运行一下 demo19.go 文件试试看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字典（map）存储的不是单一值的集合，而是键值对的集合。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;什么是键值对？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;它是从英文 key-value pair 直译过来的一个词。顾名思义，一个键值对就代表了一对键和值。&lt;br&gt;注意，一个“键”和一个“值”分
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GO：2.2 container包中的容器</title>
    <link href="http://yoursite.com/2020/07/17/GO%EF%BC%9A2-2-container%E5%8C%85%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2020/07/17/GO%EF%BC%9A2-2-container%E5%8C%85%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2020-07-17T09:01:43.000Z</published>
    <updated>2020-07-20T12:43:54.799Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言的链表实现在标准库的container/list代码包中。这个代码包中有两个公开的程序实体——List和Element，List 实现了一个双向链表（以下简称链表），而 Element 则代表了链表中元素的结构。</p><h3 id="1、可以把自己生成的Element类型值传给链表吗？"><a href="#1、可以把自己生成的Element类型值传给链表吗？" class="headerlink" title="1、可以把自己生成的Element类型值传给链表吗？"></a>1、可以把自己生成的Element类型值传给链表吗？</h3><p>这里用到了List的四种方法。</p><ul><li>MoveBefore方法和MoveAfter方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。</li><li>MoveToFront方法和MoveToBack方法，分别用于把给定的元素移动到链表的最前端和最后端。</li></ul><p>在这些方法中，“给定的元素”都是<em>Element类型的，</em>Element类型是Element类型的指针类型，*Element的值就是元素的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveBefore</span><span class="params">(e, mark *Element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveAfter</span><span class="params">(e, mark *Element)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveToFront</span><span class="params">(e *Element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveToBack</span><span class="params">(e *Element)</span></span></span><br></pre></td></tr></table></figure><h4 id="1、如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？"><a href="#1、如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？" class="headerlink" title="1、如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？"></a>1、如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？</h4><p>典型回答：不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的Element值并不在链表中，所以也就谈不上“在链表中移动元素”。更何况链表不允许我们把自己生成的Element值插入其中。</p><ul><li>在List包含的方法中，用于插入新元素的那些方法都只接受interface{}类型的值。这些方法在内部会使用Element值，包装接收到的新元素。</li><li>这样做正是为了避免直接使用我们自己生成的元素，主要原因是避免链表的内部关联，遭到外界破坏，这对于链表本身以及我们这些使用者来说都是有益的。</li></ul><h4 id="2、List的方法还有下面这几种："><a href="#2、List的方法还有下面这几种：" class="headerlink" title="2、List的方法还有下面这几种："></a>2、List的方法还有下面这几种：</h4><ul><li>Front和Back方法分别用于获取链表中最前端和最后端的元素</li><li>InsertBefore和InsertAfter方法分别用于在指定的元素之前和之后插入新元素</li><li>PushFront和PushBack方法则分别用于在链表的最前端和最后端插入新元素。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Front</span><span class="params">()</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Back</span><span class="params">()</span> *<span class="title">Element</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">InsertBefore</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, mark *Element)</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">InsertAfter</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, mark *Element)</span> *<span class="title">Element</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">PushFront</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">PushBack</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Element</span></span></span><br></pre></td></tr></table></figure><p>这些方法都会把一个Element值的指针作为结果返回，它们就是链表留给我们的安全“接口”。拿到这些内部元素的指针，我们就可以去调用前面提到的用于移动元素的方法了。</p><h3 id="2、为什么链表可以做到开箱即用？"><a href="#2、为什么链表可以做到开箱即用？" class="headerlink" title="2、为什么链表可以做到开箱即用？"></a>2、为什么链表可以做到开箱即用？</h3><p>List和Element都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予各自类型的零值。</p><ul><li>广义来讲，所谓的零值就是只做了声明，但还未做初始化的变量被给予的缺省值。每个类型的零值都会依据该类型的特性而被设定。</li><li>比如，经过语句var a [2]int声明的变量a的值，将会是一个包含了两个0的整数数组。又比如，经过语句var s []int声明的变量s的值将会是一个[]int类型的、值为nil的切片。</li></ul><p>那么经过语句var l list.List声明的变量l的值将会是什么呢？<br>[1] 这个零值将会是一个长度为0的链表。这个链表持有的根元素也将会是一个空壳，其中只会包含缺省的内容。</p><ul><li>那这样的链表我们可以直接拿来使用吗？<br>答案是，可以的。这被称为“<strong>开箱即用</strong>”。Go 语言标准库中很多结构体类型的程序实体都做到了开箱即用。这也是在编写可供别人使用的代码包（或者说程序库）时，我们推荐遵循的最佳实践之一。</li></ul><p>那么，语句var l list.List声明的链表l可以直接使用，这是怎么做到的呢？<br>关键在于它的“<strong>延迟初始化</strong>”机制。</p><h4 id="1、延迟初始化"><a href="#1、延迟初始化" class="headerlink" title="1、延迟初始化"></a>1、延迟初始化</h4><p>所谓的延迟初始化，你可以理解为<strong>把初始化操作延后，仅在实际需要的时候才进行</strong>。延迟初始化的优点在于“延后”，它<strong>可以分散初始化操作带来的计算量和存储空间消耗</strong>。</p><p>例如，如果我们需要集中声明非常多的大容量切片的话，那么那时的 CPU 和内存空间的使用量肯定都会一个激增，并且只有设法让其中的切片及其底层数组被回收，内存使用量才会有所降低。</p><p>如果数组是可以被延迟初始化的，那么计算量和存储空间的压力就可以被分散到实际使用它们的时候。这些数组被实际使用的时间越分散，延迟初始化带来的优势就会越明显。</p><hr><p><strong><em>实际上，Go 语言的切片就起到了延迟初始化其底层数组的作用，你可以想一想为什么会这么说的理由。延迟初始化的缺点恰恰也在于“延后”。你可以想象一下，如果我在调用链表的每个方法的时候，它们都需要先去判断链表是否已经被初始化，那这也会是一个计算量上的浪费。在这些方法被非常频繁地调用的情况下，这种浪费的影响就开始显现了，程序的性能将会降低。</em></strong></p><hr><p>在这里的链表实现中，一些方法是无需对是否初始化做判断的。比如Front方法和Back方法，一旦发现链表的长度为0, 直接返回nil就好了。</p><p>又比如，在用于删除元素、移动元素，以及一些用于插入元素的方法中，只要判断一下传入的元素中指向所属链表的指针，是否与当前链表的指针相等就可以了。</p><p>如果不相等，就一定说明传入的元素不是这个链表中的，后续的操作就不用做了。反之，就一定说明这个链表已经被初始化了。</p><p>原因在于，链表的PushFront方法、PushBack方法、PushBackList方法以及PushFrontList方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始化。</p><p>而且，我们在向一个空的链表中添加新元素的时候，肯定会调用这四个方法中的一个，这时新元素中指向所属链表的指针，一定会被设定为当前链表的指针。所以，指针相等是链表已经初始化的充分必要条件。</p><p>？List利用了自身以及Element在结构上的特点，巧妙地平衡了延迟初始化的优缺点，使得链表可以开箱即用，并且在性能上可以达到最优。</p><h3 id="3、Ring与List的区别在哪儿？"><a href="#3、Ring与List的区别在哪儿？" class="headerlink" title="3、Ring与List的区别在哪儿？"></a>3、Ring与List的区别在哪儿？</h3><p>container/ring包中的Ring类型实现的是一个循环链表，也就是我们俗称的环。其实List在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。</p><p>所以也可以说，List的零值是一个只包含了根元素，但不包含任何实际元素值的空链表。<br>那么，既然Ring和List在本质上都是循环链表，那它们到底有什么不同呢？</p><p>最主要的不同有下面几种。</p><ul><li>1、Ring类型的数据结构仅由它自身即可代表，而List类型则需要由它以及Element类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。</li><li>2、一个Ring类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个List类型的值则代表了一个完整的链表。这是表示维度上的不同。</li><li>3、在创建并初始化一个Ring值的时候，我们可以指定它包含的元素的数量，但是对于一个List值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的New函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。</li><li>4、仅通过var r ring.Ring语句声明的r将会是一个长度为1的循环链表，而List类型的零值则是一个长度为0的链表。别忘了List中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。</li><li>5、Ring值的Len方法的算法复杂度是 O(N) 的，而List值的Len方法的算法复杂度则是 O(1) 的。这是两者在性能方面最显而易见的差别。</li></ul><p>其他的不同基本上都是方法方面的了。比如，循环链表也有用于插入、移动或删除元素的方法，不过用起来都显得更抽象一些，等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go 语言的链表实现在标准库的container/list代码包中。这个代码包中有两个公开的程序实体——List和Element，List 实现了一个双向链表（以下简称链表），而 Element 则代表了链表中元素的结构。&lt;/p&gt;
&lt;h3 id=&quot;1、可以把自己生成的Ele
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GO：2.1 数组和切片</title>
    <link href="http://yoursite.com/2020/07/16/GO%EF%BC%9A2-1-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"/>
    <id>http://yoursite.com/2020/07/16/GO%EF%BC%9A2-1-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/</id>
    <published>2020-07-16T11:06:12.000Z</published>
    <updated>2020-07-17T09:02:30.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、数组（array）类型和切片（slice）类型的异同"><a href="#1、数组（array）类型和切片（slice）类型的异同" class="headerlink" title="1、数组（array）类型和切片（slice）类型的异同"></a>1、数组（array）类型和切片（slice）类型的异同</h3><h4 id="1、相同"><a href="#1、相同" class="headerlink" title="1、相同"></a>1、相同</h4><p>数组（array）类型和切片（slice）类型的共同点是都属于集合类的类型，并且，它们的值也都可以用来存储某一种类型的值（或者说元素）。</p><h4 id="2、区别"><a href="#2、区别" class="headerlink" title="2、区别"></a>2、区别</h4><p>它们最重要的不同是：<strong>数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。</strong></p><p>数组的长度在声明它的时候就必须给定，并且之后不会再改变。可以说，<strong>数组的长度是其类型的一部分</strong>。比如，<strong>[1]string和[2]string就是两个不同的数组类型</strong>。</p><p>而<strong>切片的类型字面量中只有元素的类型，而没有长度</strong>。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小。<br><img src="/2020/07/16/GO：2-1-数组和切片/arrslice1.png" alt="arrslice1"></p><p>我们其实可以<strong>把切片看做是对数组的一层简单的封装</strong>，因为在每个切片的底层数据结构中，一定会包含一个数组。<strong>数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。</strong></p><ul><li><p>也正因为如此，Go 语言的<strong>切片类型属于引用类型</strong>，同属<strong>引用类型的还有字典类型、通道类型、函数类型等</strong>；而 Go 语言的<strong>数组类型则属于值类型</strong>，同属<strong>值类型的有基础数据类型以及结构体类型</strong>。注意，Go 语言里不存在像 Java 等编程语言中令人困惑的“传值或传引用”问题。在 Go 语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。我们在数组和切片之上都可以应用索引表达式，得到的都会是某个元素。我们在它们之上也都可以应用切片表达式，也都会得到一个新的切片</p></li><li><p>通过调用内建函数len，得到数组和切片的长度。通过调用内建函数cap，我们可以得到它们的容量。但要注意，<strong>数组的容量永远等于其长度，都是不可变的</strong>。切片的容量却不是这样，并且它的变化是有规律可寻的。</p></li></ul><h3 id="2、怎样正确估算切片的长度和容量？"><a href="#2、怎样正确估算切片的长度和容量？" class="headerlink" title="2、怎样正确估算切片的长度和容量？"></a>2、怎样正确估算切片的长度和容量？</h3><p>1、如下例子demo15.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 示例1。</span></span><br><span class="line">  s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="comment">//用内建函数make声明了一个[]int类型的变量s1，传给make函数的第二个参数是5，从而指明了该切片的长度</span></span><br><span class="line">  </span><br><span class="line">  fmt.Printf(<span class="string">"The length of s1: %d\n"</span>, <span class="built_in">len</span>(s1))</span><br><span class="line">  fmt.Printf(<span class="string">"The capacity of s1: %d\n"</span>, <span class="built_in">cap</span>(s1))</span><br><span class="line">  fmt.Printf(<span class="string">"The value of s1: %d\n"</span>, s1)</span><br><span class="line">  </span><br><span class="line">  s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br><span class="line">  <span class="comment">//同样的方式声明了切片s2，多传入了一个参数8以指明该切片的容量。</span></span><br><span class="line">  </span><br><span class="line">  fmt.Printf(<span class="string">"The length of s2: %d\n"</span>, <span class="built_in">len</span>(s2))</span><br><span class="line">  fmt.Printf(<span class="string">"The capacity of s2: %d\n"</span>, <span class="built_in">cap</span>(s2))</span><br><span class="line">  fmt.Printf(<span class="string">"The value of s2: %d\n"</span>, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>切片s1和s2的容量都是多少？<br>切片s1的容量是5，s2的容量是8</li></ul><p>2、通过切片表达式基于某个数组或切片生成新切片的时候，情况就变得复杂起来了。<br>如下例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="comment">//s3中有 8 个元素，分别是从1到8的整数，s3的长度和容量都是8。</span></span><br><span class="line"></span><br><span class="line">s4 := s3[<span class="number">3</span>:<span class="number">6</span>]</span><br><span class="line"><span class="comment">//用切片表达式s3[3:6]初始化了切片s4</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"The length of s4: %d\n"</span>, <span class="built_in">len</span>(s4))</span><br><span class="line">fmt.Printf(<span class="string">"The capacity of s4: %d\n"</span>, <span class="built_in">cap</span>(s4))</span><br><span class="line">fmt.Printf(<span class="string">"The value of s4: %d\n"</span>, s4)</span><br></pre></td></tr></table></figure></p><p>运行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The length of s4: <span class="number">3</span></span><br><span class="line">The capacity of s4: <span class="number">5</span></span><br><span class="line">The value of s4: [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><ul><li>1、s4的长度是多少？<br>长度是3</li></ul><p>切片表达式中s3[3:6]取数范围为[3,6)，即从索引3开始取，取到索引6但不包含索引6。</p><p>这里的3可被称为起始索引，6可被称为结束索引。那么s4的长度就是6减去3，即3。</p><p>可以说，s4中的索引从0到2指向的元素对应的是s3及其底层数组中索引从3到5的那 3 个元素。<br><img src="/2020/07/16/GO：2-1-数组和切片/arrslice2.png" alt="arrslice2"></p><ul><li><p>2、再来看s4的容量是多少?<br>容量是5</p><p><strong>切片的容量代表了它的底层数组的长度，但这仅限于使用make函数或者切片值字面量初始化切片的情况。</strong></p></li></ul><p>更通用的规则是：<strong>一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。</strong></p><p>由于s4是通过在s3上施加切片操作得来的，所以s3的底层数组就是s4的底层数组。</p><p>又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾。</p><p>所以，s4的容量就是其底层数组的长度8, 减去上述切片表达式中的那个起始索引3，即5。</p><p>注意，切片代表的窗口是无法向左扩展的。也就是说，我们永远无法透过s4看到s3中最左边的那 3 个元素。</p><ul><li>把切片的窗口向右扩展到最大的方法。<br>对于s4来说，切片表达式s4[0:cap(s4)]就可以做到。我想你应该能看懂。该表达式的结果值（即一个新的切片）会是[]int{4, 5, 6, 7, 8}，其长度和容量都是5。 </li></ul><h3 id="3、怎样估算切片容量的增长？"><a href="#3、怎样估算切片容量的增长？" class="headerlink" title="3、怎样估算切片容量的增长？"></a>3、怎样估算切片容量的增长？</h3><p>一旦一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。<strong>在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。</strong></p><p>但是，当<strong>原切片的长度（以下简称原长度）大于或等于1024时</strong>，Go 语言将会<strong>以原容量的1.25倍作为新容量的基准（以下新容量基准）</strong>。<strong>新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）</strong>。最终，新容量往往会比新长度大一些，当然，相等也是可能的。</p><p>另外，如果我们一次追加的元素过多，以至于<strong>使新长度比原容量的 2 倍还要大</strong>，那么<strong>新容量就会以新长度为基准</strong>。注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些。</p><h3 id="4、切片的底层数组什么时候会被替换？"><a href="#4、切片的底层数组什么时候会被替换？" class="headerlink" title="4、切片的底层数组什么时候会被替换？"></a>4、切片的底层数组什么时候会被替换？</h3><p>确切地说，一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。</p><p>它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。</p><p>在无需扩容时，append函数返回的是指向原底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。所以，严格来讲，“扩容”这个词用在这里虽然形象但并不合适。</p><p>只要新长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、数组（array）类型和切片（slice）类型的异同&quot;&gt;&lt;a href=&quot;#1、数组（array）类型和切片（slice）类型的异同&quot; class=&quot;headerlink&quot; title=&quot;1、数组（array）类型和切片（slice）类型的异同&quot;&gt;&lt;/a&gt;1、
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GO：1.4 程序实体</title>
    <link href="http://yoursite.com/2020/07/13/GO%EF%BC%9A1-4-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BD%93/"/>
    <id>http://yoursite.com/2020/07/13/GO%EF%BC%9A1-4-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BD%93/</id>
    <published>2020-07-13T02:42:07.000Z</published>
    <updated>2020-07-16T10:59:47.048Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言中的<strong>程序实体包括变量、常量、函数、结构体和接口</strong>。 Go 语言是<strong>静态类型</strong>的编程语言，所以我们在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让 Go 语言能够推导出它们的类型。</p><h3 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h3><p>在 Go 语言中，<strong>变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数、结构体或接口</strong>。常量的合法类型不多，只能是那些 Go 语言预定义的基本类型。它的声明方式也更简单一些。</p><hr><h4 id="1、声明变量有几种方式？"><a href="#1、声明变量有几种方式？" class="headerlink" title="1、声明变量有几种方式？"></a>1、声明变量有几种方式？</h4><p>1、先声明后赋值<br>一个很简单的命令源码文件，命名为 demo7.go。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name <span class="keyword">string</span> <span class="comment">// 先声明</span></span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>) <span class="comment">// 后赋值</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、使用var声明变量的同时赋值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name = flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//声明的同时赋值</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, *name)。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>flag.String函数返回的结果值的类型是<em>string而不是string。类型</em>string代表的是字符串的指针类型，而不是字符串类型。因此，这里的变量name代表的是一个指向字符串值的指针。</p><p>注：</p><ul><li>1、声明变量name的同时，还为它赋了值，而这时声明中并没有显式指定name的类型。之前的变量声明语句是var name string。这里利用了 Go 语言自身的类型推断，而省去了对该变量的类型的声明。</li><li>2、类型推断是一种编程语言在编译期自动解释表达式类型的能力。</li><li>3、类型推断只能用于对变量或常量的初始化。</li></ul><p>3、使用”:=”短变量声明的同时赋值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  name := flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//声明的同时赋值</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, *name)。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注：</p><ul><li>1、短变量声明，实际上就是 Go 语言的类型推断再加上一点点语法糖，<strong>只能在函数体内部使用短变量声明</strong></li><li>在编写if、for或switch语句的时候，我们经常把它安插在初始化子句中，并用来声明一些临时的变量。而相比之下，第一种方式更加通用，它可以被用在任何地方。<br><img src="/2020/07/13/GO：1-4-程序实体/app1.png" alt="app1"></li></ul><h4 id="2、Go-语言的类型推断可以带来哪些好处？"><a href="#2、Go-语言的类型推断可以带来哪些好处？" class="headerlink" title="2、Go 语言的类型推断可以带来哪些好处？"></a>2、Go 语言的类型推断可以带来哪些好处？</h4><p>在写代码时，我们通过使用 Go 语言的类型推断，而节省下来的键盘敲击次数几乎可以忽略不计。但它真正的好处，往往会体现在我们写代码之后的那些事情上，比如<strong>代码重构</strong>。</p><p>通过调用一个函数在声明name变量的同时为它赋值，这个函数是由我们自己定义的函数getTheFlag。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name = getTheFlag()</span><br><span class="line">  <span class="comment">//不显式地指定变量name的类型，使得它可以被赋予任何类型的值。也就是说，变量name的类型可以在其初始化时，由其他程序动态地确定。</span></span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %v!\n"</span>, *name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTheFlag</span><span class="params">()</span> *<span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以用getTheFlag函数包裹（或者说包装）那个对flag.String函数的调用，并把其结果直接作为getTheFlag函数的结果，结果的类型是*string。</p><p>这样一来，var name =右边的表达式，可以变为针对getTheFlag函数的调用表达式了。这实际上是对“声明并赋值name变量的那行代码”的重构。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重构：</span><br><span class="line">我们通常把不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码修改方式，叫做对该程序的重构。重构的对象可以是一行代码、一个函数、一个功能模块，甚至一个软件系统。</span><br></pre></td></tr></table></figure></p><p>你会发现，你可以随意改变getTheFlag函数的内部实现，及其返回结果的类型，而不用修改main函数中的任何代码。</p><p>注：</p><ul><li>我们不显式地指定变量name的类型，使得它可以被赋予任何类型的值。也就是说，变量name的类型可以在其初始化时，由其他程序动态地确定。</li><li>在你改变getTheFlag函数的结果类型之后，Go 语言的编译器会在你再次构建该程序的时候，自动地更新变量name的类型。</li><li>通过这种<strong>类型推断</strong>，你可以体验到动态类型编程语言所带来的一部分优势，即程序灵活性的明显提升。但在那些编程语言中，这种提升可以说是用程序的可维护性和运行效率换来的。</li><li>Go 语言是静态类型的，所以一旦在初始化变量时确定了它的类型，之后就不可能再改变。这就避免了在后面维护程序时的一些问题。另外，请记住，这种类型的确定是在<strong>编译期</strong>完成的，因此不会对程序的运行效率产生任何影响。</li></ul><hr><p><em>Go 语言的类型推断可以带来哪些好处？<br>Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。</em></p><hr><h4 id="2、变量的重声明是什么意思？"><a href="#2、变量的重声明是什么意思？" class="headerlink" title="2、变量的重声明是什么意思？"></a>2、变量的重声明是什么意思？</h4><p>1、变量的重声明：对已经声明过的变量再次声明。</p><p>2、这涉及了短变量声明。通过使用它，我们可以对同一个代码块中的变量进行重声明。</p><p>3、变量重声明的前提条件如下。</p><ul><li>1、由于变量的类型在其初始化时就已经确定了，所以对它<strong>再次声明时赋予的类型必须与其原本的类型相同</strong>，否则会产生编译错误。</li><li>2、变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了</li><li>3、变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。</li><li>4、被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。</li></ul><p>如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">n, err := io.WriteString(os.Stdout, <span class="string">"Hello, everyone!\n"</span>)</span><br></pre></td></tr></table></figure></p><p>使用短变量声明，对新变量n和旧变量err进行了“声明并赋值”，这时也是对err的重声明。</p><h4 id="3、如果一个变量与其外层代码块中的变量重名会出现什么状况？"><a href="#3、如果一个变量与其外层代码块中的变量重名会出现什么状况？" class="headerlink" title="3、如果一个变量与其外层代码块中的变量重名会出现什么状况？"></a>3、如果一个变量与其外层代码块中的变量重名会出现什么状况？</h4><p>1、作用域：</p><ul><li>1、程序实体的访问权限有三种：<strong>包级私有的、模块级私有的和公开的</strong>。这其实就是 Go 语言在语言层面，依据代码块对程序实体作用域进行的定义。</li><li>2、包级私有和模块级私有访问权限对应的都是代码包代码块，公开的访问权限对应的是全域代码块。</li><li>3、<strong>一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制</strong>。对“高内聚，低耦合”这种程序设计思想的实践，就是从这里开始的。</li></ul><p>2、如果一个变量与其外层代码块中的变量重名会出现什么状况？<br>如下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> block = <span class="string">"package"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  block := <span class="string">"function"</span></span><br><span class="line">  &#123;</span><br><span class="line">    block := <span class="string">"inner"</span></span><br><span class="line">    fmt.Printf(<span class="string">"The block is %s.\n"</span>, block)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">"The block is %s.\n"</span>, block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个命令源码文件中有四个代码块，它们是：</p><ul><li>全域代码块、</li><li>main包代表的代码块、</li><li>main函数代表的代码块，</li><li>在main函数中的一个用花括号包起来的代码块。</li></ul><p>在后三个代码块（main包代表的代码块、main函数代表的代码块、在main函数中的一个用花括号包起来的代码块）中分别声明了一个名为block的变量，并分别把字符串值”package”、”function”和”inner”赋给了它们。此外，我在后两个代码块的最后分别尝试用fmt.Printf函数打印出“The block is %s.”。这里的“%s”只是为了占位，程序会用block变量的实际值替换掉。</p><p>那么，该源码文件中的代码能通过编译吗？<br>能通过编译。运行后打印出的内容是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The block is inner.</span><br><span class="line">The block is function.</span><br></pre></td></tr></table></figure></p><ul><li>对于同一个代码块而言，用短变量声明对已有变量进行重声明可以通过编译</li><li>对于不同的代码块来说，其中的变量重名没什么大不了，照样可以通过编译。即使这些代码块有直接的嵌套关系也是如此，就像上述代码中的main包代码块、main函数代码块和那个最内层的代码块那样。 </li></ul><p>3、这其实有一个很有画面感的查找过程。这个查找过程不只针对于变量，还适用于任何程序实体。如下面所示。</p><ul><li>首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。</li><li>其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块（父级代码块）开始，一层一层地查找。</li><li>一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了。</li><li>如果我们在当前源码文件中导入了其他代码包，那么引用其中的程序实体时，是需要以限定符为前缀的。所以程序在找代表变量未加限定符的名字（即标识符）的时候，是不会去被导入的代码包中查找的。</li></ul><p>但有个特殊情况，如果我们把代码包导入语句写成import . “XXX”的形式（注意中间的那个“.”），那么就会让这个“XXX”包中公开的程序实体，被当前源码文件中的代码，视为当前代码包中的程序实体。 比如，如果有代码包导入语句import . fmt，那么我们在当前源码文件中引用fmt.Printf函数的时候直接用Printf就可以了。在这个特殊情况下，程序在查找当前源码文件后会先去查用这种方式导入的那些代码包。</p><p>4、从作用域的角度也可以说，虽然通过var block = “package”声明的变量作用域是整个main代码包，但是在main函数中，它却被那两个同名的变量<strong>“屏蔽”</strong>了。<br>  相似的，虽然main函数首先声明的block的作用域，是整个main函数，但是在最内层的那个代码块中，它却是不可能被引用到的。反过来讲，最内层代码块中的block也不可能被该块之外的代码引用到，这也是打印内容的第二行是“The block is function.”的另一半原因。</p><h4 id="4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？"><a href="#4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？" class="headerlink" title="4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？"></a>4、不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？</h4><p>1、为了方便描述，我就把不同代码块中的重名变量叫做“可重名变量”吧。注意，在同一个代码块中不允许出现重名的变量，这违背了 Go 语言的语法。</p><p>区别：</p><ul><li>变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。</li><li>变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。</li><li>不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。</li><li>如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。</li></ul><p><img src="/2020/07/13/GO：1-4-程序实体/app2.png" alt="app2.png"></p><p>2、不同类型的可重名变量例子<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The element is <span class="string">"one"</span>.</span><br></pre></td></tr></table></figure></p><p>上述代码中，有两个都叫做container的变量，分别位于main包代码块和main函数代码块。</p><p>main包代码块中的变量是切片（slice）类型的，另一个是字典（map）类型的。在main函数的最后，试图打印出container变量的值中索引为1的那个元素。</p><p>如果container的类型不是数组、切片或字典类型，那么索引表达式就会引发编译错误。</p><p>这正是利用 Go 语言语法，帮我们约束程序的一个例子；但是当我们想知道 container 确切类型的时候，利用索引表达式的方式就不够了。</p><p><strong>当可重名变量的值被转换成某个接口类型值，或者它们的类型本身就是接口类型的时候，严格的类型检查就很有必要了。</strong></p><h4 id="5、怎样判断一个变量的类型？"><a href="#5、怎样判断一个变量的类型？" class="headerlink" title="5、怎样判断一个变量的类型？"></a>5、怎样判断一个变量的类型？</h4><p>看如下例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>怎样在打印其中元素之前，正确判断变量container的类型？<br>使用<strong>“类型断言”</strong>表达式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">interface</span>&#123;&#125;(container).([]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></p><p>完整代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">value, ok := <span class="keyword">interface</span>&#123;&#125;(container).([]<span class="keyword">string</span>)</span><br><span class="line">fmt.Printf(<span class="string">"The value is %v.\n"</span>, value)</span><br><span class="line">fmt.Printf(<span class="string">"The ok is %v.\n"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The element is <span class="string">"one"</span>.</span><br><span class="line">The value is [].</span><br><span class="line">The ok is <span class="literal">false</span>.</span><br></pre></td></tr></table></figure></p><p>1、这里有一条赋值语句。在赋值符号的右边，是一个类型断言表达式。</p><p>它包括了用来把container变量的值转换为空接口值的interface{}(container)。以及一个用于判断前者的类型是否为切片类型 []string  的 .([]string)。</p><p>这个表达式的结果可以被赋给两个变量，在这里由value和ok代表。变量ok是布尔（bool）类型的，它将代表类型判断的结果，true或false。</p><p>如果是true，那么被判断的值将会被自动转换为[]string类型的值，并赋给变量value，否则value将被赋予nil（即“空”）。这里的ok也可以没有。也就是说，类型断言表达式的结果，可以只被赋给一个变量，在这里是value。但是这样的话，当判断为否时就会引发异常。</p><p>这种异常在 Go 语言中被叫做panic，我把它翻译为运行时恐慌。因为它是一种在 Go 程序运行期间才会被抛出的异常，而“恐慌”二字是英文 Panic 的中文直译。除非显式地“恢复”这种“恐慌”，否则它会使 Go 程序崩溃并停止。所以，在一般情况下，我们还是应该使用带ok变量的写法。</p><p>如果将类型断言改为：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">interface</span>&#123;&#125;(container).(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></p><p>完整代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = []<span class="keyword">string</span>&#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">container := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">0</span>: <span class="string">"zero"</span>, <span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"The element is %q.\n"</span>, container[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">value, ok := <span class="keyword">interface</span>&#123;&#125;(container).(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">fmt.Printf(<span class="string">"The value is %v.\n"</span>, value)</span><br><span class="line">fmt.Printf(<span class="string">"The ok is %v.\n"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The element is <span class="string">"one"</span>.</span><br><span class="line">The value is <span class="keyword">map</span>[<span class="number">0</span>:zero <span class="number">1</span>:one <span class="number">2</span>:two].</span><br><span class="line">The ok is <span class="literal">true</span>.</span><br></pre></td></tr></table></figure></p><p>1、类型断言表达式的语法形式是<strong>x.(T)</strong>。其中的x代表要被判断类型的值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的。</p><p>2、所以，当这里的container变量类型不是任何的接口类型时，我们就需要先把它转成某个接口类型的值。如果container是某个接口类型的，那么这个类型断言表达式就可以是container.([]string)。</p><p>3、在 Go 语言中，interface{}代表空接口，任何类型都是它的实现类型。这里的具体语法是interface{}(x)，例如前面展示的interface{}(container)。</p><p>4、你可能会对这里的{}产生疑惑，为什么在关键字interface的右边还要加上这个东西？</p><ul><li>一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。</li><li>比如struct{}，它就代表了不包含任何字段和方法的、空的结构体类型。而空接口interface{}则代表了不包含任何方法定义的、空的接口类型。</li><li>当然了，对于一些集合类的数据类型来说，{}还可以用来表示其值不包含任何元素，比如空的切片值[]string{}，以及空的字典值map[int]string{}。<br><img src="/2020/07/13/GO：1-4-程序实体/app3.png" alt="app3.png"></li></ul><h4 id="6、类型转换规则中有哪些值得注意的地方？"><a href="#6、类型转换规则中有哪些值得注意的地方？" class="headerlink" title="6、类型转换规则中有哪些值得注意的地方？"></a>6、类型转换规则中有哪些值得注意的地方？</h4><p>1、类型转换表达式的语法形式：<strong>T(x)</strong>。</p><p>其中的x可以是一个变量，也可以是一个代表值的字面量（比如1.23和struct{}{}），还可以是一个表达式。注意，如果是表达式，那么该表达式的结果只能是一个值，而不能是多个值。</p><p>在这个上下文中，x可以被叫做源值，它的类型就是源类型，而那个T代表的类型就是目标类型。如果从源类型到目标类型的转换是不合法的，那么就会引发一个编译错误。</p><p>2、三个注意点</p><ul><li>1、<strong>对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。</strong></li></ul><p>比如，之所以uint8(255)可以把无类型的常量255转换为uint8类型的值，是因为255在[0, 255]的范围内。</p><p>但需要特别注意的是，源整数类型的可表示范围较大，而目标类型的可表示范围较小的情况，比如把值的类型从int16转换为int8。请看下面这段代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> srcInt = <span class="keyword">int16</span>(<span class="number">-255</span>)</span><br><span class="line">dstInt := <span class="keyword">int8</span>(srcInt)<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p>变量srcInt的值是int16类型的-255，而变量dstInt的值是由前者转换而来的，类型是int8。int16类型的可表示范围可比int8类型大了不少。</p><p>问题是，dstInt的值是多少？<br>首先你要知道，整数在 Go 语言以及计算机中都是以补码的形式存储的。这主要是为了简化计算机对整数的运算过程。补码其实就是原码各位求反再加 1。</p><p>比如，int16类型的值-255的补码是1111111100000001。如果我们把该值转换为int8类型的值，那么 Go 语言会把在较高位置（或者说最左边位置）上的 8 位二进制数直接截掉，从而得到00000001。又由于其最左边一位是0，表示它是个正整数，以及正整数的补码就等于其原码，所以<strong>dstInt的值就是1</strong>。</p><p>一定要记住，当整数值的类型的有效范围由宽变窄时，只需在补码形式下截掉一定数量的高位二进制数即可。</p><p>类似的快刀斩乱麻规则还有：当把一个浮点数类型的值转换为整数类型值时，前者的小数部分会被全部截掉。</p><ul><li>2、<strong>虽然直接把一个整数值转换为一个string类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的 Unicode 代码点，否则转换的结果将会是”�”（仅由高亮的问号组成的字符串值）。</strong><br>字符’�’的 Unicode 代码点是U+FFFD。它是 Unicode 标准中定义的 Replacement Character，专用于替换那些未知的、不被认可的以及无法展示的字符。<br>如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>(<span class="number">-1</span>)  <span class="comment">//�"</span></span><br></pre></td></tr></table></figure></li></ul><p>由于-1肯定无法代表一个有效的 Unicode 代码点，所以得到的总会是”�”。</p><ul><li>3、string类型与各种切片类型之间的互转<br><strong>一个值在从string类型向[]byte类型转换时代表着以 UTF-8 编码的字符串会被拆分成零散、独立的字节。</strong></li></ul><p>除了与 ASCII 编码兼容的那部分字符集，以 UTF-8 编码的某个单一字节是无法代表一个字符的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>([]<span class="keyword">byte</span>&#123;<span class="string">'\xe4'</span>, <span class="string">'\xbd'</span>, <span class="string">'\xa0'</span>, <span class="string">'\xe5'</span>, <span class="string">'\xa5'</span>, <span class="string">'\xbd'</span>&#125;) <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure></p><p>比如，UTF-8 编码的三个字节\xe4、\xbd和\xa0合在一起才能代表字符’你’，而\xe5、\xa5和\xbd合在一起才能代表字符’好’。</p><p><strong>一个值在从string类型向[]rune类型转换时代表着字符串会被拆分成一个个 Unicode 字符。</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>([]<span class="keyword">rune</span>&#123;<span class="string">'\u4F60'</span>, <span class="string">'\u597D'</span>&#125;) <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure></p><h4 id="7、什么是别名类型？什么是潜在类型？"><a href="#7、什么是别名类型？什么是潜在类型？" class="headerlink" title="7、什么是别名类型？什么是潜在类型？"></a>7、什么是别名类型？什么是潜在类型？</h4><p>我们可以用关键字type声明自定义的各种类型。这些类型必须在 Go 语言基本类型和高级类型的范畴之内。在它们当中，有一种被叫做“别名类型”的类型。我们可以像下面这样声明它：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString = <span class="keyword">string</span></span><br></pre></td></tr></table></figure></p><p>这条声明语句表示，MyString是string类型的别名类型。顾名思义，别名类型与其源类型的区别只是在名称上，它们是完全相同的。</p><p><strong>源类型与别名类型是一对概念</strong>，是两个对立的称呼。别名类型主要是为了代码重构而存在的。</p><p>Go 语言内建的基本类型中就存在两个别名类型<strong>。byte是uint8的别名类型，而rune是int32的别名类型。</strong></p><p>一定要注意，如果我这样声明：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="keyword">string</span>  <span class="comment">// 注意，这里没有等号。</span></span><br></pre></td></tr></table></figure></p><p>MyString2和string就是两个不同的类型了。这里的MyString2是一个新的类型，不同于其他任何类型。</p><p>这种方式也可以被叫做对<strong>类型的再定义</strong>。我们刚刚把string类型再定义成了另外一个类型MyString2。<br><img src="/2020/07/13/GO：1-4-程序实体/app4.png" alt="app4.png"></p><p>对于这里的类型再定义来说，string可以被称为MyString2的潜在类型。<strong>潜在类型</strong>的含义是，<strong>某个类型在本质上是哪个类型。</strong></p><p><strong>潜在类型相同的不同类型的值之间是可以进行类型转换的</strong>。因此，<strong>MyString2类型的值与string类型的值可以使用类型转换表达式进行互转</strong>。</p><p><strong>但对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，因为[]MyString2与[]string的潜在类型不同，分别是[]MyString2和[]string。</strong></p><p>另外，<strong>即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go 语言中的&lt;strong&gt;程序实体包括变量、常量、函数、结构体和接口&lt;/strong&gt;。 Go 语言是&lt;strong&gt;静态类型&lt;/strong&gt;的编程语言，所以我们在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让 Go 语言能够推导出它们的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GO：1.3 库源码文件</title>
    <link href="http://yoursite.com/2020/07/12/GO%EF%BC%9A1-3-%E5%BA%93%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/07/12/GO%EF%BC%9A1-3-%E5%BA%93%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/</id>
    <published>2020-07-12T08:01:56.000Z</published>
    <updated>2020-07-12T09:37:40.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、什么是库源码文件？"><a href="#1、什么是库源码文件？" class="headerlink" title="1、什么是库源码文件？"></a>1、什么是库源码文件？</h3><p>1、<strong>库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体</strong>，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）。</p><p>2、这里的“其他代码”可以与被使用的程序实体在同一个源码文件内，也可以在其他源码文件，甚至其他代码包中。</p><p>3、程序实体是什么？<br>在 Go 语言中，<strong>程序实体是变量、常量、函数、结构体和接口的统称</strong>。</p><ul><li>我们总是会先声明（或者说定义）程序实体，然后再去使用。</li><li>程序实体的名字被统称为标识符。标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。</li><li>从规则上说，我们可以用中文作为变量的名字。但是不建议这样做。</li></ul><h3 id="2、怎样把命令源码文件中的代码拆分到其他库源码文件？"><a href="#2、怎样把命令源码文件中的代码拆分到其他库源码文件？" class="headerlink" title="2、怎样把命令源码文件中的代码拆分到其他库源码文件？"></a>2、怎样把命令源码文件中的代码拆分到其他库源码文件？</h3><p>如果在某个目录下有一个命令源码文件 demo4.go，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  hello(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>demo4.go 在调用了hello函数，函数hello被声明在了另外一个源码文件中，我把它命名为 demo4_lib.go，并且放在与 demo4.go 相同的目录main下（在同一个目录下的源码文件都需要被声明为属于同一个代码包。）。如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注：如果该目录下有一个命令源码文件，那么为了让同在一个目录下的文件都通过编译，其他源码文件应该也声明属于main包。</p><p>现在运行它们，比如，我们可以在这些文件所在的目录下运行如下命令并得到相应的结果。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run demo4.<span class="keyword">go</span> demo4_lib.<span class="keyword">go</span> </span><br><span class="line">Hello, everyone!</span><br></pre></td></tr></table></figure></p><p>或者，像下面这样先构建当前的代码包再运行。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build puzzlers/article3/q1</span><br><span class="line">$ ./q1            </span><br><span class="line">Hello, everyone!</span><br></pre></td></tr></table></figure></p><p>1、在这里，我把 demo4.go 和 demo4_lib.go 都放在了一个相对路径为puzzlers/article3/q1的目录中。</p><p>2、在默认情况下，相应的代码包的导入路径会与此一致。我们可以通过代码包的导入路径引用其中声明的程序实体。但是，这里的情况是不同的。</p><p>3、注意，demo4.go 和 demo4_lib.go 都声明自己属于main包。我在前面讲 Go 语言源码的组织方式的时候提到过这种用法，即：源码文件声明的包名可以与其所在目录的名称不同，只要这些文件声明的包名一致就可以。</p><p>4、代码包声明的基本规则：</p><ul><li>同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。如果目录中有命令源码文件，那么其他种类的源码文件也应该声明属于main包。这也是我们能够成功构建和运行它们的前提。</li><li>源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。对于命令源码文件而言，构建生成的可执行文件的主名称会与其父目录的名称相同</li></ul><p>###3、怎样把命令源码文件中的代码拆分到其他代码包？<br>1、把 demo4.go 另存为 demo5.go，并放到一个相对路径为puzzlers/article3/q2的目录中。</p><p>2、然后再创建一个相对路径为puzzlers/article3/q2/lib的目录，再把 demo4_lib.go 复制一份并改名为 demo5_lib.go 放到该目录中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lib5</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里修改了两个地方。</p><ul><li>第一个改动是，把代码包声明语句由package main改为了package lib5。注意，故意让声明的包名与其所在的目录的名称不同。</li><li><p>第二个改动是，把全小写的函数名hello改为首字母大写的Hello。</p><p>基于以上改动，我们再来看下面的几个问题。</p></li></ul><h4 id="1、代码包的导入路径总会与其所在目录的相对路径一致吗？"><a href="#1、代码包的导入路径总会与其所在目录的相对路径一致吗？" class="headerlink" title="1、代码包的导入路径总会与其所在目录的相对路径一致吗？"></a>1、代码包的导入路径总会与其所在目录的相对路径一致吗？</h4><p>库源码文件 demo5_lib.go 所在目录的相对路径是puzzlers/article3/q2/lib，而它却声明自己属于lib5包。在这种情况下，该包的导入路径是puzzlers/article3/q2/lib，还是puzzlers/article3/q2/lib5？<br>1、首先，我们在构建或者安装这个代码包的时候，提供给go命令的路径应该是目录的相对路径，就像这样：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> install puzzlers/article3/q2/lib</span><br></pre></td></tr></table></figure></p><p>该命令会成功完成。之后，当前工作区的 pkg 子目录下会产生相应的归档文件，具体的相对路径是:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg/darwin_amd64/puzzlers/article3/q2/lib.a</span><br></pre></td></tr></table></figure></p><p>其中的darwin_amd64就是我在讲工作区时提到的平台相关目录。可以看到，这里与源码文件所在目录的相对路径是对应的。</p><p>2、为了进一步说明问题，需要先对 demo5.go 做两个改动。</p><ul><li>第一个改动是，在以import为前导的代码包导入语句中加入puzzlers/article3/q2/lib，也就是试图导入这个代码包。</li><li>第二个改动是，把对hello函数的调用改为对lib.Hello函数的调用。其中的lib.叫做限定符，旨在指明右边的程序实体所在的代码包。不过这里与代码包导入路径的完整写法不同，只包含了路径中的最后一级lib，这与代码包声明语句中的规则一致。</li></ul><p>现在，通过运行go run demo5.go命令试一试。错误提示会类似于下面这种。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./demo5.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">2</span>: imported and not used: <span class="string">"puzzlers/article3/q2/lib"</span> as lib5</span><br><span class="line">./demo5.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">2</span>: undefined: lib</span><br></pre></td></tr></table></figure></p><ul><li>第一个错误提示的意思是，我们导入了puzzlers/article3/q2/lib包，但没有实际使用其中的任何程序实体。这在 Go 语言中是不被允许的，在编译时就会导致失败。</li><li>这里还有另外一个线索，那就是“as lib5”。这说明虽然导入了代码包puzzlers/article3/q2/lib，但是使用其中的程序实体的时候应该以lib5.为限定符。这也就是第二个错误提示的原因了。Go 命令找不到lib.这个限定符对应的代码包。</li></ul><p>3、为什么会是这样？<br>根本原因就是，我们在源码文件中声明所属的代码包与其所在目录的名称不同。请记住，源码文件所在的目录相对于 src 目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符要与它声明所属的代码包名称对应。</p><p>有两个方式可以使上述构建成功完成。我在这里选择把 demo5_lib.go 文件中的代码包声明语句改为package lib。理由是，为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。</p><h4 id="2、什么样的程序实体才可以被当前包外的代码引用？"><a href="#2、什么样的程序实体才可以被当前包外的代码引用？" class="headerlink" title="2、什么样的程序实体才可以被当前包外的代码引用？"></a>2、什么样的程序实体才可以被当前包外的代码引用？</h4><p>1、为什么要把 demo5_lib.go 文件中的那个函数名称hello的首字母大写？<br>实际上这涉及了 Go 语言中对于程序实体访问权限的规则。超级简单，<strong>名称的首字母为大写的程序实体才可以被当前包外的代码引用</strong>，否则它就只能被当前包内的其他代码引用。通过名称，Go 语言自然地把程序实体的访问权限划分为了<strong>包级私有的和公开的</strong>。<strong>对于包级私有的程序实体，即使你导入了它所在的代码包也无法引用到它。</strong></p><h4 id="3、对于程序实体，还有其他的访问权限规则吗？"><a href="#3、对于程序实体，还有其他的访问权限规则吗？" class="headerlink" title="3、对于程序实体，还有其他的访问权限规则吗？"></a>3、对于程序实体，还有其他的访问权限规则吗？</h4><p>1、答案是肯定的。在 Go 1.5 及后续版本中，我们可以通过创建internal代码包让一些程序实体仅仅能被当前模块中的其他代码引用。这被称为 Go 程序实体的第三种访问权限：<strong>模块级私有</strong>。</p><p>2、具体规则是，<strong>internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用</strong>。当然，引用前需要先导入这个internal包。<strong>对于其他代码包，导入该internal包都是非法的，无法通过编译</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、什么是库源码文件？&quot;&gt;&lt;a href=&quot;#1、什么是库源码文件？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是库源码文件？&quot;&gt;&lt;/a&gt;1、什么是库源码文件？&lt;/h3&gt;&lt;p&gt;1、&lt;strong&gt;库源码文件是不能被直接运行的源码文件，它仅用于存
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GO：1.2 命令源码文件</title>
    <link href="http://yoursite.com/2020/07/10/GO%EF%BC%9A1-2-%E5%91%BD%E4%BB%A4%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/07/10/GO%EF%BC%9A1-2-%E5%91%BD%E4%BB%A4%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/</id>
    <published>2020-07-10T11:25:13.000Z</published>
    <updated>2020-07-13T07:42:55.894Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经知道，环境变量 GOPATH 指向的是一个或多个工作区，每个工作区中都会有以代码包为基本组织形式的源码文件。</p><p>这里的源码文件又分为三种，即：<strong>命令源码文件、库源码文件和测试源码文件</strong>，它们都有着不同的用途和编写规则。<br><img src="/2020/07/10/GO：1-2-命令源码文件/command1.png" alt="command1.png"></p><h3 id="1、命令源码文件的用途是什么，怎样编写它？"><a href="#1、命令源码文件的用途是什么，怎样编写它？" class="headerlink" title="1、命令源码文件的用途是什么，怎样编写它？"></a>1、命令源码文件的用途是什么，怎样编写它？</h3><p>1、命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。</p><p>2、如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么它就是命令源码文件。 就像下面这段代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello, world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你把这段代码存成 demo1.go 文件，那么运行go run demo1.go命令后就会在屏幕（标准输出）中看到Hello, world!</p><p>注：<br>1、当需要模块化编程时，我们往往会将代码拆分到多个文件，甚至拆分到不同的代码包中。但无论怎样，对于一个独立的程序来说，<strong>命令源码文件永远只会也只能有一个</strong>。如果有与命令源码文件同包的源码文件，那么它们也应该声明属于main包。</p><p>2、通过构建或安装命令源码文件，<strong>生成的可执行文件就可以被视为“命令”</strong>，既然是命令，那么就应该具备接收参数的能力。</p><h3 id="2、命令源码文件怎样接收参数"><a href="#2、命令源码文件怎样接收参数" class="headerlink" title="2、命令源码文件怎样接收参数"></a>2、命令源码文件怎样接收参数</h3><p>先看下面代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span><span class="comment">//1步</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//2步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、函数flag.StringVar接受 4 个参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、第 1 个参数是用于存储该命令参数值的地址，具体到这里就是在前面声明的变量name的地址了，由表达式&amp;name表示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、第 2 个参数是为了指定该命令参数的名称，这里是name。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4、第 3 个参数是为了指定在未追加该命令参数时的默认值，这里是everyone。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、第 4 个函数参数，即是该命令参数的简短说明了，这在打印命令说明时会用到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()<span class="comment">//函数flag.Parse用于真正解析命令参数，并把它们的值赋给相应的变量。</span></span><br><span class="line">  <span class="comment">//3步</span></span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对该函数的调用必须在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是在[2]处对flag.StringVar函数的调用）之后，并且在读取任何命令参数值之前进行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">正因为如此，我们最好把flag.Parse()放在main函数的函数体的第一行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>注：还有一个与flag.StringVar函数类似的函数，叫flag.String。这两个函数的区别是，后者会直接返回一个已经分配好的用于存储命令参数值的地址。如果使用它的话，我们就需要把“var name string”改为<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = flag.String(<span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)</span><br></pre></td></tr></table></figure></p><h3 id="3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明"><a href="#3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明" class="headerlink" title="3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明"></a>3、怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明</h3><p>我们把上述代码存成名为 demo2.go 的文件，那么运行如下命令就可以为参数name传值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run demo2.<span class="keyword">go</span> -name=<span class="string">"Robert"</span></span><br></pre></td></tr></table></figure></p><p>运行后，打印到标准输出（stdout）的内容会是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Robert!</span><br></pre></td></tr></table></figure></p><p>另外，如果想查看该命令源码文件的参数说明，可以这样做：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run demo2.<span class="keyword">go</span> --help</span><br></pre></td></tr></table></figure></p><p>其中的$表示我们是在命令提示符后运行go run命令的。运行后输出的内容会类似：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage of /<span class="keyword">var</span>/folders/ts/<span class="number">7</span>lg_tl_x2gd_k1lm5g_48c7w0000gn/T/<span class="keyword">go</span>-build155438482/b001/exe/demo2:</span><br><span class="line"> -name <span class="keyword">string</span></span><br><span class="line">    The greeting object. (<span class="keyword">default</span> <span class="string">"everyone"</span>)</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>以下是go run命令构建上述命令源码文件时临时生成的可执行文件的完整路径<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">var</span>/folders/ts/<span class="number">7</span>lg_tl_x2gd_k1lm5g_48c7w0000gn/T/<span class="keyword">go</span>-build155438482/b001/exe/demo2</span><br></pre></td></tr></table></figure></p><p>如果我们先构建这个命令源码文件再运行生成的可执行文件，像这样：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build demo2.<span class="keyword">go</span></span><br><span class="line">$ ./demo2 --help</span><br></pre></td></tr></table></figure></p><p>那么输出就会是<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage of ./demo2:</span><br><span class="line"> -name <span class="keyword">string</span></span><br><span class="line">    The greeting object. (<span class="keyword">default</span> <span class="string">"everyone"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="4、怎样自定义命令源码文件的参数使用说明"><a href="#4、怎样自定义命令源码文件的参数使用说明" class="headerlink" title="4、怎样自定义命令源码文件的参数使用说明"></a>4、怎样自定义命令源码文件的参数使用说明</h3><p>1、最简单的一种方式就是对变量flag.Usage重新赋值。</p><p>flag.Usage的类型是func()，即一种无参数声明且无结果声明的函数类型。flag.Usage变量在声明时就已经被赋值了，所以我们才能够在运行命令go run demo2.go –help时看到正确的结果。注意，对flag.Usage的赋值必须在调用flag.Parse函数之前。现在，我们把 demo2.go 另存为 demo3.go，然后在main函数体的开始处加入如下代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span><span class="comment">//1步</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//2步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     fmt.Fprintf(os.Stderr, <span class="string">"Usage of %s:\n"</span>, <span class="string">"question"</span>)</span><br><span class="line">     flag.PrintDefaults()</span><br><span class="line">    &#125;</span><br><span class="line">  flag.Parse()<span class="comment">//函数flag.Parse用于真正解析命令参数，并把它们的值赋给相应的变量。</span></span><br><span class="line">  <span class="comment">//3步</span></span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run demo3.<span class="keyword">go</span> --help</span><br></pre></td></tr></table></figure></p><p>后，就会看到<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage of question:</span><br><span class="line"> -name <span class="keyword">string</span></span><br><span class="line">    The greeting object. (<span class="keyword">default</span> <span class="string">"everyone"</span>)</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>2、现在再深入一层，我们在调用flag包中的一些函数（比如StringVar、Parse等等）的时候，实际上是在调用flag.CommandLine变量的对应方法。</p><p><strong>flag.CommandLine相当于默认情况下的命令参数容器</strong>。所以，通过对flag.CommandLine重新赋值，我们可以更深层次地定制当前命令源码文件的参数使用说明。</p><p>现在我们把main函数体中的那条对flag.Usage变量的赋值语句注销掉，然后在init函数体的开始处添加如下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span><span class="comment">//1步</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.CommandLine = flag.NewFlagSet(<span class="string">""</span>, flag.ExitOnError)</span><br><span class="line">  flag.CommandLine.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Fprintf(os.Stderr, <span class="string">"Usage of %s:\n"</span>, <span class="string">"question"</span>)</span><br><span class="line">  flag.PrintDefaults()</span><br><span class="line">&#125;</span><br><span class="line">  flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"everyone"</span>, <span class="string">"The greeting object."</span>)<span class="comment">//2步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()<span class="comment">//函数flag.Parse用于真正解析命令参数，并把它们的值赋给相应的变量。</span></span><br><span class="line">  <span class="comment">//3步</span></span><br><span class="line">  fmt.Printf(<span class="string">"Hello, %s!\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再运行命令go run demo3.go –help后，其输出会与上一次的输出的一致。不过后面这种定制的方法更加灵活。比如，当我们把为flag.CommandLine赋值的那条语句改为<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.CommandLine = flag.NewFlagSet(<span class="string">""</span>, flag.PanicOnError)</span><br></pre></td></tr></table></figure></p><p>后，再运行go run demo3.go –help命令就会产生另一种输出效果。这是由于我们在这里传给flag.NewFlagSet函数的第二个参数值是flag.PanicOnError。</p><ul><li>1、flag.PanicOnError和flag.ExitOnError都是预定义在flag包中的常量。</li><li>2、flag.ExitOnError的含义是，告诉命令参数容器，当命令后跟–help或者参数设置的不正确的时候，在打印命令参数使用说明后以状态码2结束当前程序。</li><li>状态码2代表用户错误地使用了命令，而flag.PanicOnError与之的区别是在最后抛出“运行时恐慌（panic）”。</li><li>上述两种情况都会在我们调用flag.Parse函数时被触发。</li></ul><p>3、下面再进一步，我们索性不用全局的flag.CommandLine变量，转而自己创建一个私有的命令参数容器。我们在函数外再添加一个变量声明：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cmdLine = flag.NewFlagSet(<span class="string">"question"</span>, flag.ExitOnError)</span><br></pre></td></tr></table></figure></p><p>然后，我们把对flag.StringVar的调用替换为对cmdLine.StringVar调用，再把flag.Parse()替换为cmdLine.Parse(os.Args[1:])。</p><p>其中的os.Args[1:]指的就是我们给定的那些命令参数。这样做就完全脱离了flag.CommandLine。</p><p>这样做的好处依然是更灵活地定制命令参数容器。但更重要的是，你的定制完全不会影响到那个全局变量flag.CommandLine。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们已经知道，环境变量 GOPATH 指向的是一个或多个工作区，每个工作区中都会有以代码包为基本组织形式的源码文件。&lt;/p&gt;
&lt;p&gt;这里的源码文件又分为三种，即：&lt;strong&gt;命令源码文件、库源码文件和测试源码文件&lt;/strong&gt;，它们都有着不同的用途和编写规则。&lt;br
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GO：工作区和GOPATH</title>
    <link href="http://yoursite.com/2020/07/10/GO%EF%BC%9A%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8CGOPATH/"/>
    <id>http://yoursite.com/2020/07/10/GO%EF%BC%9A%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8CGOPATH/</id>
    <published>2020-07-10T06:27:34.000Z</published>
    <updated>2020-07-10T11:21:18.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Go基础知识导图"><a href="#1、Go基础知识导图" class="headerlink" title="1、Go基础知识导图"></a>1、Go基础知识导图</h3><p><img src="/2020/07/10/GO：工作区和GOPATH/go1.jpg" alt="go1.jpg"></p><h3 id="2、工作区和GOPATH"><a href="#2、工作区和GOPATH" class="headerlink" title="2、工作区和GOPATH"></a>2、工作区和GOPATH</h3><h4 id="1、Go-3个环境变量"><a href="#1、Go-3个环境变量" class="headerlink" title="1、Go 3个环境变量"></a>1、Go 3个环境变量</h4><ul><li>GOROOT：Go语言安装根目录的路径，也就是GO语言的安装路径</li><li>GOPATH：若干工作区目录的路径，是我们自己定义的工作空间</li><li>GOBIN：Go程序生成的可执行文件的路径</li></ul><h4 id="2、GOPATH有什么意义"><a href="#2、GOPATH有什么意义" class="headerlink" title="2、GOPATH有什么意义"></a>2、GOPATH有什么意义</h4><ol><li><p>可以把GOPATH简单理解成Go语言的工作目录，它的值是一个目录的路径，也可以是多个目录的路径，每个目录都代表Go语言的一个工作区。</p></li><li><p>我们需要利用这些工作区去放置Go语言的源码文件，以及安装（install）后的归档文件（archive file，也就是以.a为扩展名的文件）和可执行文件。</p></li><li><p>Go语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本都是围绕GOPATH和工作区进行的。</p></li></ol><p>go build 命令一些可选项的用途和用法</p><h4 id="1、Go-语言源码的组织方式是怎样的？"><a href="#1、Go-语言源码的组织方式是怎样的？" class="headerlink" title="1、Go 语言源码的组织方式是怎样的？"></a>1、Go 语言源码的组织方式是怎样的？</h4><p>1、Go语言的源码也是以代码包为基本组织单位的。在文件系统中，这些代码包与目录一一对应。目录有子目录，代码包也可以有子包。</p><p>2、一个代码包可以包含任意个以.go为扩展名的原码文件，这些源码文件都需要被声明属于同一个代码包。</p><p>3、代码包的名称一般会与源码文件所在目录同名。如果不同名，在构建、安装时会以代码包名称为准。</p><p>4、每个代码包都有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/labstack/echo"</span></span><br></pre></td></tr></table></figure></p><p>5、在工作区中，一个代码包的导入路径实际上就是从src子目录到该包的实际存储位置的相对路径。</p><p>6、所以说，Go语言源码的组织方式就是以环境变量GOPATH、工作区、src目录个代码包为主线的。一般情况下，Go语言的源码文件都需要存放在环境变量GOPATH包含的某个工作区（目录）中的src目录下的某个代码包（目录）中。</p><h4 id="2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）"><a href="#2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）" class="headerlink" title="2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）"></a>2、源码安装后的结果是什么？（只有在安装后，Go语言源码才能被我们或其他代码使用）</h4><p>1、源码文件通常会被放在某个工作区的src子目录下</p><p>2、安装后如果产生了归档文件（以.a为扩展名的文件）会被放进该工作区的pkg子目录</p><p>3、如果产生了可执行文件，就可能会被放在该工作区的bin子目录下。</p><p><strong>归档文件存放具体位置和规则：</strong><br>1、源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件就是与这个代码包同名的。</p><p>2、放置它的相对目录就是该代码包的导入路径的直接父级。比如，一个已存在的代码包的导入路径是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com/labstack/echo</span><br></pre></td></tr></table></figure></p><p>那么执行命令<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> insatll github.com/labstack/echo</span><br></pre></td></tr></table></figure></p><p>生成的归档文件的相对目录就是github.com/labstack，文件名为echo.a。</p><p>3、上面这个代码包导入路径还有一层含义，即：该代码包的源码文件存在于github网站的labstack组的代码仓库echo中</p><p>4、归档文件的相对目录与pkg目录之间还有一级目录，称为平台相关目录。平台相关目录的名称是由“build”的目标操作系统、下划线和目标计算架构的代号组成的。比如，构建某个代码包的目标擦欧总系统时Linux，目标计算架构是64位，对应的平台相关目录就是linux_amd64。<br>因此，上述代码包的归档文件就会被放置在当前工作区的子目录<br>pkg/linux_amd64/github.com/labstack中。<br>gopath与工作区：<br><img src="/2020/07/10/GO：工作区和GOPATH/gopath1.png" alt="gopath1.png"></p><p>5、某个工作区的src子目录下的源码文件在安装后一般会被放置到当前工作区的pkg子目录下对应的目录中，或者直接被放置到该工作区的bin子目录中。</p><h4 id="3、理解构建和安装Go程序的过程"><a href="#3、理解构建和安装Go程序的过程" class="headerlink" title="3、理解构建和安装Go程序的过程"></a>3、理解构建和安装Go程序的过程</h4><p>构建与安装的异同：<br>1、构建使用命令go build，安装使用命令go install。构建和安装代码包的时候都会执行编译、打包等操作，并且，这些操作生成的任何文件都会先被保存到某个临时的目录中。</p><p>2、构建源码文件</p><ul><li>如果构建的是库源码文件</li></ul><p>那么操作后产生的结果只会存在于临时目录中，这里构建的主要意义在于检查和验证；</p><ul><li>如果构建的是命令源码文件</li></ul><p>操作的结果文件会被搬运到源码文件所在的目录中。</p><p>3、安装过程会先执行构建、然后还会进行你链接操作，并且把结果文件搬运到指定目录。如：</p><ul><li>安装库源码文件，结果文件被搬运到他所在工作区的pkg目录下的某个子目录中；</li><li>安装命令源码文件，结果文件被搬运到他所在工作区的bin目录中，或者环境变量GOBIN指向的目录中。</li></ul><h3 id="4、go-build-命令一些可选项的用途和用法"><a href="#4、go-build-命令一些可选项的用途和用法" class="headerlink" title="4、go build 命令一些可选项的用途和用法"></a>4、go build 命令一些可选项的用途和用法</h3><p>1、在运行go build命令的时候，默认不会编译目标代码包所依赖的那些代码包。</p><p>2、如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。</p><p>3、如果要强制编译它们，可以在执行命令的时候加入标记-a。此时，不但目标代码包总是会被编译，它依赖的代码包也总会被编译，即使依赖的是标准库中的代码包也是如此。</p><p>5、另外，如果不但要编译依赖的代码包，还要安装它们的归档文件，那么可以加入标记-i。</p><p>6、那么我们怎么确定哪些代码包被编译了呢？有两种方法。</p><ul><li>运行go build命令时加入标记-x，这样可以看到go build命令具体都执行了哪些操作。另外也可以加入标记-n，这样可以只查看具体操作而不执行它们。</li><li>运行go build命令时加入标记-v，这样可以看到go build命令编译的代码包的名称。它在与-a标记搭配使用时很有用。</li></ul><p>7、下面再说一说与 Go 源码的安装联系很紧密的一个命令：go get。<br>命令go get会自动从一些主流公用代码仓库（比如 GitHub）下载目标代码包，并把它们安装到环境变量GOPATH包含的第 1 工作区的相应目录中。如果存在环境变量GOBIN，那么仅包含命令源码文件的代码包会被安装到GOBIN指向的那个目录。</p><p>最常用的几个标记有下面几种。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-u：下载并安装代码包，不论工作区中是否已存在它们。</span><br><span class="line"></span><br><span class="line">-d：只下载代码包，不安装代码包。</span><br><span class="line"></span><br><span class="line">-fix：在下载代码包后先运行一个用于根据当前 Go 语言版本修正代码的工具，然后再安装代码包。</span><br><span class="line"></span><br><span class="line">-t：同时下载测试所需的代码包。</span><br><span class="line"></span><br><span class="line">-insecure：允许通过非安全的网络协议下载和安装代码包。HTTP 就是这样的协议。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Go基础知识导图&quot;&gt;&lt;a href=&quot;#1、Go基础知识导图&quot; class=&quot;headerlink&quot; title=&quot;1、Go基础知识导图&quot;&gt;&lt;/a&gt;1、Go基础知识导图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2020/07/10/GO：工作区和GOPATH/go
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>hexo博客迁移</title>
    <link href="http://yoursite.com/2020/07/02/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
    <id>http://yoursite.com/2020/07/02/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/</id>
    <published>2020-07-02T07:53:23.000Z</published>
    <updated>2020-07-10T06:36:34.411Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、安装hexo博客必要的软件"><a href="#1、安装hexo博客必要的软件" class="headerlink" title="1、安装hexo博客必要的软件"></a>1、安装hexo博客必要的软件</h4><p>1、下载安装Git客户端<br>2、安装node js</p><h4 id="2、Github添加新电脑生成的密钥"><a href="#2、Github添加新电脑生成的密钥" class="headerlink" title="2、Github添加新电脑生成的密钥"></a>2、Github添加新电脑生成的密钥</h4><p>打开git bash输入如下命令：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"xxxxx@xxx.com"</span></span><br></pre></td></tr></table></figure></p><p>邮箱为GitHub注册邮箱，输入命令后直接回车，生成密钥对。根据提示找到密钥对所在位置，将id_rsa.pub公钥内容复制粘贴到Github-settings-‘SSH and GPG keys’-‘SSH keys’中。</p><p>使用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com   测试公钥是否添加成功</span><br></pre></td></tr></table></figure></p><h4 id="3、备份原文件"><a href="#3、备份原文件" class="headerlink" title="3、备份原文件"></a>3、备份原文件</h4><p>需要转移的文件有：<br><img src="/2020/07/02/hexo博客迁移/hexo1.png" alt="hexo1"><br>由于配置文件和主题文件需要经常更改，采用github创建博客分支的方式进行备份。</p><p><strong>1、创建分支</strong><br> 克隆github上上生成的静态文件到hexo文件夹中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/yourname/xxxx.github.io.git hexo</span></span><br></pre></td></tr></table></figure></p><p>克隆后将除.git文件外其他所有文件删除。主要是为了得到版本管理文件夹.git（.git文件为隐藏文件，可直接将可见文件全部删除）。</p><p><strong>2、将备份的原文件复制到此文件夹</strong><br>若文件夹是从github克隆，则需要删除主题文件中的版本控制文件夹,以next主题为例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf thems/next/.git*</span><br></pre></td></tr></table></figure></p><p>创建名为hexo的分支<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hexo</span><br></pre></td></tr></table></figure></p><p>保存所有文件到暂存区<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all</span><br></pre></td></tr></table></figure></p><p>提交变更<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"hexo-2"</span></span><br></pre></td></tr></table></figure></p><p>提交变更时报错：<br><img src="/2020/07/02/hexo博客迁移/hexo2.png" alt="hexo2"><br>根据提示配置。<br>推送分支到github,并用–set-upstream与origin创建关联，将hexo设置为默认分支<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --set-upstream origin hexo</span><br></pre></td></tr></table></figure></p><h4 id="4、迁移"><a href="#4、迁移" class="headerlink" title="4、迁移"></a>4、迁移</h4><p>以后在其他电脑上写博客，直接将分支克隆下来。再使用npm install安装依赖。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b hexo https:<span class="comment">//github.com/yourname/xxx.github.io.git</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><h4 id="5、发表文章"><a href="#5、发表文章" class="headerlink" title="5、发表文章"></a>5、发表文章</h4><p>1、新建文章<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure></p><p>2、注意：需要使用git push把源文件推到分支上<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"xxxx"</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p><p>3、部署文章<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p><p>参考：<br>1、<a href="https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/" target="_blank" rel="noopener">https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/</a></p><p>2、<a href="https://blog.csdn.net/white_idiot/article/details/80685990" target="_blank" rel="noopener">https://blog.csdn.net/white_idiot/article/details/80685990</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、安装hexo博客必要的软件&quot;&gt;&lt;a href=&quot;#1、安装hexo博客必要的软件&quot; class=&quot;headerlink&quot; title=&quot;1、安装hexo博客必要的软件&quot;&gt;&lt;/a&gt;1、安装hexo博客必要的软件&lt;/h4&gt;&lt;p&gt;1、下载安装Git客户端&lt;br&gt;2、
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>测试驱动开发TDD</title>
    <link href="http://yoursite.com/2020/06/15/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91TDD/"/>
    <id>http://yoursite.com/2020/06/15/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91TDD/</id>
    <published>2020-06-15T06:27:12.000Z</published>
    <updated>2020-07-02T07:41:05.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试驱动开发TDD（Test-Driven-Development）"><a href="#测试驱动开发TDD（Test-Driven-Development）" class="headerlink" title="测试驱动开发TDD（Test Driven Development）"></a>测试驱动开发TDD（Test Driven Development）</h2><h3 id="1、什么是-TDD"><a href="#1、什么是-TDD" class="headerlink" title="1、什么是 TDD"></a>1、什么是 TDD</h3><h4 id="1、TDD-有广义和狭义之分"><a href="#1、TDD-有广义和狭义之分" class="headerlink" title="1、TDD 有广义和狭义之分"></a>1、TDD 有广义和狭义之分</h4><p>1、常说的是狭义的TDD，也就是单元测试驱动开发UTDD（Unit Test Driven Development）；</p><p>2、广义的TDD：是验收测试驱动开发ATDD（Acceptance Test Driven Development），<br>包括行为驱动开发BDD（Behavior Driven Development）和消费者驱动契约开发Consumer-Driven Contracts Development 等。</p><h4 id="2、TDD-有三层含义："><a href="#2、TDD-有三层含义：" class="headerlink" title="2、TDD 有三层含义："></a>2、TDD 有三层含义：</h4><ul><li>Test-Driven Development，测试驱动开发。</li><li>Task-Driven Development，任务驱动开发，要对问题进行分析并进行任务分解。</li><li>Test-Driven Design，测试保护下的设计改善。TDD 并不能直接提高设计能力，它只是给你更多机会和保障去改善设计。</li></ul><h4 id="3、TDD-流程"><a href="#3、TDD-流程" class="headerlink" title="3、TDD 流程"></a>3、TDD 流程</h4><p>TDD 的基本流程是：红，绿，重构。<br><img src="/2020/06/15/测试驱动开发TDD/tdd2.jpg" alt="tdd2"></p><p>更详细的流程是：<br><img src="/2020/06/15/测试驱动开发TDD/tdd1.jpg" alt="tdd1"></p><p>1、编写测试<br>2、运行测试，观察测试结果是否如期失败（变红）<br>3、测试结果不如期失败，返回第1步修改测试<br>4、测试结果如期失败，编写刚好能够让测试通过的产品代码实现<br>5、运行测试，观察测试结果是否如期成功（变绿）<br>6、测试结果不如期成功，返回第4步修改实现<br>7、测试结果如期成功，分析代码是否需要重构<br>8、需要重构，返回第4步修改实现<br>9、不需要重构，编写下一个测试</p><h4 id="4、TDD-优点"><a href="#4、TDD-优点" class="headerlink" title="4、TDD 优点"></a>4、TDD 优点</h4><p>1、降低开发者负担<br>通过明确的流程，让我们一次只关注一个点，思维负担更小。</p><p>2、保护网<br>TDD 的好处是覆盖完全的单元测试，对产品代码提供了一个保护网，让我们可以轻松地迎接需求变化或改善代码的设计。<br>所以如果你的项目需求稳定，一次性做完，后续没有任何改动的话，能享受到 TDD 的好处就比较少了。</p><p>3、提前澄清需求<br>先写测试可以帮助我们去思考需求，并提前澄清需求细节，而不是代码写到一半才发现不明确的需求。</p><p>4、快速反馈<br>有很多人说 TDD 时，我的代码量增加了，所以开发效率降低了。但是，如果没有单元测试，你就要手工测试，你要花很多时间去准备数据，启动应用，跳转界面等，反馈是很慢的。准确说，快速反馈是单元测试的好处。</p><h4 id="5、TDD-的三条规则"><a href="#5、TDD-的三条规则" class="headerlink" title="5、TDD 的三条规则"></a>5、TDD 的三条规则</h4><p>1、除非是为了使一个失败的 unit test 通过，否则不允许编写任何产品代码</p><p>2、在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）</p><p>3、只允许编写刚好能够使一个失败的 unit test 通过的产品代码</p><p>如果违反了会怎么样呢？<br>1、违反第一条，先编写了产品代码，那这段代码是为了实现什么需求呢？怎么确保它真的实现了呢？<br>2、违反第二条，写了多个失败的测试，如果测试长时间不能通过，会增加开发者的压力，另外，测试可能会被重构，这时会增加测试的修改成本。<br>3、违反第三条，产品代码实现了超出当前测试的功能，那么这部分代码就没有测试的保护，不知道是否正确，需要手工测试。可能这是不存在的需求，那就凭空增加了代码的复杂性。如果是存在的需求，那后面的测试写出来就会直接通过，破坏了 TDD 的节奏感。</p><p>我认为它的本质是：<br>1、分离关注点，一次只戴一顶帽子<br>在我们编程的过程中，有几个关注点：需求，实现，设计。<br>TDD 给了我们明确的三个步骤，每个步骤关注一个方面。</p><ul><li>红：<br>写一个失败的测试，它是对一个小需求的描述，只需要关心输入输出，这个时候根本不用关心如何实现。</li><li>绿：<br>专注在用最快的方式实现当前这个小需求，不用关心其他需求，也不要管代码的质量多么惨不忍睹。</li><li>重构：<br>既不用思考需求，也没有实现的压力，只需要找出代码中的坏味道，并用一个手法消除它，让代码变成整洁的代码。</li></ul><p>2、注意力控制<br>人的注意力既可以主动控制，也会被被动吸引。注意力来回切换的话，就会消耗更多精力，思考也会不那么完整。<br>使用 TDD 开发，我们要主动去控制注意力，写测试的时候，发现一个类没有定义，IDE 提示编译错误，这时候你如果去创建这个类，你的注意力就不在需求上了，已经切换到了实现上，我们应该专注地写完这个测试，思考它是否表达了需求，确定无误后再开始去消除编译错误。</p><p>参考：<a href="https://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="noopener">https://www.jianshu.com/p/62f16cd4fef3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;测试驱动开发TDD（Test-Driven-Development）&quot;&gt;&lt;a href=&quot;#测试驱动开发TDD（Test-Driven-Development）&quot; class=&quot;headerlink&quot; title=&quot;测试驱动开发TDD（Test Driven De
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>go:goroutine、channel、反射</title>
    <link href="http://yoursite.com/2020/06/11/go-goroutine%E3%80%81channel%E3%80%81%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2020/06/11/go-goroutine%E3%80%81channel%E3%80%81%E5%8F%8D%E5%B0%84/</id>
    <published>2020-06-11T07:58:15.000Z</published>
    <updated>2020-06-11T08:06:24.441Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、goroutine"><a href="#1、goroutine" class="headerlink" title="1、goroutine"></a>1、goroutine</h3><h4 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、Go协程和Go主线程</p><ul><li><strong>Go主线程</strong>（有的程序员直接成为线程/也可以理解成进程）：<strong>一个Go主线程上，可以起多个协程</strong>，即<strong>协程是轻量级的线程</strong>。</li></ul><p>2、Go协程的特点</p><ul><li>有独立的栈空间</li><li>共享程序堆空间</li><li>调度由用户控制</li><li>协程是轻量级的线程</li></ul><p>3、案例<br>1）在主线程（可以理解成进程），开启一个goroutine，该协程每隔一秒输出“hello world”<br>2）在主线程中也每隔一秒输出“hello world”，输出10次后，退出程序<br>3）要求主线程和goroutine同时执行<br>4）主线程和协程执行流程图</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>    </span><br><span class="line">    <span class="string">"strconv"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个函数，每隔1秒输出“hello world”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span> ;i++  &#123;   </span><br><span class="line">        fmt.Println(<span class="string">"test() hello world"</span>+strconv.Itoa(i))     </span><br><span class="line">        </span><br><span class="line">        time.Sleep(time.Second)  <span class="comment">//休眠一秒  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">go</span> test()<span class="comment">//开启一个协程    </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span> ;i++  &#123;    </span><br><span class="line">        fmt.Println(<span class="string">"main() hello world"</span>+strconv.Itoa(i))      </span><br><span class="line">        </span><br><span class="line">        time.Sleep(time.Second)     <span class="comment">//休眠一秒  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main() hello world1</span><br><span class="line">test() hello world1</span><br><span class="line">main() hello world2</span><br><span class="line">test() hello world2</span><br><span class="line">test() hello world3</span><br><span class="line">main() hello world3</span><br><span class="line">main() hello world4</span><br><span class="line">test() hello world4</span><br><span class="line">test() hello world5</span><br><span class="line">main() hello world5</span><br><span class="line">test() hello world6</span><br><span class="line">main() hello world6</span><br><span class="line">main() hello world7</span><br><span class="line">test() hello world7</span><br><span class="line">test() hello world8</span><br><span class="line">main() hello world8</span><br><span class="line">main() hello world9</span><br><span class="line">test() hello world9</span><br></pre></td></tr></table></figure></p><p>由输出看出，<strong>主线程main和协程test同时执行</strong></p><ul><li><p>主线程和协程执行流程图<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine1.jpg" alt="goroutine1"></p></li><li><p>程序开始执行，main主线程开始执行</p></li><li>go test()开启协程，<strong>主线程main和协程test同时执行</strong></li><li>程序退出以<strong>主线程</strong>为主：<pre><code>1） 如果主线程退出了，则协程即使还没有执行完毕也会退出2）当然协程可以在主线程没有退出前，就执行完毕退出协程</code></pre></li></ul><p>4、总结</p><ul><li><p>1）<strong>主线程</strong>是一个<strong>物理线程</strong>，<strong>直接作用在CPU上</strong>。是重量级的，非常耗费CPU资源。</p></li><li><p>2）<strong>协程从主线程开启的</strong>，是轻量级的线程，是<strong>逻辑态的</strong>。对资源消耗相对小</p></li><li><p>3）Go的协程机制是重要特点，可以轻松的开启上万个协程。（其他编程语言的开发机制一般是基于线程的，开启过多的线程，资源消耗大）</p></li></ul><h4 id="2、goroutine的调度模型"><a href="#2、goroutine的调度模型" class="headerlink" title="2、goroutine的调度模型"></a>2、goroutine的调度模型</h4><p>1、MPG模式基本介绍</p><ul><li>M：操作系统的主线程（是物理线程，真正干活的人）</li><li>P：协程执行需要的上下文环境（运行时需要的资源和运行时的状态）</li><li>G：协程（逻辑态的）</li></ul><p>2、MPG模式运行的状态</p><p>1）MPG模式运行的状态1<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine2.jpg" alt="goroutine2"></p><p>2）MPG模式运行的状态2<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine3.jpg" alt="goroutine3"></p><h4 id="3、设置运行CPU数目"><a href="#3、设置运行CPU数目" class="headerlink" title="3、设置运行CPU数目"></a>3、设置运行CPU数目</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="comment">//runtime.NumCPU()   查询系统的CPU数目</span></span><br><span class="line">    cpuNum := runtime.NumCPU()   </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"cpuNum="</span>,cpuNum)     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置使用多个CPU     </span></span><br><span class="line">    runtime.GOMAXPROCS(cpuNum<span class="number">-1</span>)     </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"ok"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、管道channel"><a href="#2、管道channel" class="headerlink" title="2、管道channel"></a>2、管道channel</h3><p>案例：计算1-20的各个数的阶乘，并且把各个数放入map中并打印，使用goroutine完成</p><p>思路：</p><ul><li>1、编写一个函数，计算各个数的阶乘并放入map中</li><li>2、启动多个协程，统计的结果放入map中</li><li>3、map应该做全局的</li></ul><p>解法一：使用全局变量加锁同步<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (     </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"sync"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(  </span><br><span class="line">    myMap =<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//全局资源不加锁，会发生资源竞争，同时写会报错   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以声明一个全局互斥锁解决    </span></span><br><span class="line">    <span class="comment">//sync是一个包，synchornized 同步    </span></span><br><span class="line">    <span class="comment">//Mutex 互斥      </span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//test函数计算n的阶乘，将结果放入myMap中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="keyword">int</span>)</span></span>&#123;    </span><br><span class="line">    res:=<span class="number">1</span>    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++&#123;      </span><br><span class="line">    res*=i  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入map前加锁    </span></span><br><span class="line">    lock.Lock()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//把结果放入myMap     </span></span><br><span class="line">    myMap[n]=res    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//写完map后解锁    </span></span><br><span class="line">    lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//这里开启20个协程，</span></span><br><span class="line">    <span class="comment">//20个协程同时向map写数据，会发生 并发map写 错误    </span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++&#123;         </span><br><span class="line">        <span class="keyword">go</span> test(i)    </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//休眠5秒钟（人为估算），让主线程等待所有的协程执行完   </span></span><br><span class="line">    time.Sleep(<span class="number">5</span>*time.Second)   </span><br><span class="line">    <span class="comment">//如果不休眠，可能main主线程已经结束退出，但是test协程还没写入map     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//互斥性资源读写都要加锁     </span></span><br><span class="line">    lock.Lock()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出结果，对map进行读操作     </span></span><br><span class="line">    <span class="keyword">for</span> i,v :=<span class="keyword">range</span> myMap&#123;           </span><br><span class="line">        fmt.Printf(<span class="string">"map[%d]=%d\n"</span>,i,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    lock.Unlock()&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="number">17</span>]=<span class="number">355687428096000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">16</span>]=<span class="number">20922789888000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">20</span>]=<span class="number">2432902008176640000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">9</span>]=<span class="number">362880</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">10</span>]=<span class="number">3628800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">12</span>]=<span class="number">479001600</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">3</span>]=<span class="number">6</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">19</span>]=<span class="number">121645100408832000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">11</span>]=<span class="number">39916800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">15</span>]=<span class="number">1307674368000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">18</span>]=<span class="number">6402373705728000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">8</span>]=<span class="number">40320</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">5</span>]=<span class="number">120</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">7</span>]=<span class="number">5040</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">14</span>]=<span class="number">87178291200</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">13</span>]=<span class="number">6227020800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">4</span>]=<span class="number">24</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">6</span>]=<span class="number">720</span></span><br></pre></td></tr></table></figure></p><p>因为map的key是无序的，所以未按递增顺序执行，而且并发执行的顺序也可能不是递增得到结果的</p><p>上面的解法中</p><ul><li>主线程等待所有goroutine全部完成时间很难确定，这里设置为5秒，是为估算</li><li>如果主线程休眠时间长了，会加长等待时间；如果等待时间短了，可能还有goroutine处于工作状态（没有执行完），这时也会随主线程的退出二销毁</li><li>通过全局变量加锁同步来实现协程间通讯，并不利于多个协程对全局变量的读写操作</li></ul><p>综上，我们引出一种新的通讯机制channel</p><p>解法二：使用channel</p><h4 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、channel本质上就是一个数据结构-队列</p><p>2、数据先进先出</p><p>3、<strong>线程安全</strong>，多个goroutine访问时，自己不需要再加锁，即：<strong>channel本身就是线程安全的</strong></p><p>4、<strong>channel是有类型的</strong>，一个string的channel只能存放string类型数据<br><img src="/2020/06/11/go-goroutine、channel、反射/channel1.jpg" alt="channel1"></p><h4 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h4><h5 id="1、定义-声明"><a href="#1、定义-声明" class="headerlink" title="1、定义/声明"></a>1、定义/声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 数据类型</span><br><span class="line"></span><br><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//intChan类型为int，只能存放int型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//mapChan类型为map[int]string，只能存放map[int]string型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> perChan <span class="keyword">chan</span> Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> perChan2 <span class="keyword">chan</span> *Person</span><br></pre></td></tr></table></figure><p>2、注意</p><ul><li>channel是<strong>引用类型</strong></li><li><strong>channel必须初始化后才能写入数据，即make后才能使用</strong></li><li>channel是由类型的，如intChan类型为int，只能存放int型数据</li></ul><h5 id="3、管道的初始化、从管道读写数据以及注意事项"><a href="#3、管道的初始化、从管道读写数据以及注意事项" class="headerlink" title="3、管道的初始化、从管道读写数据以及注意事项"></a>3、管道的初始化、从管道读写数据以及注意事项</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">//1、创建一个可以存放3个int的管道   </span></span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span>    </span><br><span class="line">    intChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)  <span class="comment">//channel make后才能使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、intChan是什么     </span></span><br><span class="line">    fmt.Printf(<span class="string">"intChan的值=%v intChan本身的地址=%v\n"</span>,intChan,&amp;intChan)   </span><br><span class="line">    <span class="comment">//输出：intChan的值=0xc000092080 </span></span><br><span class="line">    <span class="comment">//intChan本身的地址=0xc00008c018      </span></span><br><span class="line">    <span class="comment">//可以看出intChan的值为一个地址，所以channel是引用类型。    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、向管道写入数据     </span></span><br><span class="line">    intChan&lt;<span class="number">-10</span><span class="comment">//直接写入常量   </span></span><br><span class="line">    num:=<span class="number">211</span>     </span><br><span class="line">    intChan&lt;-num<span class="comment">//写入变量    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、看看管道的长度和容量    </span></span><br><span class="line">    <span class="comment">//容量是make时传入的，这里传入的是3，容量不能自动增长，和slice、map不一样    </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))     </span><br><span class="line">    <span class="comment">//channel len=2 cap=3    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、注意：给管道写入数据时不能超过容量     </span></span><br><span class="line">    intChan&lt;<span class="number">-50</span>      <span class="comment">//intChan&lt;-98     </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))   </span><br><span class="line">    <span class="comment">//fatal error: all goroutines are asleep - deadlock!   </span></span><br><span class="line">    <span class="comment">//报告死锁deadlock错误     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、从管道中读取数据     </span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">int</span>     </span><br><span class="line">    num2 = &lt;-intChan  </span><br><span class="line">    fmt.Println(<span class="string">"num2="</span>,num2)<span class="comment">//num2= 10，从队列头开始取     </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))    </span><br><span class="line">    <span class="comment">//channel len=2 cap=3     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、在没有使用协程的情况下，如果管道中的数据已经全部取出，再取数据就会报告死锁deadlock错误     </span></span><br><span class="line">    num3 := &lt;-intChan    </span><br><span class="line">    num4 := &lt;-intChan     </span><br><span class="line">    num5 := &lt;-intChan   </span><br><span class="line">    fmt.Println(<span class="string">"num3="</span>,num3,<span class="string">"num4="</span>,num4,<span class="string">"num5="</span>,num5)   </span><br><span class="line">    <span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li>channel中只能存放指定的数据类型</li><li>channel的数据放满后，就不能再放入了，否则报告死锁deadlock错误</li><li>当 channel的数据放满后，如果从channel中取出数据，可以再次放入数据</li><li>在没有使用协程的情况下，如果channel中的数据取完了，再次取数据，会报告死锁deadlock错误</li></ul><p>一个例子，当管道是空接口interface{}类型时，可以存放任意数据类型的值，取出管道中的值对象的的字段值时，需要类型断言<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123; </span><br><span class="line">    Name <span class="keyword">string</span>     </span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    allChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">3</span>)<span class="comment">//定义一个空接口类型，容量为3的管道allChan      </span></span><br><span class="line"></span><br><span class="line">    allChan&lt;<span class="number">-10</span><span class="comment">//往管道写入int类型的值     </span></span><br><span class="line">    allChan&lt;-<span class="string">"tom"</span><span class="comment">//往管道写入string类型的值    </span></span><br><span class="line"></span><br><span class="line">    cat:=Cat&#123;<span class="string">"小花猫"</span>,<span class="number">4</span>&#125;<span class="comment">//实例化一个Cat    </span></span><br><span class="line">    allChan&lt;-cat<span class="comment">////往管道写入Cat类型的值    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//想要取出管道中的第三个值，需要丢弃第一个和第二个    </span></span><br><span class="line">    &lt;-allChan    </span><br><span class="line">    &lt;-allChan    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//取到第三个   </span></span><br><span class="line">    newCat:=&lt;-allChan   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//newCat从编译层面看是空接口类型,接口类型本身没有字段    </span></span><br><span class="line">    <span class="comment">//但在运行时可动态指向结构体Cat，</span></span><br><span class="line">    <span class="comment">//下面写法语法上没错，运行时可动态指向Cat     </span></span><br><span class="line">    fmt.Printf(<span class="string">"newCat的类型=%T newCat的值=%v\n"</span>,newCat,newCat)   </span><br><span class="line">    <span class="comment">//输出：newCat的类型=main.Cat newCat的值=&#123;小花猫 4&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//newCat从编译层面看是空接口类型，接口类型本身没有字段，</span></span><br><span class="line">    <span class="comment">//直接写编译不通过，需要类型断言      </span></span><br><span class="line">    aNewCat:=newCat.(Cat)     </span><br><span class="line">    fmt.Printf(<span class="string">"newCat.Name=%v"</span>,aNewCat.Name)</span><br><span class="line">    <span class="comment">//输出：newCat.Name=小花猫</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h5 id="4、管道的遍历和关闭"><a href="#4、管道的遍历和关闭" class="headerlink" title="4、管道的遍历和关闭"></a>4、管道的遍历和关闭</h5><p> 1、管道的关闭</p><p>使用内置函数<strong>close()可以关闭管道</strong>，当管道关闭后，就不能再向管道写数据了，但是仍然可以从管道中读取数据<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)  </span><br><span class="line">    intChan&lt;<span class="number">-100</span>   </span><br><span class="line">    intChan&lt;<span class="number">-200</span>    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、关闭管道    </span></span><br><span class="line">    <span class="built_in">close</span>(intChan)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、关闭管道后，不能再写入数据   </span></span><br><span class="line">    <span class="comment">//intChan&lt;-300    </span></span><br><span class="line">    <span class="comment">//panic: send on closed channel     </span></span><br><span class="line">    <span class="comment">//向一个关闭的通道中发送数据，panic终止程序    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、关闭管道后，可以再读取数据   </span></span><br><span class="line">    n1:=&lt;-intChan    </span><br><span class="line">    fmt.Println(<span class="string">"n1="</span>,n1)<span class="comment">//n1= 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、管道的遍历<br>channel支持for-range的方式进行遍历，有两个细节注意：</p><ul><li>在遍历时，如果channel没有关闭，则会出现死锁deadlock错误</li><li>在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历</li></ul><p>在遍历时不能使用普通for循环遍历，因为管道的长度（len(intChan)）是随数据出管道-1动态变化的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环往管道中写入100个数据      </span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">100</span> ;i++  &#123;       </span><br><span class="line">        intChan&lt;-i*<span class="number">2</span>   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历，一定要先关闭管道,如果不关闭管道，会出现死锁deadlock错误     </span></span><br><span class="line">    <span class="built_in">close</span>(intChan)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//管道没有下标，for-range只返回一个值    </span></span><br><span class="line">    <span class="keyword">for</span> v:= <span class="keyword">range</span> intChan&#123;         </span><br><span class="line">        fmt.Println(<span class="string">"v="</span>,v)     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、goroutine和管道channel结合使用"><a href="#3、goroutine和管道channel结合使用" class="headerlink" title="3、goroutine和管道channel结合使用"></a>3、goroutine和管道channel结合使用</h3><h4 id="1、案例："><a href="#1、案例：" class="headerlink" title="1、案例："></a>1、案例：</h4><p>案例：<br>goroutine和管道channel协同工作<br>1）开启一个wiiteData协程，向管道写入50个整数<br>2）开启一个readData协程，从管道中读取wiiteData写入的数据<br>3）注意：wiiteData和readData操作的是同一个管道<br>4）主线程需要等待wiiteData和readData协程完成工作后才能退出<br>思路图解：<br><img src="/2020/06/11/go-goroutine、channel、反射/goandchan1.jpg" alt="goandchan1"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++  &#123;   </span><br><span class="line">        intChan&lt;-i         </span><br><span class="line">        fmt.Println(<span class="string">"writeData "</span>,i)    </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(intChan)<span class="comment">//关闭intChan，后面intChan仍然可读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//readData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>,exitChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">for</span>&#123;         </span><br><span class="line">        v,ok:=&lt;-intChan      </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;       </span><br><span class="line">          <span class="keyword">break</span>     </span><br><span class="line">         &#125;         </span><br><span class="line">        fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//readData读取数据完后，    </span></span><br><span class="line">    <span class="comment">//往exitChan写入数据true，告知主线程readData执行完毕    </span></span><br><span class="line">    exitChan&lt;-<span class="literal">true</span>   </span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//创建两个管道  </span></span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">50</span>)  </span><br><span class="line">    exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)  <span class="comment">//该管道用于等到intChan管道的读取协程工作完毕后，往exitChan写入数据，标识主线程可退出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> writeData(intChan) <span class="comment">//向管道写入50个整数</span></span><br><span class="line">    <span class="keyword">go</span> readData(intChan,exitChan)   <span class="comment">//从管道中读取wiiteData写入的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>&#123;      </span><br><span class="line">        _,ok:=&lt;-exitChan    </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;            </span><br><span class="line">             <span class="keyword">break</span>       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、管道阻塞机制"><a href="#2、管道阻塞机制" class="headerlink" title="2、管道阻塞机制"></a>2、管道阻塞机制</h4><p>如果<strong>只向管道里写数据，而没有读取</strong>，就会出现<strong>阻塞而死锁</strong>deadlock。<br>注意：如果<strong>有向管道读取数据，但读取比写数据慢得多</strong>，也不会发生死锁，只要编译器检测到数据在管道中是流动的，即有读取也有写入，那么就不会发生死锁</p><p>下面例子中，intChan容量改为10<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++  &#123;   </span><br><span class="line">        intChan&lt;-i     <span class="comment">//数据一下就放入，但下面readData读取慢慢读</span></span><br><span class="line">    </span><br><span class="line">        fmt.Println(<span class="string">"writeData "</span>,i)    </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(intChan)<span class="comment">//关闭intChan，后面intChan仍然可读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//readData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>,exitChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">for</span>&#123;         </span><br><span class="line">        v,ok:=&lt;-intChan      </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;       </span><br><span class="line">          <span class="keyword">break</span>     </span><br><span class="line">         &#125;         </span><br><span class="line">       time.Sleep(time.Second)<span class="comment">//慢慢读，每隔一秒读一次</span></span><br><span class="line">       </span><br><span class="line">      fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//readData读取数据完后，    </span></span><br><span class="line">    <span class="comment">//往exitChan写入数据true，告知主线程readData执行完毕    </span></span><br><span class="line">    exitChan&lt;-<span class="literal">true</span>   </span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//创建两个管道  </span></span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)<span class="comment">//容量10</span></span><br><span class="line">    exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)  <span class="comment">//该管道用于等到intChan管道的读取协程工作完毕后，往exitChan写入数据，标识主线程可退出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> writeData(intChan) <span class="comment">//向管道写入50个整数</span></span><br><span class="line">    <span class="keyword">go</span> readData(intChan,exitChan)   <span class="comment">//从管道中读取wiiteData写入的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>&#123;      </span><br><span class="line">        _,ok:=&lt;-exitChan    </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;            </span><br><span class="line">             <span class="keyword">break</span>       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">writeData  <span class="number">1</span></span><br><span class="line">writeData  <span class="number">2</span></span><br><span class="line">writeData  <span class="number">3</span></span><br><span class="line">writeData  <span class="number">4</span></span><br><span class="line">writeData  <span class="number">5</span></span><br><span class="line">writeData  <span class="number">6</span></span><br><span class="line">writeData  <span class="number">7</span></span><br><span class="line">writeData  <span class="number">8</span></span><br><span class="line">writeData  <span class="number">9</span></span><br><span class="line">writeData  <span class="number">10</span></span><br><span class="line">writeData  <span class="number">11</span></span><br><span class="line">readData 读到数据=<span class="number">1</span></span><br><span class="line">writeData  <span class="number">12</span></span><br><span class="line">readData 读到数据=<span class="number">2</span></span><br><span class="line">writeData  <span class="number">13</span></span><br><span class="line">readData 读到数据=<span class="number">3</span></span><br><span class="line">writeData  <span class="number">14</span></span><br><span class="line">readData 读到数据=<span class="number">4</span></span><br><span class="line">writeData  <span class="number">15</span></span><br><span class="line">readData 读到数据=<span class="number">5</span></span><br><span class="line">writeData  <span class="number">16</span></span><br><span class="line">readData 读到数据=<span class="number">6</span></span><br><span class="line">writeData  <span class="number">17</span></span><br><span class="line">readData 读到数据=<span class="number">7</span></span><br><span class="line">writeData  <span class="number">18</span></span><br><span class="line">readData 读到数据=<span class="number">8</span></span><br><span class="line">writeData  <span class="number">19</span></span><br><span class="line">readData 读到数据=<span class="number">9</span></span><br><span class="line">writeData  <span class="number">20</span></span><br><span class="line">readData 读到数据=<span class="number">10</span></span><br><span class="line">writeData  <span class="number">21</span></span><br><span class="line">readData 读到数据=<span class="number">11</span></span><br><span class="line">writeData  <span class="number">22</span></span><br><span class="line">readData 读到数据=<span class="number">12</span></span><br><span class="line">writeData  <span class="number">23</span></span><br><span class="line">readData 读到数据=<span class="number">13</span></span><br><span class="line">writeData  <span class="number">24</span></span><br><span class="line">readData 读到数据=<span class="number">14</span></span><br><span class="line">writeData  <span class="number">25</span></span><br><span class="line">readData 读到数据=<span class="number">15</span></span><br><span class="line">writeData  <span class="number">26</span></span><br><span class="line">readData 读到数据=<span class="number">16</span></span><br><span class="line">writeData  <span class="number">27</span></span><br><span class="line">readData 读到数据=<span class="number">17</span></span><br><span class="line">writeData  <span class="number">28</span></span><br><span class="line">readData 读到数据=<span class="number">18</span></span><br><span class="line">writeData  <span class="number">29</span></span><br><span class="line">readData 读到数据=<span class="number">19</span></span><br><span class="line">writeData  <span class="number">30</span></span><br><span class="line">readData 读到数据=<span class="number">20</span></span><br><span class="line">writeData  <span class="number">31</span></span><br><span class="line">readData 读到数据=<span class="number">21</span></span><br><span class="line">writeData  <span class="number">32</span></span><br><span class="line">readData 读到数据=<span class="number">22</span></span><br><span class="line">writeData  <span class="number">33</span></span><br><span class="line">readData 读到数据=<span class="number">23</span></span><br><span class="line">writeData  <span class="number">34</span></span><br><span class="line">readData 读到数据=<span class="number">24</span></span><br><span class="line">writeData  <span class="number">35</span></span><br><span class="line">readData 读到数据=<span class="number">25</span></span><br><span class="line">writeData  <span class="number">36</span></span><br><span class="line">readData 读到数据=<span class="number">26</span></span><br><span class="line">writeData  <span class="number">37</span></span><br><span class="line">readData 读到数据=<span class="number">27</span></span><br><span class="line">writeData  <span class="number">38</span></span><br><span class="line">readData 读到数据=<span class="number">28</span></span><br><span class="line">writeData  <span class="number">39</span></span><br><span class="line">readData 读到数据=<span class="number">29</span></span><br><span class="line">writeData  <span class="number">40</span></span><br><span class="line">readData 读到数据=<span class="number">30</span></span><br><span class="line">writeData  <span class="number">41</span></span><br><span class="line">readData 读到数据=<span class="number">31</span></span><br><span class="line">writeData  <span class="number">42</span></span><br><span class="line">readData 读到数据=<span class="number">32</span></span><br><span class="line">writeData  <span class="number">43</span></span><br><span class="line">readData 读到数据=<span class="number">33</span></span><br><span class="line">writeData  <span class="number">44</span></span><br><span class="line">readData 读到数据=<span class="number">34</span></span><br><span class="line">writeData  <span class="number">45</span></span><br><span class="line">readData 读到数据=<span class="number">35</span></span><br><span class="line">writeData  <span class="number">46</span></span><br><span class="line">readData 读到数据=<span class="number">36</span></span><br><span class="line">writeData  <span class="number">47</span></span><br><span class="line">readData 读到数据=<span class="number">37</span></span><br><span class="line">writeData  <span class="number">48</span></span><br><span class="line">readData 读到数据=<span class="number">38</span></span><br><span class="line">writeData  <span class="number">49</span></span><br><span class="line">readData 读到数据=<span class="number">39</span></span><br><span class="line">writeData  <span class="number">50</span></span><br><span class="line">readData 读到数据=<span class="number">40</span></span><br><span class="line">readData 读到数据=<span class="number">41</span></span><br><span class="line">readData 读到数据=<span class="number">42</span></span><br><span class="line">readData 读到数据=<span class="number">43</span></span><br><span class="line">readData 读到数据=<span class="number">44</span></span><br><span class="line">readData 读到数据=<span class="number">45</span></span><br><span class="line">readData 读到数据=<span class="number">46</span></span><br><span class="line">readData 读到数据=<span class="number">47</span></span><br><span class="line">readData 读到数据=<span class="number">48</span></span><br><span class="line">readData 读到数据=<span class="number">49</span></span><br><span class="line">readData 读到数据=<span class="number">50</span></span><br></pre></td></tr></table></figure></p><p>因为管道容量为10，所以写到11的时候，需要等待数据被读出才能写入，所以写数据12-50与读取是交错的，读取数据每隔一秒读取一次。最后数据全部写完，只需要读取数据。</p><h4 id="3、细节"><a href="#3、细节" class="headerlink" title="3、细节"></a>3、细节</h4><p>1、在默认情况下，管道是双向的，即可读可写<br>2、管道可以声明为只读或只写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管道声明为只写</span></span><br><span class="line"><span class="keyword">var</span> chan1 <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">chan1 &lt;- <span class="number">1</span> <span class="comment">//ok</span></span><br><span class="line">num1 := &lt;-chan1 <span class="comment">//error，无效的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管道声明为只读</span></span><br><span class="line"><span class="keyword">var</span> chan2 &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">num2 := &lt;-chan2 <span class="comment">//ok</span></span><br><span class="line">chan2 &lt;- <span class="number">2</span> <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p><p>管道声明为只读或只写的应用场景：</p><ul><li>先声明一个双向管道intChan</li><li>声明两个函数，一个往intChan只写数据的send函数，一个往intChan只读数据的recv函数，防止误操作</li><li>可以将双向管道intChan作为实参，传给只写数据的send函数，send函数形参为<strong>ch chan&lt;- int</strong></li><li>可以将双向管道intChan作为实参，传给只读数据的recv函数，re函数形参为<strong>ch &lt;-chan int</strong></li><li>上面所述中，将双向管道作为实参传给单向管道（只读或只写）并不会报错。</li><li>管道的双向和单向只是管道的性质，但是管道的类型都是chan int，所以不会报错</li></ul><p>3、使用<strong>select</strong>可以解决<strong>从管道取数据的阻塞问题</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">//使用select可以解决从管道取数据的阻塞问题     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、定义一个管道 10个数据 int     </span></span><br><span class="line">    intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++  &#123;     </span><br><span class="line">         intChan&lt;-i     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、定义一个管道 5个数据，string     </span></span><br><span class="line">    stringChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">5</span>)    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span> ;i++  &#123;   </span><br><span class="line">         stringChan&lt;-<span class="string">"hello"</span>+fmt.Sprintf(<span class="string">"%d"</span>,i)  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统方法在遍历管道时，如果不关闭会阻塞并死锁deadlock   </span></span><br><span class="line">    <span class="comment">//但在实际开发中，我们往往不确定关闭管道的时机    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由此我们使用select解决      </span></span><br><span class="line">    <span class="keyword">for</span>&#123;          </span><br><span class="line">        <span class="keyword">select</span> &#123;          </span><br><span class="line">        <span class="comment">//重点：这里如果intChan一直没有关闭，不会一直阻塞而死锁，                </span></span><br><span class="line">        <span class="comment">//会自动到下一个case匹配         </span></span><br><span class="line">            <span class="keyword">case</span> v:=&lt;-intChan:              </span><br><span class="line">            fmt.Printf(<span class="string">"从intChan读取了数据%d\n"</span>,v)         </span><br><span class="line">            <span class="keyword">case</span> v:=&lt;-stringChan:                   </span><br><span class="line">            fmt.Printf(<span class="string">"从stringChan读取了数据%s\n"</span>,v)              </span><br><span class="line">            <span class="keyword">default</span>:                     </span><br><span class="line">            fmt.Printf(<span class="string">"都取不到了，加入处理逻辑\n"</span>)                    </span><br><span class="line">            <span class="keyword">return</span>        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">从stringChan读取了数据hello0</span><br><span class="line">从intChan读取了数据<span class="number">0</span></span><br><span class="line">从stringChan读取了数据hello1</span><br><span class="line">从stringChan读取了数据hello2</span><br><span class="line">从stringChan读取了数据hello3</span><br><span class="line">从intChan读取了数据<span class="number">1</span></span><br><span class="line">从intChan读取了数据<span class="number">2</span></span><br><span class="line">从stringChan读取了数据hello4</span><br><span class="line">从intChan读取了数据<span class="number">3</span></span><br><span class="line">从intChan读取了数据<span class="number">4</span></span><br><span class="line">从intChan读取了数据<span class="number">5</span></span><br><span class="line">从intChan读取了数据<span class="number">6</span></span><br><span class="line">从intChan读取了数据<span class="number">7</span></span><br><span class="line">从intChan读取了数据<span class="number">8</span></span><br><span class="line">从intChan读取了数据<span class="number">9</span></span><br><span class="line">都取不到了，加入处理逻辑</span><br></pre></td></tr></table></figure></p><p>4、<strong>goroutine中使用recover，解决协程中出现panic</strong>，导致程序崩溃问题</p><ul><li><p>如果我们起了一个协程，但是这个协程出现了panic，如果我们没有捕获这个panic，就会造成成哥程序的崩溃，</p></li><li><p>这时可以在该协程中使用recover来捕获panic进行处理。这样即使这个协程发生问题，主线程仍然不受影响，继续执行。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数sayHello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;           </span><br><span class="line">        time.Sleep(time.Second)    </span><br><span class="line">        fmt.Println(<span class="string">"hello world"</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="comment">//这里使用defer+recover解决panic终止程序    </span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;           </span><br><span class="line">    <span class="comment">//捕获test抛出的panic         </span></span><br><span class="line">        <span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span> &#123;            </span><br><span class="line">              fmt.Println(<span class="string">"test() 发生错误"</span>)   </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个map  </span></span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>     </span><br><span class="line">    myMap[<span class="number">0</span>]=<span class="string">"golang"</span><span class="comment">//空map直接赋值，报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="keyword">go</span> sayHello()    </span><br><span class="line">    <span class="keyword">go</span> test()   <span class="comment">//这个协程会panic 使用defer+recover解决</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;       </span><br><span class="line">        time.Sleep(time.Second)       </span><br><span class="line">        fmt.Println(<span class="string">"main() ok="</span>,i)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">test() 发生错误</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">0</span></span><br><span class="line">main() ok= <span class="number">1</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">2</span></span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">3</span></span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">4</span></span><br><span class="line">main() ok= <span class="number">5</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">6</span></span><br><span class="line">main() ok= <span class="number">7</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">8</span></span><br><span class="line">main() ok= <span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>由输出看出，test协程出错，但是主线程和sayHello协程继续执行</p><h3 id="4、反射"><a href="#4、反射" class="headerlink" title="4、反射"></a>4、反射</h3><h4 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、反射的作用：</p><ul><li><p>1）、反射可以在运行时动态获取变量的各种信息，如变量的类型（type）、类别（kind）</p></li><li><p>2）、如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段、方法）</p></li><li><p>3）、通过反射，可以修改变量的值，可以调用关联的方法</p></li><li><p>4）、使用反射，需要import（“reflect”）</p></li></ul><p>reflect实现了运行时反射，允许程序操作任意类型的对象，典型用法是用静态类型interface{}保存一个值，通过<strong>调用TypeOf获取类型信息</strong>，该函数返回一个Type类型值，<strong>调用ValueOf函数返回一个value类型值</strong>，该值代表运行时数据，Zero接受一个Type类型参数并返回该类型零值的value类型值。</p><ul><li>5）、反射示意图</li></ul><p><img src="/2020/06/11/go-goroutine、channel、反射/reflect1.png" alt="reflect1"></p><p><strong>reflect.Type是一个接口</strong>，定义了非常多方法，通过这些方法可以反向操作变量，获取变量的各种信息</p><p><strong>reflect.Value是一个结构体</strong>，包含了非常多方法，可通过Type()方法将Value转换为Type、返回变量的字段和方法等等</p><ul><li>6）、变量、interface{}和reflect.Value是可以相互转换的<br><img src="/2020/06/11/go-goroutine、channel、反射/reflect2.png" alt="reflect2"></li></ul><h4 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h4><p>1、对基本数据类型、interface{}、reflect.Value进行反射的基本操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (     </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//通过反射获取传入变量的type、kind、值     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、先获取到reflect.Type     </span></span><br><span class="line">    rTyp := reflect.TypeOf(b)     </span><br><span class="line">    fmt.Println(<span class="string">"rTyp="</span>,rTyp)     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取到reflect.Value     </span></span><br><span class="line">    rVal := reflect.ValueOf(b)<span class="comment">//rVal=100      </span></span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)     </span><br><span class="line">    <span class="comment">//n:=rVal+2 </span></span><br><span class="line">    <span class="comment">//error，rVal的类型不是int，是reflect.Value，不能做运算    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、如果要做运算，如下      </span></span><br><span class="line">    n:=rVal.Int()+<span class="number">2</span>     </span><br><span class="line">    fmt.Println(<span class="string">"n="</span>,n)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、将rval转成interface&#123;&#125;      </span></span><br><span class="line">    iv:=rVal.Interface()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、将interface&#123;&#125;通过断言转成int(对应的类型)    </span></span><br><span class="line">    num2:=iv.(<span class="keyword">int</span>)     </span><br><span class="line">    fmt.Printf(<span class="string">"num2=%v num2的type=%T\n"</span>,num2,num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//1、定义一个int     </span></span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span>     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、反射</span></span><br><span class="line">    reflectTest01(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rTyp= <span class="keyword">int</span></span><br><span class="line">rVal=<span class="number">100</span> rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">n= <span class="number">102</span></span><br><span class="line">num2=<span class="number">100</span> num2的<span class="keyword">type</span>=<span class="keyword">int</span></span><br></pre></td></tr></table></figure></p><p>2、对结构体、interface{}、reflect.Value进行反射的基本操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Name <span class="keyword">string</span>     </span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对结构体反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest02</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//通过反射获取传入变量的type、kind、值     </span></span><br><span class="line">    <span class="comment">//1、先获取到reflect.Type   </span></span><br><span class="line">    rTyp := reflect.TypeOf(b)    </span><br><span class="line">    fmt.Println(<span class="string">"rTyp="</span>,rTyp)   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取到reflect.Value     </span></span><br><span class="line">    rVal := reflect.ValueOf(b)   </span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、获取变量对应的kind，两种方式等价</span></span><br><span class="line">    <span class="comment">//(1)通过获取到的reflect.Type来获取 =》rTyp.Kind()</span></span><br><span class="line">    kind1:=rTyp.Kind()</span><br><span class="line">    <span class="comment">//(2)通过获取到的reflect.Value来获取 =》rVal.Kind()</span></span><br><span class="line">   kind2:=rVal.Kind()</span><br><span class="line">   fmt.Printf(<span class="string">"kind1=%v kind2=%v\n"</span>,kind1,kind2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、将rval转成interface&#123;&#125;     </span></span><br><span class="line">    iv:=rVal.Interface()     </span><br><span class="line">    fmt.Printf(<span class="string">"iv=%v iv的type=%T\n"</span>,iv,iv)  </span><br><span class="line">    <span class="comment">//输出：iv=&#123;tom 20&#125; iv的type=main.Student   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、iv的type=main.Student，但是通过iv取字段会报错     </span></span><br><span class="line">    <span class="comment">//iv.Name     </span></span><br><span class="line">    <span class="comment">//error 因为编译器在编译阶段无法知道iv的类型是main.Student，只有运行时才知道     </span></span><br><span class="line">    <span class="comment">//所以这里直接编译报错    </span></span><br><span class="line">    <span class="comment">//反射是在程序运行时工作的    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、将interface&#123;&#125;通过断言转成int(对应的类型)    </span></span><br><span class="line">    stu:=iv.(Student)    </span><br><span class="line">    <span class="keyword">if</span> ok &#123;     </span><br><span class="line">        fmt.Printf(<span class="string">"stu=%v stu的type=%T\n"</span>,stu,stu)    </span><br><span class="line">        fmt.Printf(<span class="string">"stu.Name=%v stu.Age=%v\n"</span>,stu.Name,stu.Age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//1、定义一个student实例   </span></span><br><span class="line">    stu:=Student&#123;<span class="string">"tom"</span>,<span class="number">20</span>&#125;     </span><br><span class="line">    <span class="comment">//2、反射   </span></span><br><span class="line">    reflectTest02(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rTyp= main.Student</span><br><span class="line">rVal=&#123;tom <span class="number">20</span>&#125; rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">kind1=<span class="keyword">struct</span> kind2=<span class="keyword">struct</span></span><br><span class="line">iv=&#123;tom <span class="number">20</span>&#125; iv的<span class="keyword">type</span>=main.Student</span><br><span class="line">stu=&#123;tom <span class="number">20</span>&#125; stu的<span class="keyword">type</span>=main.Student</span><br><span class="line">stu.Name=tom stu.Age=<span class="number">20</span></span><br></pre></td></tr></table></figure></p><h4 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h4><p>1、reflect.Value.Kind()，获取变量的类别，返回一个常量。type是一个大范畴，kind在type上细分（如type只返回int，kind返回具体的int32，int64的常量定义的值等）<br>在上面的例子中有：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、获取变量对应的kind，两种方式等价</span></span><br><span class="line">    <span class="comment">//(1)通过获取到的reflect.Type来获取 =》rTyp.Kind()</span></span><br><span class="line">    kind1:=rTyp.Kind()</span><br><span class="line">    <span class="comment">//(2)通过获取到的reflect.Value来获取 =》rVal.Kind()</span></span><br><span class="line">   kind2:=rVal.Kind()</span><br><span class="line">   fmt.Printf(<span class="string">"kind1=%v kind2=%v\n"</span>,kind1,kind2)</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kind1=<span class="keyword">struct</span> kind2=<span class="keyword">struct</span></span><br></pre></td></tr></table></figure></p><p>2、Type和Kind的区别：Type是类型，Kind是类别，<strong>Type和Kind可能相同也可能不同</strong></p><ul><li>var num int = 10 num的Type是int，Kind也是int</li><li>var stu Student   stu的Type是<strong>包名.Student</strong>，Kind是struct</li></ul><p>3、变量、interface{}和reflect.Value是可以相互转换的</p><p>4、使用反射的方式来获取变量的值（并返回对应的类型），要求数据类型匹配，如x是int，那么就应该用reflect.ValueOf(x).Int()，不能使用其他，否则panic</p><p>5、通过反射修改变量的值，注意当使用SetXXX方法来修改变量的值，需要通过变量对应的指针来修改，这时需要使用reflect.Value.Elem()方法</p><ul><li><p>func (v Value) SetXXX(x XXX)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">SetXXX</span><span class="params">(x XXX)</span></span> </span><br><span class="line"><span class="comment">//SetXXX方法是和Value类型绑定的方法，不能用指针类型去调用它，只能把指针类型再转为Value类型，使用Elem函数</span></span><br></pre></td></tr></table></figure></li><li><p>func (v Value) Elem() Value   </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"> <span class="comment">//重点：Elem返回v持有的接口保管的值的Value类型封装，或持有的指针指向的值的Value类型封装</span></span><br></pre></td></tr></table></figure></li></ul><p>代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line"><span class="string">"fmt"</span>    </span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改反射变量的值    </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;    </span><br><span class="line">    <span class="comment">//1、获取到reflect.Value  </span></span><br><span class="line">    rVal := reflect.ValueOf(b)<span class="comment">//rVal=100    </span></span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)  </span><br><span class="line">    <span class="comment">//main函数中调用函数时传的是地址，rVal的值为一个地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取rVal的Kind    </span></span><br><span class="line">    rKind:=rVal.Kind()  </span><br><span class="line">    fmt.Printf(<span class="string">"rVal Kind=%v\n"</span>,rKind)   </span><br><span class="line">    <span class="comment">//输出：rVal Kind=ptr，</span></span><br><span class="line">    <span class="comment">//rVal的Kind是指针，因为main函数中调用函数时传的是地址     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、通过SetXXX修改变量的值    </span></span><br><span class="line">    <span class="comment">//rVal.SetInt(20) //error   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//func (v Value) SetXXX(x XXX)，  </span></span><br><span class="line">    <span class="comment">//SetXXX方法是和Value类型绑定的方法，不能用指针类型去调用它    </span></span><br><span class="line">    <span class="comment">//只能把指针类型再转为Value类型，使用Elem函数    </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//func (v Value) Elem() Value   </span></span><br><span class="line">    <span class="comment">//Elem返回v持有的接口保管的值的Value类型封装，或持有的指针指向的值的Value类型封装     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、通过Elem()获取到指针指向的值，再通过SetXXX修改变量的值     </span></span><br><span class="line">    rVal.Elem().SetInt(<span class="number">20</span>)    <span class="comment">//值修改为20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;     </span><br><span class="line">    <span class="comment">//1、定义一个int    </span></span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span>     </span><br><span class="line">    <span class="comment">//2、反射    </span></span><br><span class="line">    reflectTest01(&amp;num)<span class="comment">//修改变量num的值，所以要穿num的地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、打印修改后的num</span></span><br><span class="line">    fmt.Println(<span class="string">"num="</span>,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rVal=<span class="number">0xc000060058</span> rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">rVal Kind=ptr</span><br><span class="line">num= <span class="number">20</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、goroutine&quot;&gt;&lt;a href=&quot;#1、goroutine&quot; class=&quot;headerlink&quot; title=&quot;1、goroutine&quot;&gt;&lt;/a&gt;1、goroutine&lt;/h3&gt;&lt;h4 id=&quot;1、基本介绍&quot;&gt;&lt;a href=&quot;#1、基本介绍&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>go:文件操作、json</title>
    <link href="http://yoursite.com/2020/06/11/go-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E3%80%81json/"/>
    <id>http://yoursite.com/2020/06/11/go-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E3%80%81json/</id>
    <published>2020-06-11T07:54:54.000Z</published>
    <updated>2020-06-11T07:56:22.157Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、文件操作"><a href="#1、文件操作" class="headerlink" title="1、文件操作"></a>1、文件操作</h3><h4 id="1、基本认识"><a href="#1、基本认识" class="headerlink" title="1、基本认识"></a>1、基本认识</h4><p>1、文件在程序中是以 <strong>流</strong> 的形式来操作的</p><ul><li>流：数据在数据源（文件）和程序（内存）之间经历的路径</li><li>输入流：数据从数据源（文件）到程序（内存）之间的路径</li><li>输出流：数据从程序（内存）到数据源（文件）之间的路径</li></ul><p><img src="/2020/06/11/go-文件操作、json/file1.png" alt="file1"></p><p>2、GO中，os.File封装所有文件相关操作（方法），File是一个结构体</p><p>3、<strong>文件是引用类型</strong></p><h4 id="2、文件操作"><a href="#2、文件操作" class="headerlink" title="2、文件操作"></a>2、文件操作</h4><h5 id="1、打开文件"><a href="#1、打开文件" class="headerlink" title="1、打开文件"></a>1、打开文件</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(file *File,err error)</span></span></span><br></pre></td></tr></table></figure><p>Open打开一个文件用于读取，如果操作成功，返回一个文件对象（结构体指针或者文件句柄）可用于读取数据；如果出错，错误底层类型是PathError</p><h5 id="2、关闭文件"><a href="#2、关闭文件" class="headerlink" title="2、关闭文件"></a>2、关闭文件</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File )</span> <span class="title">Close</span> <span class="params">(error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>Close关闭文件f，用于读取，使文件不能用于读写。返回可能出现的错误</p><p>案例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.Open(<span class="string">"d:/test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出文件</span></span><br><span class="line">    fmt.Printf(<span class="string">"file=%v"</span>,file)<span class="comment">//输出 file=&amp;&lt;0xcXXXXXXXX&gt;，</span></span><br><span class="line">    <span class="comment">//看出文件是一个地址（指针）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    err = file.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"close file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3、读文件操作应用实例"><a href="#3、读文件操作应用实例" class="headerlink" title="3、读文件操作应用实例"></a>3、读文件操作应用实例</h5><p>1、读取文件的内容并显示在终端（<strong>带缓冲区</strong>的方式）<br>os.Open()、 file.Close()、bufio.NewReader()<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.Open(<span class="string">"d:/test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当函数退出时，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个 *Reader，是带缓冲的</span></span><br><span class="line">    <span class="comment">//默认缓冲4096个字节</span></span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环读取文件的内容</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        str ,err :=  reader.ReadString(<span class="string">"\n"</span>)<span class="comment">//读到一个换行就结束一次</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;<span class="comment">//io.EOF表示文件的末尾</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//输出内容</span></span><br><span class="line">         fmt.Print(str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件读取结束</span></span><br><span class="line">     fmt.Println(<span class="string">"文件读取结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、读取文件的内容并显示在终端（使用ioutil一次性将整个文件读入到内存中），这种方式适合文件不大的情况 。</p><ul><li>这种方式不用显示的Open和Close文件，因为文件的Open和Close被封装到ReadFile函数内部</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file = <span class="string">"d:/test.txt"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用ioutil.ReadFile一次性将文件读取完</span></span><br><span class="line">    content,err := ioutil.ReadFile(file)<span class="comment">//返回一个[]byte（byt切片）</span></span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"read file err="</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把读取的文件内容显示到终端</span></span><br><span class="line">    fmt.Printf(<span class="string">"content=%v"</span>,content)<span class="comment">//这是一个[]byte</span></span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">"content=%v"</span>,<span class="keyword">string</span>(content))<span class="comment">//[]byte转成string输出</span></span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、写文件操作应用实例"><a href="#4、写文件操作应用实例" class="headerlink" title="4、写文件操作应用实例"></a>4、写文件操作应用实例</h5><p>1、基本介绍<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(path <span class="keyword">string</span>,flag <span class="keyword">int</span>,perm FileMode)</span> <span class="params">(file *File,err error)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>path：要打开文件的路径</li><li>flag：打开文件的方式</li><li>perm：文件权限，Windows系统下无效，Unix和Linux下有效</li></ul><h6 id="1、实例一"><a href="#1、实例一" class="headerlink" title="1、实例一"></a>1、实例一</h6><p> 带缓冲bufio.NewWriter</p><p>1）创建一个<strong>新文件</strong>，<strong>写入</strong>内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_WRONLY | os.O_CREATE,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以只写方式打开，如果没有文件就创建一个，如果有就继续往下</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入内容</span></span><br><span class="line">    str := <span class="string">"要写入的内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2）打开一个<strong>已经存在</strong>的文件，将原来的内容<strong>覆盖</strong>成新的内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_WRONLY | os.O_TRUNC,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以只写方式打开，如果文件已经有内容就清空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入要覆盖的新内容</span></span><br><span class="line">    str := <span class="string">"写入要覆盖的新内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3）打开一个<strong>已经存在</strong>的文件，在原来的内容<strong>追加</strong>新的内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_WRONLY | os.O_APPEND,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以只写方式打开，在文件末尾以追加的形式写入内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入要追加写入的新内容</span></span><br><span class="line">    str := <span class="string">"追加写入的新内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4）打开一个已经存在的文件，将原来的内容<strong>读出</strong>显示在终端，并<strong>追加</strong>新的内容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    filePath := <span class="string">"d:\abc.test"</span></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    file , err := os.OpenFile(filePath,os,O_RDWR | os.O_APPEND,<span class="number">0666</span>)</span><br><span class="line">    <span class="comment">//以读写方式打开，在文件末尾以追加的形式写入内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"open file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当main函数退出之前，要及时关闭文件</span></span><br><span class="line">    <span class="keyword">defer</span>  file.Close() <span class="comment">//及时关闭file句柄，防止内存泄漏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先读取文件原来的内容，并显示在终端</span></span><br><span class="line">     <span class="comment">//创建一个 *Reader，是带缓冲的</span></span><br><span class="line">    <span class="comment">//默认缓冲4096个字节</span></span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环读取文件的内容</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        str ,err :=  reader.ReadString(<span class="string">"\n"</span>)<span class="comment">//读到一个换行就结束一次</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;<span class="comment">//io.EOF表示文件的末尾</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//输出内容，显示在终端</span></span><br><span class="line">         fmt.Print(str)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入要追加写入的新内容</span></span><br><span class="line">    str := <span class="string">"第二次追加写入的新内容\r\n"</span></span><br><span class="line">    <span class="comment">//有的编辑器\n会换行</span></span><br><span class="line">    <span class="comment">//有的编辑器\r才会换行（如记事本）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时，使用带缓冲的*Writer</span></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环写入内容</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;<span class="comment">//写5次</span></span><br><span class="line">        writer.writerString(<span class="string">"str"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为Writer是带缓存的，</span></span><br><span class="line">    <span class="comment">//因此在调用writerString方法时，内容是先写入缓存的，</span></span><br><span class="line">    <span class="comment">//所以需要调用Flush方法，将缓冲的数据真正写入到文件中，</span></span><br><span class="line">    <span class="comment">//否则文件中会没有数据</span></span><br><span class="line">    writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="2、实例二"><a href="#2、实例二" class="headerlink" title="2、实例二"></a>2、实例二</h6><p>将一个文件的内容，写入到另外一个文件。（两个文件已经存在）<br>ioutil.ReadFile/ioutil.WriteFile<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将”d:/test.txt“文件内容导入到”e:/kkk.txt“</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1、将”d:/test.txt“文件内容读取到内存</span></span><br><span class="line">    <span class="comment">//2、将读取到的内容写入”e:/kkk.txt“</span></span><br><span class="line">    </span><br><span class="line">      file1Path = <span class="string">"d:/test.txt"</span></span><br><span class="line">      file2Path = <span class="string">"e:/kkk.txt"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用ioutil.ReadFile一次性将文件读取完</span></span><br><span class="line">    data,err := ioutil.ReadFile(file1Path)<span class="comment">//返回一个[]byte（byt切片）</span></span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"read file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把读取的文件内容显写入e:/kkk.txt文件</span></span><br><span class="line">    err = ioutil.WriteFile(file2Path,data,<span class="number">0666</span>)<span class="comment">//data接收一个[]byte</span></span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"write file err="</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5、判断文件或文件夹是否存在"><a href="#5、判断文件或文件夹是否存在" class="headerlink" title="5、判断文件或文件夹是否存在"></a>5、判断文件或文件夹是否存在</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(filePath <span class="keyword">string</span>)</span> <span class="params">(fi FileInfo,err error)</span></span></span><br></pre></td></tr></table></figure><ul><li>如果返回的error为nil，说明文件或文件夹存在</li><li>如果返回的error使用为os.IsNotExist判断为true，说明文件或文件夹不存在</li><li>如果返回的error为其他类型，则不确定是否存在</li></ul><h3 id="2、json"><a href="#2、json" class="headerlink" title="2、json"></a>2、json</h3><p>1、JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。易于人阅读和编写，也易于机器解析和生成，并有效提升网络效率。</p><p>2、json序列化（如struct、map、slice序列化成json字符串）<br>json.Marshal()序列化后是一个[]byte，要转string<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span>    </span><br><span class="line">    Birthday  <span class="keyword">string</span>    </span><br><span class="line">    Sal <span class="keyword">float64</span>    </span><br><span class="line">    Skill <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monster := Monster&#123;</span><br><span class="line">        Name:<span class="string">"牛魔王"</span>,            </span><br><span class="line">        Age:<span class="number">500</span>,            </span><br><span class="line">        Birthday:<span class="string">"2011-11-11"</span>,           </span><br><span class="line">        Sal:<span class="number">8000.0</span>,            </span><br><span class="line">        Skill:<span class="string">"牛魔拳"</span>,      </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line"><span class="comment">//将monster序列化     </span></span><br><span class="line">data,err:=json.Marshal(&amp;monster)      </span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;            </span><br><span class="line">    fmt.Printf(<span class="string">"序列化失败 err=%v\n"</span>,err)     </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出序列化后的结果     </span></span><br><span class="line">    <span class="comment">//json.Marshal(&amp;monster)序列化后是一个[]byte，要转string      </span></span><br><span class="line">    fmt.Printf(<span class="string">"序列化后的结果monster=%v"</span>,<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testStruct()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序列化后的结果monster=&#123;<span class="string">"Name"</span>:<span class="string">"牛魔王"</span>,<span class="string">"Age"</span>:<span class="number">500</span>,<span class="string">"Birthday"</span>:<span class="string">"2011-11-11"</span>,<span class="string">"Sal"</span>:<span class="number">8000</span>,<span class="string">"Skill"</span>:<span class="string">"牛魔拳"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>注意：也可以对基本数据类型进行序列化，序列化结果直接将基本数据类型转成string，但是对基本数据类型进行序列化一般没有意义。</p><p>3、json反序列化（如将json反序列化成struct、map、slice）<br>json.Unmarshal([]byte(str),&amp;monster)第一个参数要传一个[]byte<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span> </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span>    </span><br><span class="line">    Age <span class="keyword">int</span>    </span><br><span class="line">    Birthday  <span class="keyword">string</span>     </span><br><span class="line">    Sal <span class="keyword">float64</span>    </span><br><span class="line">    Skill <span class="keyword">string</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unSerialStruct</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    str:=<span class="string">"&#123;\"Name\":\"牛魔王\",\"Age\":500,\"Birthday\":\"2011-11-11\","</span> +            <span class="string">"\"Sal\":8000,\"Skill\":\"牛魔拳\"&#125;"</span>     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个Monster实例      </span></span><br><span class="line">    <span class="keyword">var</span> monster Monster      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//json.Unmarshal([]byte(str),&amp;monster)第一个参数要传一个[]byte     </span></span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(str),&amp;monster)</span><br><span class="line">    <span class="comment">//传地址才能改变var monster的值</span></span><br><span class="line">      <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123; </span><br><span class="line">         fmt.Printf(<span class="string">"反序列化失败 err=%v\n"</span>,err)    </span><br><span class="line">      &#125;      </span><br><span class="line">      </span><br><span class="line">      fmt.Printf(<span class="string">"反序列化后的结果monster=%v"</span>,monster)</span><br><span class="line"> &#125;</span><br><span class="line">      </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">        unSerialStruct()  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反序列化后的结果monster=&#123;牛魔王 <span class="number">500</span> <span class="number">2011</span><span class="number">-11</span><span class="number">-11</span> <span class="number">8000</span> 牛魔拳&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、文件操作&quot;&gt;&lt;a href=&quot;#1、文件操作&quot; class=&quot;headerlink&quot; title=&quot;1、文件操作&quot;&gt;&lt;/a&gt;1、文件操作&lt;/h3&gt;&lt;h4 id=&quot;1、基本认识&quot;&gt;&lt;a href=&quot;#1、基本认识&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>go:结构体、方法、工厂模式、OOP三大特性、类型断言、接口</title>
    <link href="http://yoursite.com/2020/06/11/go-%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%81OOP%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E3%80%81%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E3%80%81%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/06/11/go-%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%81OOP%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E3%80%81%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E3%80%81%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-06-11T07:35:04.000Z</published>
    <updated>2020-06-11T07:57:30.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象-结构体"><a href="#面向对象-结构体" class="headerlink" title="面向对象-结构体"></a>面向对象-结构体</h3><p>1、GO支持面向对象编程（OOP），但不是纯粹的面向对象编程语言，更准确地说是<strong>GO支持面向对象编程特性</strong><br>2、GO没有类的概念，结构体（struct）来实现OOP<br>3、GO面向对象编程非常简洁，去掉传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等<br>4、Go仍然有面向对象编程的继承、封装和多态的特性，只是实现方式不一样。<br>5、GO面向对象（OOP）很优雅，OOP本身就是语言类型系统的一部分（Go天然支持OOP），通过接口（interface）关联，耦合性低，非常灵活。<br>6、GO更准确的说是<strong>面向接口编程</strong></p><h5 id="1、结构体变量在内存中的布局"><a href="#1、结构体变量在内存中的布局" class="headerlink" title="1、结构体变量在内存中的布局"></a>1、结构体变量在内存中的布局</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Color <span class="keyword">string</span></span><br><span class="line">    Hobby <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个结构体cat变量</span></span><br><span class="line">vat cat1 Cat</span><br><span class="line">cat.Name = <span class="string">"小白"</span></span><br><span class="line">cat.Age = <span class="number">3</span></span><br><span class="line">cat.Color = <span class="string">"白色"</span></span><br><span class="line">cat.Hobby = <span class="string">"吃鱼"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"cat1="</span>,cat1)</span><br></pre></td></tr></table></figure><p>结构体是自定义的数据类型(如Cat)，结构体变量（实例）是具体的、实际的一个变量(如cat1)</p><p>结构体实例在内存中的布局，以cat1为例<br>1、当代码执行到“var cat1 Cat”时，cat1指向一个结构体，这时还没有给结构体的各个字段赋值，所以各个字段为默认值<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/struct1.jpg" alt="struct1"></p><p>2、结构体有一个自己的地址，cat1直接指向一个结构体的数据空间，而不是结构体的地址，所以<strong>结构体是值类型</strong></p><p>3、赋值语句为结构体的字段赋值<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/struct2.jpg" alt="struct2"></p><p>总结：</p><ul><li>当我们声明一个结构体变量时，结构体的数据空间已经有了，且结构体的每个字段已有<strong>默认值</strong></li><li>声明结构体变量后，该变量指向一个结构体的数据空间，而不是该结构体数据空间的地址，所以结构体是<strong>值类型</strong></li></ul><h5 id="2、结构体声明"><a href="#2、结构体声明" class="headerlink" title="2、结构体声明"></a>2、结构体声明</h5><p>1、在创建一个变量后，如果没有给字段赋值，系统会赋零值</p><ul><li>基本数据类型赋零值</li><li><strong>引用类型：slice、map、指针的零值是nil，即没有分配内存空间</strong></li><li>数组类型的默认值与元素相关</li></ul><p>2、不同结构体变量的字段你是独立的，互不影响。因为结构体是值类型、默认是值拷贝</p><h5 id="3、创建结构体实例的4种方式"><a href="#3、创建结构体实例的4种方式" class="headerlink" title="3、创建结构体实例的4种方式"></a>3、创建结构体实例的4种方式</h5><p>1、直接声明<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vat person Person</span><br><span class="line">person.field1 = value1</span><br><span class="line">person.field2 = value2</span><br><span class="line">person.field3 = value3</span><br></pre></td></tr></table></figure></p><p>2、声明时直接为字段赋值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vat person Person = Person&#123;</span><br><span class="line">    field1:value1</span><br><span class="line">    field2:value2</span><br><span class="line">    field3:value3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、通过new函数创建，创建对象是一个指向该结构体的指针<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vat person *Person = <span class="built_in">new</span>(Person)</span><br><span class="line"><span class="comment">//person是一个指针，标准赋值方式如下</span></span><br><span class="line">(*person).field1 = value1  </span><br><span class="line">(*person).field2 = value2</span><br><span class="line">(*person).field3 = value3</span><br><span class="line"><span class="comment">//运算符优先级："." &gt; "*"，所以需要括号(*person).field1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可简写为</span></span><br><span class="line">person.field1 = value1</span><br><span class="line">person.field2 = value2</span><br><span class="line">person.field3 = value3</span><br><span class="line"></span><br><span class="line"><span class="comment">//GO的设计者为了使用方便，底层会对简写写法person.field1 = value1进行处理，会给person加上取值运算 (*person).field1 = value1</span></span><br></pre></td></tr></table></figure></p><p>4、vat person *Person = &amp;Person{}，可以直接再{}中赋值，如方式2，也可如下赋值，如方式3<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    vat person *Person = &amp;Person&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person是一个指针，标准赋值方式如下</span></span><br><span class="line">    (*person).field1 = value1</span><br><span class="line">    (*person).field2 = value2</span><br><span class="line">    (*person).field3 = value3</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可简写为</span></span><br><span class="line">    person.field1 = value1</span><br><span class="line">    person.field2 = value2</span><br><span class="line">    person.field3 = value3</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GO的设计者为了使用方便，底层会对简写写法person.field1 = value1进行处理，会给person加上取值运算 (*person).field1 = value1</span></span><br></pre></td></tr></table></figure></p><p>总结:</p><ul><li>方式3和方式4返回的是一个<strong>结构体指针</strong></li></ul><h5 id="4、结构体内细节"><a href="#4、结构体内细节" class="headerlink" title="4、结构体内细节"></a>4、结构体内细节</h5><p>1、<strong>结构体中所有字段在内存中是连续分布的</strong><br>2、当结构体的字段是指针时，指针本身的地址是连续的，但是指针指向的地址指值不一定连续<br>3、结构体使用户单独定义的类型，和其它类型转换时，需要有完全相同的字段（名字、个数和累型）<br>4、结构体进行type重新定义（相当于取别名），Go认为是<strong>新的数据类型</strong>，但是相互间可以强转<br>5、在结构体的每个字段上，可以写上一个<strong>tag</strong>，该tag可以通过<strong>反射机制</strong>获取，常见的使用场景就是<strong>序列化</strong>和<strong>反序列化</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age <span class="keyword">int</span> <span class="string">`json:"age"`</span></span><br><span class="line">    Skill <span class="keyword">string</span> <span class="string">`json:"skill"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">monster := Monster&#123;</span><br><span class="line">    <span class="string">"牛魔王"</span>，</span><br><span class="line">    <span class="number">500</span>，</span><br><span class="line">    “牛头拳”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将monster变量序列化为json字符串（反射机制）</span></span><br><span class="line">jsonStr,err := json.Marshal(monster)<span class="comment">//返回值为[]byte切片</span></span><br><span class="line"><span class="comment">//这里json包去访问monster中的字段，如果字段小写则访问不到，字段小写表示只能当前包内访问，则只能大写。但是大写，json格式化后json串中也是大写，与前端命名习惯不一致，所以可以用tag为字段取别名成小写形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"json处理错误"</span>，err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"jsonStr"</span>,<span class="keyword">string</span>(jsonStr))</span><br></pre></td></tr></table></figure></p><h3 id="方法method"><a href="#方法method" class="headerlink" title="方法method"></a>方法method</h3><p>1、Go中方法是<strong>作用在指定的数据类型上</strong>的（和指定数据类型绑定），因此自定义类型，都可以有方法（不仅是struct）。</p><p>2、方法的声明与调用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="comment">//A结构体有一个方法test，说明test方法和结构体（类型）A绑定，test方法只能被A的对象来调用</span></span><br><span class="line"></span><br><span class="line">    a.Num=<span class="number">2</span> <span class="comment">//这里的改变不会影响main函数中的赋值输出，因为struct是值类型，func (a A)这里不是指针。</span></span><br><span class="line">    fmt.Println(a.Num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a A </span><br><span class="line">    a.Num=<span class="number">1</span></span><br><span class="line">    a.test()<span class="comment">//调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   由上述代码有：</p><ul><li>1、test方法和A类型绑定</li><li>2、test方法只能通过A的实例来调用，<strong>不能直接调用</strong>，也不能用其他类型调用</li><li><strong>3</strong>、func (a A) test()，<strong>a表示哪个A实例调用，他就是该实例的副本</strong>，和函数传参类似，由于<strong>struct是值类型</strong>，func (a A)这里不是指针，所以方法中对字段重新赋值不会影响main函数中的值</li></ul><h4 id="方法的调用和传参机制"><a href="#方法的调用和传参机制" class="headerlink" title="方法的调用和传参机制"></a>方法的调用和传参机制</h4><p><strong>重点</strong>：方法的调用和传参机制和函数基本一样，不一样的地方是方法调用时，<strong>会将调用方法的实例变量，当作实参也传递给方法</strong></p><p>示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">getSum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p Person </span><br><span class="line">    p.Name = <span class="string">"tom"</span></span><br><span class="line">    </span><br><span class="line">    n1 := <span class="number">10</span></span><br><span class="line">    n2 := <span class="number">20</span></span><br><span class="line">    res := p.getSum(n1,n2)<span class="comment">//调用方法</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1、main函数中执行“n1 := 10 n2 := 20”时，内存中开辟main栈并压入变量n1和n2<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method1.png" alt="method1"></p><p>2、main函数执行 “ res := p.getSum(n1,n2)”时：</p><ul><li>先执行“p.getSum(n1,n2)”，内存中开辟getSum栈，并将n1和n2的值拷贝到getSum栈中，同时将结构体实例p值拷贝到getSum栈中（因为结构体实例p调用方法getSum），因为这里传的是“func (p Person)”，所以是值拷贝，所以main栈和getSum栈是完全独立的数据空间。若传指针则为引用传递<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method2.png" alt="method2"></li></ul><ul><li>然后执行赋值给res变量“res := p.getSum(n1,n2)”，main栈中压入res变量，res变量的值有函数getSum返回<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/method3.png" alt="method3"></li></ul><p>注意：<strong>如果一个类型（结构体）实现了String()这个方法，fmt.Println默认会调用这个结构体变量的String()方法输出</strong></p><h4 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h4><p>1、调用方式不一样</p><ul><li>函数的调用方式：函数名（实参列表）</li><li>方法的调用方式：绑定类型变量.方法名（实参列表）</li></ul><p>2、对于普通函数，接收者为值类型时，不能将指针类型数据直接传递，反之亦然</p><p>3、对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反之亦然<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">       Name <span class="keyword">string</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">       p.Name = <span class="string">"jack"</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//jack</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">test01</span><span class="params">()</span></span> &#123;</span><br><span class="line">       p.Name = <span class="string">"marry"</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//marry</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">var</span> p Person </span><br><span class="line">       p.Name = <span class="string">"tom"</span></span><br><span class="line">       </span><br><span class="line">       p.test() <span class="comment">//ok</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//tom</span></span><br><span class="line">       </span><br><span class="line">       (&amp;p).test()  <span class="comment">//用p的地址（指针）调也可以，但仍然是值拷贝，只是形式上看是引用拷贝，但是接受的地方“func (p Person)”是传值，所以底层会处理为“p.test()”，只有接受的地方为传地址（如 func (p *Person)），才是引用传递</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name) <span class="comment">//tom</span></span><br><span class="line">       </span><br><span class="line">       (&amp;p).test01()<span class="comment">//ok</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name)<span class="comment">//marry</span></span><br><span class="line">       </span><br><span class="line">       p.test01()<span class="comment">//ok，等价于(&amp;p).test01()，底层处理，形式上传值，实际传地址，因为接受的地方为传地址（如 func (p *Person)）</span></span><br><span class="line">       fmt.Println(<span class="string">"tes=t"</span>,p.Name)<span class="comment">//marry </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p><strong>针对第3条总结</strong>：<strong>重点重点</strong><br>不管调用的形式如何，真正决定是值拷贝还是地址拷贝，看定义这个方法时跟哪个类型绑定，若跟指针（如 p *Person）绑定则为地址拷贝，若跟值类型（如 p Person）绑定则为值拷贝</p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>1、GO的结构体没有<strong>构造函数</strong>，通常使用工厂模式来解决</p><ul><li>使用工厂模式实现跨包创建结构体实例</li></ul><p>1）model包下有结构体Student<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model </span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> student <span class="keyword">struct</span>&#123;</span><br><span class="line"> <span class="comment">//这里结构体定义为小写student，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Score <span class="keyword">float64</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//使用工厂模式</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>,score <span class="keyword">float64</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">          Name : name,</span><br><span class="line">          Score : score,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>2）main包下使用工厂模式创建结构体student实例<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"factory/model"</span></span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用工厂模式创建student实例</span></span><br><span class="line">    <span class="keyword">var</span> stu = model.NewStudent(<span class="string">"tom"</span>,<span class="number">88.8</span>)<span class="comment">//返回值为一个指针</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu) <span class="comment">//输出&amp;&#123;tom 88.8&#125;</span></span><br><span class="line">   fmt.Println(*stu) <span class="comment">//输出&#123;tom 88.8&#125;</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu.Name) <span class="comment">//等价于(*stu).Name 输出tom</span></span><br><span class="line">   fmt.Println(stu.Score) <span class="comment">//等价于(*stu).Score 输出88.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果结构体中的字段也是小写，只能在定义结构体的包中使用，其他包不可访问，同理可以为结构体绑定一个公有方法，用于返回字段<br>1）model包下有结构体Student<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model </span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> student <span class="keyword">struct</span>&#123;</span><br><span class="line"> <span class="comment">//这里结构体定义为小写student，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        score <span class="keyword">float64</span></span><br><span class="line"> <span class="comment">//这里字段score定义为小写，只能在当前包内使用，其他包不可访问</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//使用工厂模式</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>,score <span class="keyword">float64</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">          Name : name,</span><br><span class="line">          score : score,<span class="comment">//该包内可以访问小写字段，其他包不可以</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//GetScore方法绑定结构体，返回字段score</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">GetScore</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.score</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>2）main包下使用工厂模式创建结构体student实例<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"factory/model"</span></span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用工厂模式创建student实例</span></span><br><span class="line">    <span class="keyword">var</span> stu = model.NewStudent(<span class="string">"tom"</span>,<span class="number">88.8</span>)<span class="comment">//返回值为一个指针</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu) <span class="comment">//输出&amp;&#123;tom 88.8&#125;</span></span><br><span class="line">   fmt.Println(*stu) <span class="comment">//输出&#123;tom 88.8&#125;</span></span><br><span class="line">   </span><br><span class="line">   fmt.Println(stu.Name) <span class="comment">//等价于(*stu).Name 输出tom</span></span><br><span class="line">   fmt.Println(stu.GetScore()) <span class="comment">//输出88.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="面向对象编程三大特性"><a href="#面向对象编程三大特性" class="headerlink" title="面向对象编程三大特性"></a>面向对象编程三大特性</h3><p>面向对象编程三大特性：<strong>封装、继承、多态</strong>。</p><h4 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h4><p>1、封装：把<strong>抽象出来的字段和对字段的操作封装在一起</strong>，数据就被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作</p><p>2、封装的优点</p><ul><li>隐藏实现的细节</li><li>提供方法可以对数据进行验证、保证安全合理</li></ul><p>3、如何体现封装</p><ul><li>对结构体中的属性进行封装</li><li>通过方法、包实现封装</li></ul><p>4、封装的实现<br>参考上一个笔记，工厂模式（将结构体、属性定义为包私有，通过公有方法访问）</p><h4 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h4><p>继承可以<strong>解决代码复用</strong>，提高扩展性、可维护性<br><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/oop1.jpg" alt="oop1"><br>GO使用在一个结构体中<strong>嵌套匿名结构体</strong>的方式来实现继承<br>案例：<br>1、抽取共有字段和方法，创建一个结构体Student<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">      Name <span class="keyword">string</span></span><br><span class="line">      Age <span class="keyword">int</span></span><br><span class="line">      Score <span class="keyword">float64</span>     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//共有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">ShowInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"学生名=%v年龄=%v 成绩=%v           \n"</span>,stu.Name,stu.Age,stu.Score)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">SetScore</span><span class="params">(score <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">       stu.Score = score</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>2、创建结构体Pupil<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pupil <span class="keyword">struct</span>&#123;</span><br><span class="line">      Student    <span class="comment">//嵌入Student匿名结构体</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Pupil特有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(p *Pupil)</span> <span class="title">testing</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"小学生正在考试中"</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>3、创建结构体Graduate<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Graduate <span class="keyword">struct</span>&#123;</span><br><span class="line">      Student    <span class="comment">//嵌入Student匿名结构体</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Graduate特有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(g *Graduate)</span> <span class="title">testing</span><span class="params">()</span></span>&#123;</span><br><span class="line">       fmt.Printf(<span class="string">"大学生正在考试中"</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>4、main创建实例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//当我们对结构体嵌入了匿名结构体后，使用方法发生了变化</span></span><br><span class="line">     <span class="comment">//创建一个Pupil实例</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Student.Name = <span class="string">"tom"</span></span><br><span class="line">     pupil.Student.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.Student.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//创建一个Graduate实例</span></span><br><span class="line">     graduate := &amp;Graduate&#123;&#125;</span><br><span class="line">     graduate.Student.Name = <span class="string">"marry"</span></span><br><span class="line">     graduate.Student.Age = <span class="number">8</span></span><br><span class="line">     graduate.testing()</span><br><span class="line">     graduate.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     graduate.Student.ShowInfo()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h5 id="继承细节"><a href="#继承细节" class="headerlink" title="继承细节"></a>继承细节</h5><p>1、结构体可以使用嵌套匿名结构体的<strong>所有字段和方法</strong>，即：首字母大写和小写的字段和方法都可以使用</p><p>2、访问匿名结构体字段可以简化<br>在上述案例中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//当我们对结构体嵌入了匿名结构体后，使用方法发生了变化</span></span><br><span class="line">     <span class="comment">//创建一个Pupil实例</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Student.Name = <span class="string">"tom"</span></span><br><span class="line">     pupil.Student.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.Student.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.Student.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//创建Pupil实例，访问Pupil结构体中的匿名结构体Student的字段和方法可以简化为</span></span><br><span class="line">     pupil := &amp;Pupil&#123;&#125;</span><br><span class="line">     pupil.Name = <span class="string">"tom"</span></span><br><span class="line">     pupi.Age = <span class="number">8</span></span><br><span class="line">     pupil.testing()</span><br><span class="line">     pupil.SetScore(<span class="number">70</span>)</span><br><span class="line">     pupil.ShowInfo()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//pupil.Student.Name = "tom" 等价于pupil.Name = "tom"，</span></span><br><span class="line">    <span class="comment">// pupil.Name 先去pupil找Name字段，如果没有，再去Pupil结构体中的匿名结构体Student找字段Name</span></span><br><span class="line">    <span class="comment">//如果找到则访问，否则报错</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>3、当结构体和匿名结构体有相同的字段或方法时，编译器采用<strong>就近访问原则</strong>访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体来区分<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">SayOk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"A SayOK"</span>,a.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"A hello"</span>,a.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">    A</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SayOk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"b SayOK"</span>,b.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b B</span><br><span class="line">    </span><br><span class="line">    b.Name = <span class="string">"jack"</span><span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//去结构体B中找字段Name，找到并赋值jack，则b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.SayOK() <span class="comment">//b SayOK jack</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法SayOK ，找到并执行fmt.Println("b SayOK",b.Name)，这里b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.hello() <span class="comment">//A hello ""空串</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法hello，没有找到，再去匿名结构体A中找，找到并执行fmt.Println("A hello"，a.Name)，前面的语句并没有为a.Name赋值，则为默认值空串，a.Name就近等于空串</span></span><br><span class="line">    </span><br><span class="line">    b.A.Name = <span class="string">"tom"</span><span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//去结构体B的匿名结构体A中找字段Name，找到并赋值tom，则b.Name= "tom"</span></span><br><span class="line">    </span><br><span class="line">    b.SayOK() <span class="comment">//b SayOK jack</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法SayOK ，找到并执行fmt.Println("b SayOK",b.Name)，这里b.Name= "jack"</span></span><br><span class="line">    </span><br><span class="line">    b.A.SayOK() <span class="comment">//A SayOK tom</span></span><br><span class="line">    <span class="comment">//去结构体B的匿名结构体A中找方法SayOK ，找到并执行fmt.Println("A hello",a.Name)，这里a.Name= "tom"</span></span><br><span class="line">    </span><br><span class="line">    b.hello() <span class="comment">//A hello tom</span></span><br><span class="line">    <span class="comment">//去结构体B中找方法hello，没有找到，再去匿名结构体A中找，找到并执行fmt.Println("A hello"，a.Name)，前面的语句为a.Name赋值tom，则a.Name就近等于tom</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、当结构体嵌入两个（或多个）匿名结构体，如<strong>两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的字段和方法）</strong>，在访问时，就必须要明确指定匿名结构体的名字，否则编译报错</p><p>5、如果一个struct嵌套了一个有名字的结构体，这种模式就是<strong>组合</strong>，如果是组合关系，那么在访问组合的结构体的字段和方法时，就必须带上结构体的名字，<strong>不能简写</strong>。<br>Go中层级关系明确，如果是组合关系，例：一个结构体A嵌套了一个有名结构体B，B的名字为b,B有字段Name，现创建A的实例a,访问字段Name时，只能a.b.Name，不能a.Name，编译器会报错。看到a.Name时，编译器会去A中找字段Name，没有就立马报错（嵌套匿名结构体时会继续在匿名结构体中找）</p><p>6、嵌套匿名结构体后，也可以创建结构体变量时，直接指定各个匿名结构体字段的值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pupil := &amp;Pupil&#123;Student&#123;<span class="string">"tom"</span>，<span class="number">15</span>，<span class="number">78.5</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">pupil := &amp;Pupil&#123;</span><br><span class="line">    Student&#123;</span><br><span class="line">        Name:<span class="string">"tom"</span>，</span><br><span class="line">        Age:<span class="number">15</span>，</span><br><span class="line">        Score:<span class="number">78.5</span>，</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>7、在结构体中嵌入匿名结构体时，也可以直接嵌入匿名结构体的指针，这样效率更高</p><p>8、在结构体中嵌入匿名结构体时，也可以直接嵌入匿名基本数据类型。<br>如嵌入匿名int，访问时直接通过 “外层结构体实例名.int = 20”这种形式。但是不能同时侵入两个同样的匿名基本数据类型，因为无法区分，如嵌入两个匿名int，这是不允许的。</p><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>一个struct嵌套了多个匿名结构体，那么该结构体可以直接访问所有嵌套的匿名结构体的字段和方法，从而实现多重继承<br>1、当结构体嵌入两个（或多个）匿名结构体，如<strong>两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的字段和方法）</strong>，在访问时，就必须要明确指定匿名结构体的名字，否则编译报错</p><p>2、为了代码简洁性，建议尽量不适用多重继承</p><h4 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a>3、多态</h4><h5 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、变量（实例）具有多种形态，在GO中，多态特征是通过接口实现的。可以按照统一的接口来调用不同的实现，这时<strong>接口变量就呈现不同的形态</strong>。<br>案例说明：<br>1、定义一个接口Usb<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span>&#123;</span><br><span class="line">    <span class="comment">//声明两个没有实现的方法</span></span><br><span class="line">    Start()</span><br><span class="line">    Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、定义一个结构体Phone<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">type</span> Stu <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让Phone实现接口Usb的所有方法，即实现了接口Usb</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机开始工作。。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"手机停止工作。。。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、再定义一个结构体Camera<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> Stu Camera&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//让Camera实现接口Usb的所有方法，即实现了接口Usb</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">     fmt.Println(<span class="string">"相机开始工作。。。"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">     fmt.Println(<span class="string">"相机停止工作。。。"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>4、再定义一个结构体Computer<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu Computer&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个方法Working，接收一个Usb接口类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">Working</span><span class="params">(usb Usb)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过usb接口变量来调用Start和Stop方法</span></span><br><span class="line">    usb.Start()</span><br><span class="line">    usb.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5、在main函数中使用接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建结构体Computer变量</span></span><br><span class="line">    computer := Computer&#123;&#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//创建结构体Phone变量</span></span><br><span class="line">    phone := Phone&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建结构体Camera变量</span></span><br><span class="line">    camera := Camera&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关键点</span></span><br><span class="line">    computer.Working(phone)</span><br><span class="line">    <span class="comment">//手机开始工作。。。</span></span><br><span class="line">    <span class="comment">//手机停止工作。。。</span></span><br><span class="line">    </span><br><span class="line">    computer.Working(camera)</span><br><span class="line">     <span class="comment">//相机开始工作。。。</span></span><br><span class="line">    <span class="comment">//相机停止工作。。。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结构体Computer的Working函数接收的是一个Usb接口变量，因为结构体Phone和Camera都实现了这个接口，所以可以传入，并且当传Phone时，可以动态的调用phone.Start()和phone.Stop()，传入camera时同理。Usb接口变量体现出多态。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2、接口体现多态的特征"><a href="#2、接口体现多态的特征" class="headerlink" title="2、接口体现多态的特征"></a>2、接口体现多态的特征</h5><p>1、多态参数<br>在前面的Usb接口案例中，Computer的Working函数接收的是一个Usb接口变量，Phone和Camera都实现了这个接口，所以既可以接收Phone变量，又可以接收Camera变量，体现出多态。</p><p>2、多态数组<br>在上述Usb案例中，我们可以定义一个Usb接口数组<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个Usb接口数组，可以存放Phone和Camera的结构体变量</span></span><br><span class="line">    <span class="keyword">var</span> usbArr [<span class="number">3</span>]Usb</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;nil&gt;&lt;nil&gt;&lt;nil&gt;]</span></span><br><span class="line">    </span><br><span class="line">    usbArr[<span class="number">0</span>] = Phone&#123;&#125;</span><br><span class="line">    usbArr[<span class="number">1</span>] = Phone&#123;&#125;</span><br><span class="line">    usbArr[<span class="number">2</span>] = Camera&#123;&#125;</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;&gt;&lt;&gt;&lt;&gt;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上述的案例中的结构体都没有字段，这里都加上Name字段，然后创建结构体变量</span></span><br><span class="line">    usbArr[<span class="number">0</span>] = Phone&#123;<span class="string">"华为"</span>&#125;</span><br><span class="line">    usbArr[<span class="number">1</span>] = Phone&#123;<span class="string">"小米"</span>&#125;</span><br><span class="line">    usbArr[<span class="number">2</span>] = Camera&#123;<span class="string">"索尼"</span>&#125;</span><br><span class="line">    fmt.Println(usbArr)<span class="comment">//输出[&lt;华为&gt;&lt;小米&gt;&lt;索尼&gt;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Usb接口数组usbArr，可以存放Phone和Camera的结构体变量，体现出多态数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><h5 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、<strong>类型断言</strong>，由于<strong>接口</strong>是一般类型，<strong>不知道具体类型</strong>。如果要转成具体类型，就需要使用类型断言。</p><h5 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h5><p>1、定义结构体Point<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">    y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、main函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; <span class="comment">//定义一个空接口类型变量a</span></span><br><span class="line">    <span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment">//定义Point类型变量point</span></span><br><span class="line">    </span><br><span class="line">    a = point <span class="comment">//ok，</span></span><br><span class="line">    <span class="comment">//将Point类型变量point赋给一个空接口类型变量a，</span></span><br><span class="line">    <span class="comment">//使空接口类型变量a指向Point类型的变量point</span></span><br><span class="line">    <span class="comment">//空接口变量可以接收任何数据类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b Point</span><br><span class="line">    <span class="comment">//b = a不可以，不可以将一个空接口类型变量a赋给其他数据类型</span></span><br><span class="line">    <span class="comment">//b = a.(Point)可以，a.(Point)称为类型断言</span></span><br><span class="line">    </span><br><span class="line">    b,ok = a.(Point) </span><br><span class="line">    <span class="comment">//判断空接口类型变量a是指向Point类型的变量</span></span><br><span class="line">    <span class="comment">//如果是就转成Point类型的变量并赋给b，否则报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类型断言检查，不要让断言失败直接panic终止程序</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(b)<span class="comment">//输出&lt;1，2&gt;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         fmt.Println(<span class="string">"转换失败"</span>)</span><br><span class="line">     &#125;       </span><br><span class="line">     </span><br><span class="line">     fmt.Println(<span class="string">"代码继续执行"</span>)<span class="comment">//类型断言检查，断言失败不会panic终止程序，这里还会执行到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>重点</strong>：</p><ul><li>在进行类型断言时，如果类型不匹配，就会报panic。因此进行类型断言时，要确保原来的空接口指向的就是要断言的类型</li><li>例：首先“a = point ”使空接口类型变量a指向Point类型的变量point，才可以类型断言“b = a.(Point) ”</li></ul><h5 id="3、类型断言最佳案例"><a href="#3、类型断言最佳案例" class="headerlink" title="3、类型断言最佳案例"></a>3、类型断言最佳案例</h5><p><img src="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/assert1.png" alt="assert1"></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h5 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>1、interface类型可以定义一组方法但是不需要实现</p><p>2、interface中<strong>不能包含任何变量</strong></p><h5 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    method1(参数列表)返回值列表</span><br><span class="line">    method2(参数列表)返回值列表</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> 自定义类型名 <span class="keyword">struct</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s 自定义类型名)</span> <span class="title">method1</span><span class="params">(参数列表)</span>返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">//方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s 自定义类型名)</span> <span class="title">method2</span><span class="params">(参数列表)</span>返回值列表</span>&#123;</span><br><span class="line">    <span class="comment">//方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意：<br>1）接口中的所有方法都没有方法体，即接口的方法都是没有实现的方法。体现<strong>多态</strong>、<strong>高内聚低耦合</strong></p><p>2）Go中的接口，不需要显示实现。只要一个结构体变量（实例）含有接口类型中的所有方法，则称这个结构体变量实现了这个接口（没有类似implement这样的关键字，GO是基于方法实现的多态，而不需显示指出接口名称）。</p><p>3）如果由接口a和接口b有完全一样的方法列表，那么有实例c如果实现了接口a，同时也就实现了接口b，即：同时实现两个或两个以上的接口（在其他语言中是做不到的，例如Java，必须显示implement实现a，再显示implement实现b）</p><p>4）特别指出，需要<strong>实现接口所有的方法</strong></p><h5 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h5><p>1、<strong>接口本身不能创建实例</strong>，但是可以指向一个实现了该接口的自定义类型（如struct）的变量（实例）</p><p>2、接口中的所有方法都没有方法体，即接口的方法都是没有实现的方法</p><p>3、Go中，一个自定义类型需要将某个接口的<strong>所有方法都实现</strong>，才能称这个自定义类型实现了该接口</p><p>4、只要是自定义类型，都可以实现接口，不仅仅是结构体类型。如自定义一个int类型“type integer int”，这个自定义的类型integer也可以实现接口</p><p>5、一个自定义类型可以<strong>实现多个</strong>接口。（只要把多个接口的方法都实现就可以）</p><p>6、Go接口中不能有任何变量（常量也不可以）</p><p>7、一个接口（如接口A）可以<strong>继承多个</strong>别的接口（如接口B和C），这时如果要实现接口A，也必须要将接口B和C的方法全部实现，但是<strong>接口B和C中不能有完全相同的方法</strong>，编译器会报错重复定义，因为无法区分。</p><p>8、interface类型默认是一个<strong>指针</strong>（<strong>引用类型</strong>），如果没有对interface初始化就使用，那么会输出nil</p><p>9、空接口interface{}，没有任何方法，所以<strong>所有类型都默认实现了空接口</strong>（即空接口可以接收任何数据类型，可以把任何数据类型变量赋给空接口）。</p><p>10、<strong>空接口也是一种数据类型</strong><br>例：可以声明一个空接口类型变量<br>“vat t interface{}”</p><p>该空接口类型变量可以接收任何数据类型的值<br>“t = student”//接收一个Student类型的变量student<br>“t = 8.8”//接收一个float类型的值8.8</p><h5 id="4、接口使用案例"><a href="#4、接口使用案例" class="headerlink" title="4、接口使用案例"></a>4、接口使用案例</h5><p>1、定义一个接口AInteger<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AInteger <span class="keyword">interface</span>&#123;</span><br><span class="line">    Test01()</span><br><span class="line">    Test02()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、再定义一个接口BInteger<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AInteger <span class="keyword">interface</span>&#123;</span><br><span class="line">    Test01()</span><br><span class="line">    Test03()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、定义一个结构体Stu<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test01</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test02</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法Test03</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(stu Stu)</span> <span class="title">Test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、在main函数中使用接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stu := Stu&#123;&#125;<span class="comment">//创建一个Stu实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> a AInteger =stu </span><br><span class="line">    <span class="comment">//ok，将实例stu赋给接口AInteger的变量a，因为stu实现了接口AInteger中的所有方法（ Test01和Test02）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b BInteger =stu</span><br><span class="line">    <span class="comment">//ok，将实例stu赋给接口BInteger的变量b，因为stu实现了接口BInteger中的所有方法（ Test01和Test03）</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">"ok"</span>,a,b)<span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5、接口与继承比较"><a href="#5、接口与继承比较" class="headerlink" title="5、接口与继承比较"></a>5、接口与继承比较</h5><p>1、当B结构体继承了A结构体，那么B结构体就自动的继承了A结构体的字段和方法，并且可以直接使用</p><p>2、B结构体需要扩展功能，同时不希望破坏继承关系，可以去实现某个接口，因此，可以认为：实现<strong>接口是对继承机制的一种补充</strong></p><p>3、接口与继承解决的问题不同</p><ul><li>继承的价值：解决代码的<strong>复用性</strong>和<strong>可维护性</strong></li><li>接口的价值：<strong>设计</strong>，设计好各种规范（方法），让其他自定义类型去实现这些方法来增强功能</li></ul><p>4、接口比继承更加灵活。<strong>继承</strong>是满足 <strong>is - a</strong> 的关系，<strong>接口</strong>只需要满足 <strong>like - a</strong> 的关系</p><p>5、接口在一定程度上实现代码解耦，尤其在GO中更加松散</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象-结构体&quot;&gt;&lt;a href=&quot;#面向对象-结构体&quot; class=&quot;headerlink&quot; title=&quot;面向对象-结构体&quot;&gt;&lt;/a&gt;面向对象-结构体&lt;/h3&gt;&lt;p&gt;1、GO支持面向对象编程（OOP），但不是纯粹的面向对象编程语言，更准确地说是&lt;strong
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>go:错误处理机制、数组、切片、map</title>
    <link href="http://yoursite.com/2020/06/11/go-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E3%80%81map/"/>
    <id>http://yoursite.com/2020/06/11/go-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E3%80%81map/</id>
    <published>2020-06-11T07:29:33.000Z</published>
    <updated>2020-06-11T07:34:19.349Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、go错误处理机制"><a href="#1、go错误处理机制" class="headerlink" title="1、go错误处理机制"></a>1、go错误处理机制</h3><p>1、Go引入处理方式：<strong>defer、panic、recover</strong>，通常三者结合使用<br>2、这几个异常使用场景简单描述：Go中可以抛出一个panic异常，然后在defer中通过recover捕获这个异常，然后正常处理<br>示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num1 := <span class="number">10</span></span><br><span class="line">    num2 := <span class="number">0</span></span><br><span class="line">    res := num1/num2  <span class="comment">//会报错，10/0错误，0不可以作为除数</span></span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     test()<span class="comment">//test函数报错，下面的代码不会执行</span></span><br><span class="line">     fmt.Println(<span class="string">"main下面的代码"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异常处理：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用defer+recover结合捕获并处理异常</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        err :=<span class="built_in">recover</span>()<span class="comment">//recover()是一个内置函数，可以捕获异常</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;<span class="comment">//如果捕获到异常</span></span><br><span class="line">             fmt.Println(<span class="string">"err="</span>,err)</span><br><span class="line">             <span class="comment">//这里可以把错误信息发送给管理员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()<span class="comment">//这里调用defer后的匿名函数</span></span><br><span class="line">    num1 := <span class="number">10</span></span><br><span class="line">    num2 := <span class="number">0</span></span><br><span class="line">    res := num1/num2  <span class="comment">//会报错，10/0错误，0不可以作为除数</span></span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test()<span class="comment">//defer+recover结合捕获并处理异常后，使得下面的代码可以执行</span></span><br><span class="line">     fmt.Println(<span class="string">"main下面的代码"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h5><p>1、Go支持自定义错误，使用<strong>errors.New</strong>和<strong>panic</strong>内置函数<br>1）errors.New（“错误说明”），返回一个<strong>error</strong>类型的值，表示一个错误<br>2）panic内置函数，接收一个空接口interface{}类型的值（即任何值）作为参数。可以接收error类型的变量，输出错误信息，并退出程序。<br>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数读取配置文件init.conf的信息</span></span><br><span class="line"><span class="comment">//如果文件名传入不正确，返回一个自定义错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> name == <span class="string">"init.conf"</span>&#123;<span class="comment">//如果捕获到异常</span></span><br><span class="line">             <span class="comment">//读取...</span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//返回一个自定义错误</span></span><br><span class="line">             <span class="keyword">return</span> errors.New(<span class="string">"读取文件错误"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := readConf(init.conf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">             <span class="comment">//如果发生错误，输出错误，并终止程序</span></span><br><span class="line">             <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">     fmt.Println(<span class="string">"test后面的代码"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     test()<span class="comment">//test函数如果发生读取文件错误，panic会终止程序，下面的代码不会执行</span></span><br><span class="line">     fmt.Println(<span class="string">"main下面的代码"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2、数组"><a href="#2、数组" class="headerlink" title="2、数组"></a>2、数组</h3><p>1、数组可以存放多个同一类型数据。数组也是一种数据类型，Go中，数组是<strong>值类型</strong><br>2、四种初始化数组方式<br>如果定义时不赋值，则会被系统赋默认值</p><ul><li><p>1）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>2）var arr时不指定类型，类型推导</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>3）用“…”代替数组大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>4）指定元素值的下标</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>:<span class="string">"tom"</span>,<span class="number">2</span>:<span class="string">"jack"</span>,<span class="number">0</span>:<span class="string">"marry"</span>&#125;<span class="comment">//顺序可乱序，输出按下标输出</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="3、数组遍历"><a href="#3、数组遍历" class="headerlink" title="3、数组遍历"></a>3、数组遍历</h5><p>1、常规for循环遍历<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr);i++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"arr[%d]=%v\n]"</span>,i,arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、for-range结构遍历<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value := <span class="keyword">range</span> arr&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"i=%v,v=%v\n"</span>,index,value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="4、数组使用细节"><a href="#4、数组使用细节" class="headerlink" title="4、数组使用细节"></a>4、数组使用细节</h5><p>1、var arr []int，这时arr是一个slice切片<br>2、Go数组属于值类型，默认情况下是值传递，进行值拷贝，数组间不会互相影响<br>3、如想在其他函数中修改原来的数组，可以使用引用传递（指针方式，传数组地址）<br>4、<strong>长度是数组类型的一部分</strong>，在传递函数参数时，需要考虑数组长度<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">     fmt.Println(<span class="string">"modify的arr"</span>,arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr =[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    modify(arr)<span class="comment">//这里编译错误，因为认为main函数中的[3]int与modify函数中的形参[]int不是同一类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、切片"><a href="#3、切片" class="headerlink" title="3、切片"></a>3、切片</h3><p>1、切片是数组的一个引用，因此数组时引用类型，传递方式是引用传递<br>2、切片的长度可以变化，因此切片是一个动态数组<br>3、切片的使用和数组类似，遍历、访问切片的元素和求切片长度len（slice）都一样<br>3、切片定义的基本语法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span><span class="comment">//与数组不同的是，【】中不需要填入大小或“...”</span></span><br></pre></td></tr></table></figure></p><p>4、示例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个数组</span></span><br><span class="line"><span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">66</span>,<span class="number">99</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// intArr[1:3]表示切片slice从intArr这个数组的下标为1的元素开始引用，到下标为3的元素，但不包含标为3的元素</span></span><br><span class="line">slice := intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(<span class="string">"slice的元素："</span>，slice)              <span class="comment">//[22,33]</span></span><br><span class="line">fmt.Println(<span class="string">"slice的元素个数："</span>，<span class="built_in">len</span>(slice))   <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="string">"slice的容量："</span>，<span class="built_in">cap</span>(slice))        <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片的容量可以动态变化</span></span><br></pre></td></tr></table></figure></p><h5 id="1、切片在内存中的布局"><a href="#1、切片在内存中的布局" class="headerlink" title="1、切片在内存中的布局"></a>1、切片在内存中的布局</h5><p><img src="/2020/06/11/go-错误处理机制、数组、切片、map/slice1.jpg" alt="slice1"></p><p>由上图可以看出<br>1、slice是一个引用类型<br>2、slice从底层来说是一个结构体是struct，由三部分构成<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">    ptr *[<span class="number">2</span>]intArr  <span class="comment">//指向切片第一个元素的地址</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span>         <span class="comment">//长度</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span>         <span class="comment">//容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于slice是引用类型，所以通过slice去修改引用到的intArr数组中的值，intArr本身的值也会发生改变</p><h5 id="2、切片使用的三种方式"><a href="#2、切片使用的三种方式" class="headerlink" title="2、切片使用的三种方式"></a>2、切片使用的三种方式</h5><p>1、定义一个切片，然后让切片去引用一个已经创建好的数组，如上所示<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个数组</span></span><br><span class="line"><span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">66</span>,<span class="number">99</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// intArr[1:3]表示切片slice从intArr这个数组的下标为1的元素开始引用，到下标为3的元素，但不包含标为3的元素</span></span><br><span class="line">slice := intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(<span class="string">"slice的元素："</span>，slice)              <span class="comment">//[22,33]</span></span><br><span class="line">fmt.Println(<span class="string">"slice的元素个数："</span>，<span class="built_in">len</span>(slice))   <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="string">"slice的容量："</span>，<span class="built_in">cap</span>(slice))        <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片的容量可以动态变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//几种引用数组元素写法</span></span><br><span class="line">slice1 := intArr[:<span class="number">3</span>] <span class="comment">//等价于intArr[0:3]  1,22,33</span></span><br><span class="line">slice2 := intArr[<span class="number">1</span>:] <span class="comment">//等价于intArr[1:len(intArr)]  22,33,66,99</span></span><br><span class="line">slice1 := intArr[:] <span class="comment">//等价于intArr[0:len(intArr)]  1,22,33,66,99</span></span><br></pre></td></tr></table></figure></p><p>2、通过make来创建切片<br>基本语法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">//cap可选参数，cap&gt;=len</span></span><br></pre></td></tr></table></figure></p><p>使用案例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">float64</span></span><br><span class="line"><span class="comment">//对于切片，必须make后使用</span></span><br><span class="line">fmt.Println(<span class="string">"slice="</span>，slice)<span class="comment">//输出[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//make后</span></span><br><span class="line">slice = <span class="built_in">make</span>([]<span class="keyword">float64</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="string">"slice="</span>，slice)<span class="comment">//输出[0,0,0,0,0],默认值为0</span></span><br></pre></td></tr></table></figure></p><p>3、定义切片时直接指定具体数组<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure></p><p>注意：</p><ul><li>方式1创建切片的方式是直接引用一个事先定义好的数组，程序员对这个数组可见</li><li>方式2通过make方式创建切片，<strong>make也会创建一个数组，由切片在底层进行维护，程序员不可见</strong></li><li><strong>切片定义完之后，还不能直接使用</strong>，这时是一个空切片【】，需要引用到一个数组或者make一个空间来使用</li><li>切片可以再切片</li></ul><h5 id="3、切片的遍历"><a href="#3、切片的遍历" class="headerlink" title="3、切片的遍历"></a>3、切片的遍历</h5><p>1、for循环<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//20,20,30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;<span class="built_in">len</span>(slice);i++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"slice[%v]=%v "</span>,i,slice[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、for-range<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//20,20,30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> slice&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"i=%v v=%v\n"</span>,i,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="4、切片的使用注意事项"><a href="#4、切片的使用注意事项" class="headerlink" title="4、切片的使用注意事项"></a>4、切片的使用注意事项</h5><p>1、<strong>切片定义完之后，还不能直接使用</strong>，这时是一个空切片【】，需要引用到一个数组或者make一个空间来使用</p><p>2、切片可以再切片</p><p>3、用<strong>append</strong>内置函数，可以对切片动态追加<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>&#125;</span><br><span class="line"><span class="comment">//通过append直接给切片slice追加具体的值，数据类型需匹配</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">400</span>)</span><br><span class="line"><span class="comment">//append操作后，会生成一个新数组，需要将append后的值赋给slice，保证slice引用到append操作后的新数组</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">500</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">600</span>,<span class="number">700</span>,<span class="number">800</span>)<span class="comment">//一次追加多个</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice,slice...)<span class="comment">//直接追加一个切片</span></span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure></p><ul><li>append操作的本质就是对数组扩容</li><li>go底层会创建一个新的数组newArr，将slice原来包含的元素拷贝到新数组newArr中，slice再重新引用数组newArr</li><li>数组newArr在底层维护，程序员不可见</li></ul><p>4、用<strong>copy</strong>内置函数，可以对切片拷贝<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(slice)<span class="comment">//输出[0,0,0,0,0,0,0,0,0,0]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(slice,a)<span class="comment">//将切片a的值拷贝到slice中</span></span><br><span class="line">fmt.Println(slice)<span class="comment">//输出【1，2，3，4，5，0，0，0，0，0】</span></span><br></pre></td></tr></table></figure></p><ul><li>copy操作需要两个参数都是切片，只能从切片拷贝到切片</li><li>上面代码中，切片a与slice的数据空间是独立的，互不影响</li><li>将切片a拷贝到slice，slice的长度小于a也是正确的</li><li>切片是引用类型，在传递时遵守引用传递机制</li></ul><h5 id="5、slice与string"><a href="#5、slice与string" class="headerlink" title="5、slice与string"></a>5、slice与string</h5><p>1、string底层是一个byte数组，因此string也可以进行切片处理操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello world"</span></span><br><span class="line"><span class="comment">//使用切片获取到world</span></span><br><span class="line">slice := str[<span class="number">6</span>:]</span><br><span class="line">fmt.Println(slice)<span class="comment">//输出world</span></span><br></pre></td></tr></table></figure></p><p>2、string在内存中的形式，以串“abcd”为例<br><img src="/2020/06/11/go-错误处理机制、数组、切片、map/slice2.jpg" alt="slice2"></p><p><em>string底层由两部分组成，指向一个字节数组的指针</em>[4]byte和长度len<br>字节数组中真正存放串的内容</p><p>3、string是不可变的，即不能通过str[0]=’z’的方式来修改字符(编译会报错)</p><p>4、如果需要修改字符串，可以先将string-&gt;[]byte（或者 []rune）-&gt;修改-&gt;重写转成string<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    str := <span class="string">"hello world"</span></span><br><span class="line">   <span class="comment">//把‘w’改成h</span></span><br><span class="line">   <span class="comment">//首先转成byte切片，可以处理英文和数字，中文用[]rune</span></span><br><span class="line">   <span class="comment">//因为[]byte按字节来处理，而一个汉字占3个字节，因此会出现乱码，[]rune按字符处理，兼容汉字</span></span><br><span class="line">   slice := []<span class="keyword">byte</span>(str)</span><br><span class="line">   slice[<span class="number">6</span>]=<span class="string">'h'</span></span><br><span class="line">   str = <span class="keyword">string</span>(slice)</span><br><span class="line">   fmt.Println(slice)<span class="comment">//输出hello horld</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 4、映射map</span></span><br><span class="line"><span class="string">1、map是key-value数据结构，又称为字段或者关联数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2、声明基本语法</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[keyType]valueType</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* key可以是很多种类型，如：bool，int系列、string、指针、channel，还可以是只包含前面几个类型的接口、结构体、数组，**通常为int、string**</span></span><br><span class="line"><span class="string">* **key不可以是slice、map、function**，因为这几个不能用“==”判断（key通常需要判断key存不存在）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* value的类型通常是string、map、struct</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* key不可重复，value可重复，**key**是**无序的**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* **声明不会分配内存**，初始化需要make分配内存后才能赋值和使用 </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//声明，还未分配内存</span></span><br><span class="line"></span><br><span class="line">a[<span class="string">"no1"</span>]=<span class="string">"宋江"</span>  <span class="comment">//这里会panic恐慌，给一个空map赋值，会报错</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure></p><p>使用map前需要先make，给map分配空间，和数组不一样，数组声明后会默认初始化为零值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//声明，还未分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用map前需要先make，给map分配空间，和数组不一样，数组声明后会默认初始化为零值</span></span><br><span class="line">a=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">10</span>)<span class="comment">//分配10个空间，不写默认为1</span></span><br><span class="line">a[<span class="string">"no1"</span>]=<span class="string">"宋江"</span></span><br><span class="line">a[<span class="string">"no2"</span>]=<span class="string">"吴用"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a)        <span class="comment">//输出 map 【no1:宋江 no2:吴用】</span></span><br></pre></td></tr></table></figure></p><h4 id="1、map的使用方式"><a href="#1、map的使用方式" class="headerlink" title="1、map的使用方式"></a>1、map的使用方式</h4><h5 id="1、声明-gt-make-gt-赋值"><a href="#1、声明-gt-make-gt-赋值" class="headerlink" title="1、声明-&gt;make-&gt;赋值"></a>1、声明-&gt;make-&gt;赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//声明，还未分配内存，这时map==nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用map前需要先make，给map分配空间，和数组不一样，数组声明后会默认初始化为零值</span></span><br><span class="line">a=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">10</span>)<span class="comment">//分配10个空间，不写默认为1</span></span><br><span class="line">a[<span class="string">"no1"</span>]=<span class="string">"宋江"</span></span><br><span class="line">a[<span class="string">"no2"</span>]=<span class="string">"吴用"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a)        <span class="comment">//输出 map 【no1:宋江 no2:吴用】</span></span><br></pre></td></tr></table></figure><h5 id="2、声明同时make-gt-赋值"><a href="#2、声明同时make-gt-赋值" class="headerlink" title="2、声明同时make-&gt;赋值"></a>2、声明同时make-&gt;赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">city[<span class="string">"no1"</span>]=<span class="string">"北京"</span></span><br><span class="line">city[<span class="string">"no2"</span>]=<span class="string">"上海"</span></span><br><span class="line">city[<span class="string">"no3"</span>]=<span class="string">"武汉"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(city)        <span class="comment">//输出 map 【no1:北京 no2:上海 no3:武汉】</span></span><br></pre></td></tr></table></figure><h5 id="3、声明时直接赋值"><a href="#3、声明时直接赋值" class="headerlink" title="3、声明时直接赋值"></a>3、声明时直接赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(city)        <span class="comment">//输出 map 【no1:北京 no2:上海 no3:武汉】</span></span><br></pre></td></tr></table></figure><h4 id="2、map的增删改查（crud）操作"><a href="#2、map的增删改查（crud）操作" class="headerlink" title="2、map的增删改查（crud）操作"></a>2、map的增删改查（crud）操作</h4><h5 id="1、增加和更新"><a href="#1、增加和更新" class="headerlink" title="1、增加和更新"></a>1、增加和更新</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="string">"key"</span>] = value</span><br><span class="line"><span class="comment">//1、如果key之前不存在，就是增加操作</span></span><br><span class="line"><span class="comment">//2、如果key之前存在，就是修改操作，新值覆盖旧值</span></span><br></pre></td></tr></table></figure><h5 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>,<span class="string">"key"</span>)</span><br></pre></td></tr></table></figure><p>1、delete是一个内置函数，如果key存在就删除该key-value，如果不存在，不操作，也不会报错<br>2、如果map为nil也不操作，不报错<br>3、如果我们要删除map所有的key，只能遍历逐个删除，不能一次全删除。或者map = make(map[keyType]valueType)，make一个新的，让原来的成为垃圾，被GC回收</p><h5 id="3、查找"><a href="#3、查找" class="headerlink" title="3、查找"></a>3、查找</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">val,ok := city[<span class="string">"no1"</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"有key:no1，值为：%v"</span>，val)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     fmt.Println(<span class="string">"没有key:no1"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="3、map的遍历"><a href="#3、map的遍历" class="headerlink" title="3、map的遍历"></a>3、map的遍历</h4><p>map遍历只能通过for-range，不能用普通for循环，因为map没有下标，key是无序的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> city &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"k=%v v=%v \n"</span>，k,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、map的长度"><a href="#4、map的长度" class="headerlink" title="4、map的长度"></a>4、map的长度</h4><p>len(map)，统计map中有几对key-value<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"city 有"</span>，<span class="built_in">len</span>（city），“对key-value”)</span><br></pre></td></tr></table></figure></p><h4 id="5、map切片"><a href="#5、map切片" class="headerlink" title="5、map切片"></a>5、map切片</h4><p>切片的数据类型如果是map，则成为<strong>map切片</strong>，这样<strong>map的个数可以动态变化</strong>，map切片是一种切片，切片的每个元素都是一个map.<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个map切片</span></span><br><span class="line"><span class="keyword">var</span> monsters []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片make后才能使用</span></span><br><span class="line">monsters = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)<span class="comment">//len=2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> monsters[<span class="number">0</span>] == <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="comment">//切片的元素是map，map需要先make再使用</span></span><br><span class="line">    monsters[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)<span class="comment">//map有两个key</span></span><br><span class="line">    monsters[<span class="number">0</span>][<span class="string">"name"</span>] = <span class="string">"牛魔王"</span></span><br><span class="line">    monsters[<span class="number">0</span>][<span class="string">"age"</span>] = “<span class="number">500</span>”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> monsters[<span class="number">1</span>] == <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="comment">//切片的元素是map，map需要先make再使用</span></span><br><span class="line">    monsters[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)<span class="comment">//map有两个key</span></span><br><span class="line">    monsters[<span class="number">1</span>][<span class="string">"name"</span>] = <span class="string">"玉兔精"</span></span><br><span class="line">    monsters[<span class="number">1</span>][<span class="string">"age"</span>] = “<span class="number">400</span>”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为一开始定义切片长度为2，如果还要添加元素，用append函数动态增加</span></span><br><span class="line"><span class="comment">//1、定义一个monster信息</span></span><br><span class="line">newMonster := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"name"</span> = <span class="string">"新妖怪：红孩儿"</span>,</span><br><span class="line">    <span class="string">"age"</span> = <span class="string">"200"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、添加到切片中</span></span><br><span class="line">monsters = <span class="built_in">append</span>(monsters,newMonster)</span><br><span class="line"></span><br><span class="line"> fmt.Println(monsters)</span><br></pre></td></tr></table></figure></p><h4 id="6、map排序"><a href="#6、map排序" class="headerlink" title="6、map排序"></a>6、map排序</h4><p>1、GO中没有专门的map排序方法<br>2、map默认是无序的，也不是按照添加顺序存放，每次遍历的输出结果也不一样<br>3、对map排序，可以先将key排序，再根据key值遍历输出<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">map1[<span class="number">10</span>]=<span class="number">130</span></span><br><span class="line">map1[<span class="number">1</span>]=<span class="number">13</span></span><br><span class="line">map1[<span class="number">4</span>]=<span class="number">56</span></span><br><span class="line">map1[<span class="number">8</span>]=<span class="number">90</span></span><br><span class="line">    </span><br><span class="line">fmt.Println(map1)<span class="comment">//这里每次的输出结果顺序可能不一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="comment">//1、先将map的key放到切片中</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> map1&#123;</span><br><span class="line">    keys = <span class="built_in">append</span>(keys,k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、对切片排序</span></span><br><span class="line">sort.Ints(keys)</span><br><span class="line">fmt.Println(keys)<span class="comment">//key递增输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历切片，根据key值遍历输出值</span></span><br><span class="line"><span class="keyword">for</span> _,k  := <span class="keyword">range</span> keys&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"map1[%v]=%v \n"</span>,k,map1[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7、map使用细节"><a href="#7、map使用细节" class="headerlink" title="7、map使用细节"></a>7、map使用细节</h4><p>1、map是引用类型，遵守引用传递机制。<br>2、map容量到达后，想再增加元素，会自动扩容，不会panic，slice会panic<br>3、map的value也经常使用struct类型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、go错误处理机制&quot;&gt;&lt;a href=&quot;#1、go错误处理机制&quot; class=&quot;headerlink&quot; title=&quot;1、go错误处理机制&quot;&gt;&lt;/a&gt;1、go错误处理机制&lt;/h3&gt;&lt;p&gt;1、Go引入处理方式：&lt;strong&gt;defer、panic、recover
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>go:函数</title>
    <link href="http://yoursite.com/2020/06/11/go-%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/06/11/go-%E5%87%BD%E6%95%B0/</id>
    <published>2020-06-11T07:19:21.000Z</published>
    <updated>2020-06-11T08:13:42.277Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、函数"><a href="#1、函数" class="headerlink" title="1、函数"></a>1、函数</h3><h4 id="1、函数调用底层机制"><a href="#1、函数调用底层机制" class="headerlink" title="1、函数调用底层机制"></a>1、函数调用底层机制</h4><p>有如下示例<br>下图中的内存空间划分均为逻辑划分</p><ol><li>从main函数入口开始执行程序<br><img src="/2020/06/11/go-函数/func1.jpg" alt="func1"><br>在内存中会为main函数在栈上开辟一个空间，并为变量n1赋值10</li></ol><p>2、调用函数test()<br><img src="/2020/06/11/go-函数/func2.jpg" alt="func2"><br>逻辑上内存会为函数test()在栈上另外开辟一个空间（逻辑上），用于存放test（）函数中的数据</p><p>3、调用函数test()，并传入参数n1<br><img src="/2020/06/11/go-函数/func3.jpg" alt="func3"><br>test（）函数接受main（）函数传过来的参数n1，<strong>在test栈区中另开辟一个空间存放传过来的参数</strong>，此时，<strong>main栈区和test栈区的n1已经没有关系了（引用类型除外）</strong>，所以test栈区中n1的改变不影响main栈区中的n1</p><p>4、test()函数执行n1=n1+1<br><img src="/2020/06/11/go-函数/func4.jpg" alt="func4"><br>test栈区中n1的改变不影响main栈区中的n1</p><p>5、test()函数执行打印n1语句，终端输出test栈区中的n1<br><img src="/2020/06/11/go-函数/func5.jpg" alt="func5"></p><p>6、test（）函数执行完之后，内存回收test栈区，<strong>test栈区中数据全部被清除</strong>，程序回到main（）函数调用test（）函数的地方<br><img src="/2020/06/11/go-函数/func6.jpg" alt="func6"></p><p>7、main()函数执行打印n1语句，终端输出main栈区中的n1<br><img src="/2020/06/11/go-函数/func7.jpg" alt="func7"></p><p>8、main（）函数执行完之后，内存回收main栈区，<strong>main栈区中数据全部被清除</strong>，程序结束<br><img src="/2020/06/11/go-函数/func8.jpg" alt="func8"></p><p>9、<strong>总结</strong></p><ul><li>在调用一个函数时，会为该函数分配一个新的栈空间，编译器会通过自身的处理让这个新的空间和其他的栈区空间区分开来</li><li>在每个函数对应的栈中，数据空间是独立的，不会混淆</li><li>当一个函数调用（执行）完毕后，程序会销毁这个函数对应的栈空间</li></ul><p>10、注意事项</p><ul><li>Go不支持传统的函数重载</li></ul><ul><li><p>Go中，<strong>函数本身也是一种数据类型</strong>。可以赋值给一个变量，则该变量就是一个函数类型的变量，<strong>通过该变量可以对函数调用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">       <span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a:=getSum   <span class="comment">//把函数getSum赋给变量a</span></span><br><span class="line">    fmt.Println(<span class="string">"a的类型是%T,getSum的类型是%T\n"</span>,a,getSum)</span><br><span class="line">    </span><br><span class="line">    res := a(<span class="number">10</span>,<span class="number">40</span>)<span class="comment">//等价于 res := getSum(10,40)</span></span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>因为函数是一种数据类型，所以在Go中，<strong>函数可以作为形参并调用</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure></li><li><p>Go支持对函数返回值命名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSumAndSub</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>, sub <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">       <span class="comment">///返回值命名sum和sub</span></span><br><span class="line">       sub = n1 - n2</span><br><span class="line">       sum = n1 + n2</span><br><span class="line">       <span class="comment">//为sum和sub赋值，顺序无所谓，可与返回值列表顺序不同</span></span><br><span class="line">       <span class="keyword">return</span>      </span><br><span class="line">       <span class="comment">//等价于return sum , sub ，由于已为返回值命名sum和sub，函数体中已为sum和sub赋值，return时可省略不写返回值，再写上反而显得冗余  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Go支持可变参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//支持0到多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(args... <span class="keyword">int</span>)</span> <span class="title">sum</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//支持1到多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span> , args... <span class="keyword">int</span>)</span> <span class="title">sum</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>args是切片slice，通过args[index]可以访问多个值</p><h4 id="2、init函数"><a href="#2、init函数" class="headerlink" title="2、init函数"></a>2、init函数</h4><p>1、<strong>每一个源文件中都可以包含init函数</strong>，该函数会在main函数执行之前，被Go运行框架调用，即init函数在main函数之前被调用。该函数通常用作初始化工作</p><p>2、如果一个文件同时包含全局变量定义，init函数和main函数，则执行的流程是：<strong>全局变量定义-&gt;init函数-&gt;main函数</strong></p><p>3、如果包含main函数的包里import了其他包，执行流程如下<br><img src="/2020/06/11/go-函数/func9.jpg" alt="func9"></p><h4 id="3、匿名函数"><a href="#3、匿名函数" class="headerlink" title="3、匿名函数"></a>3、匿名函数</h4><p>1、如果某个函数我们只是希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用</p><p>2、匿名函数的三种使用方式</p><ul><li>在定义匿名函数时就直接调用，且只能调用一次</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res1 := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1 + n2</span><br><span class="line">     &#125;(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">     <span class="comment">//在定义匿名函数的同时就调用它</span></span><br><span class="line">     </span><br><span class="line">      fmt.Println(<span class="string">"res1="</span>,res1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在紧跟匿名函数定义的后面传入参数调用<br><img src="/2020/06/11/go-函数/func10.png" alt="func10"></p><ul><li>将匿名函数赋给一个变量（函数变量），再通过该变量来调用匿名函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将匿名函数func(n1 int, n2 int) int 赋值给变量a</span></span><br><span class="line">    <span class="comment">//则a的数据类型就是函数类型，可以通过变量a完成调用</span></span><br><span class="line">    a := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1 + n2</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    res2 := a(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">    res3 := a(<span class="number">90</span>,<span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line">     fmt.Println(<span class="string">"res2="</span>,res2)</span><br><span class="line">     fmt.Println(<span class="string">"res3="</span>,res3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将匿名函数赋给一个全局变量，则这个匿名函数成为一个全局匿名函数，可以在整个程序有效</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    Func1 = <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> n1 + n2</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//这时func1即是一个全局匿名函数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res4 := Func1(<span class="number">4</span>,<span class="number">9</span>)</span><br><span class="line">    fmt.Println(<span class="string">"res4="</span>,res4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h4><p>1、闭包：就是<strong>一个函数</strong>和<strong>与其相关的引用环境</strong>组合的一个整体（实体）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        n = n + x</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f := AddUpper()</span><br><span class="line">    fmt.Println(f(<span class="number">1</span>)) <span class="comment">//输出11</span></span><br><span class="line">    fmt.Println(f(<span class="number">2</span>)) <span class="comment">//输出11+2=13</span></span><br><span class="line">    fmt.Println(f(<span class="number">3</span>)) <span class="comment">//输出13+3=16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对上面代码的说明</p><ul><li>AddUpper是一个函数，处于外层，返回数据类型时func(int) int</li><li><strong>闭包</strong>的说明</li></ul><p><img src="/2020/06/11/go-函数/func11.png" alt="func11"></p><p>在上图红框中可以看到，return返回一个匿名函数，处于内层，这个匿名函数<strong>引用到外层函数的变量n</strong>，因此这个<strong>匿名函数和变量n形成一个整体</strong>，构成<strong>闭包</strong></p><ul><li><p>可以理解成：闭包是一个类，函数是操作，变量n是字段。函数和它使用到的字段n构成闭包</p></li><li><p>在main函数中，外层函数AddUpper只被调用一次，所以AddUpper函数中的n只被初始化一次</p></li><li><p>当我们反复调用内层函数f时，因为外层函数中的变量n只初始化一次，因此每次调用进行累计，而不会重新初始化</p></li><li><p>闭包的关键，是要分析出返回的内层函数它所引用到的外层函数中的变量，因为函数和它所引用到的变量构成闭包</p></li></ul><h4 id="5、函数中的defer"><a href="#5、函数中的defer" class="headerlink" title="5、函数中的defer"></a>5、函数中的defer</h4><p>1、为什么需要defer<br>    在函数中，经常需要创建资源（如数据库连接、文件句柄、锁等），<strong>为了在函数执行完毕后，及时的释放资源</strong>，Go提供defer（延迟机制）</p><p> 2、defer使用案例<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//当执行到defer时，暂时不执行defer后的语句，会将defer后的语句压入独立的栈（这个栈和main函数及sum函数的栈不一样，这里称为defer栈）中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当函数执行完毕后，再从defer栈中，按先入后出顺序出栈执行</span></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n1="</span>,n1)<span class="comment">//3 n1=10</span></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n2="</span>,n2)<span class="comment">//2 n2=20</span></span><br><span class="line">   </span><br><span class="line">   res := n1+n2</span><br><span class="line">   fmt.Println(<span class="string">"n1+n2="</span>,res)<span class="comment">//1 n1+n2=30</span></span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res := sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)<span class="comment">//4 res=30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出顺序：<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n1+n2=<span class="number">30</span></span><br><span class="line">n2=<span class="number">20</span></span><br><span class="line">n1=<span class="number">10</span></span><br><span class="line">res=<span class="number">30</span></span><br></pre></td></tr></table></figure></p><p> 3、当执行到defer时，暂时不执行defer后的语句，会将defer后的语句压入独立的栈中，然后执行函数的下一条语句</p><p> 4、当函数执行完毕后，再从defer栈中，按先入后出顺序出栈执行</p><p> 5、将defer后的语句放入栈时，也会<strong>将相关的值拷贝同时入栈</strong><br>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n1="</span>,n1)<span class="comment">//defer  3 n1=10</span></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"n2="</span>,n2)<span class="comment">//defer  2 n2=20</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//增加两条语句</span></span><br><span class="line">  n1++ <span class="comment">//n1=11</span></span><br><span class="line">  n2++ <span class="comment">//n2=21</span></span><br><span class="line">  <span class="comment">//这里n1、n2自增后，并不影响defer栈中的值，因为defer之后的语句入栈时，同时将值拷贝入栈，所以defer中的n1、n2值仍是入栈时候的值</span></span><br><span class="line">  </span><br><span class="line">   res := n1+n2</span><br><span class="line">   fmt.Println(<span class="string">"n1+n2="</span>,res)<span class="comment">//1 n1+n2=32</span></span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res := sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)<span class="comment">//4 res=32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出顺序：<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n1+n2=<span class="number">32</span></span><br><span class="line">n2=<span class="number">20</span></span><br><span class="line">n1=<span class="number">10</span></span><br><span class="line">res=<span class="number">32</span></span><br></pre></td></tr></table></figure></p><h4 id="6、函数参数传递的方式"><a href="#6、函数参数传递的方式" class="headerlink" title="6、函数参数传递的方式"></a>6、函数参数传递的方式</h4><p>1、两种传递方式</p><ul><li><strong>值传递</strong></li><li><strong>引用传递</strong></li></ul><p>不管是值传递还是引用传递，<strong>传递给函数的都是变量的副本</strong>。不同的是：<strong>值传递</strong>传递的是<strong>值的拷贝</strong>，<strong>引用传递</strong>传递的是<strong>地址的拷贝</strong>。</p><p>一般来说，地址拷贝效率高，因为数据量小，而值拷贝的效率由传递的数据大小决定，数据越大，效率越低。</p><p>2、值类型和引用类型</p><ul><li>值类型：<strong>基本数据类型（int系列、float系列、bool、string）、数组、结构体</strong></li><li>引用类型：<strong>指针、slice切片、map、管道channel、interface</strong>等</li></ul><h4 id="7、字符串中常用系统函数"><a href="#7、字符串中常用系统函数" class="headerlink" title="7、字符串中常用系统函数"></a>7、字符串中常用系统函数</h4><p>1、统计字符串的长度，按<strong>字节</strong>：<strong>len(str)</strong><br>是一个内置（内建）函数，不属于任何包，可直接使用</p><p>2、字符串遍历，同时处理 有中文的问题：<strong>r := []rune(str)</strong><br>遍历字符串时，可先将string类型的字符串str转成rune的切片：[]rune(str)，再进行遍历，因为string类型按字节遍历，[]rune按字符遍历，一个中文占三个字节。（for循环按字节遍历，for … range 按字符遍历）</p><p>3、字符串转整数：<strong>n,err := strconv.Atoi(“12”)</strong></p><p>4、整数转字符串：<strong>str = strconv.Itoa(12345)</strong></p><p>5、字符串转[]byte：<strong>var bytes = []byte(“hello go”)</strong></p><p>6、[]byte转字符串：<strong>str = string([]byte{97,98,99})</strong></p><p>7、十进制转二进制、八进制、十六进制</p><ul><li>十进制转二进制:</li></ul><p><strong>str = strconv.FormatInt(123,2)</strong></p><ul><li>十进制转八进制:</li></ul><p>str = strconv.FormatInt(123,<strong>8</strong>)</p><ul><li>十进制转十六进制:</li></ul><p>str = strconv.FormatInt(123,<strong>16</strong>)</p><p>8、查找子串是否在指定的串中：<strong>strings.Contains(“seafood”,”foo”)</strong>//true</p><p>9、统计一个字符串中有几个指定的子串：strings.Count(“ceheese”,”e”)//4</p><p>10、不区分大小写的字符串比较（用“==”比较区分大小写）：<strong>strings.EqualFold(“abc”,”Abc”)</strong>//true</p><p>11、返回子串在字符串中第一次出现的index值，如果没有返回-1：<strong>strings.Index(“NLT_abc”,”abc”)</strong>//4  下标从0开始索引</p><p>12、返回子串在字符串中最后一次出现的index值，如果没有返回-1：<strong>strings.LastIndex(“go go hello”,”go”)</strong>//3  下标从0开始索引</p><p>13、将指定的子串替换成另外一个子串：<strong>strings.Replace(“go go hello”,”go”,”go语言”，n)</strong><br>n可以指定你希望替换几个，n=-1表示全部替换</p><p>14、按照指定的某个字符为分割标识，将一个字符串拆分成字符串数组：<strong>strings.Split(“hello,world,ok”,”,”)</strong></p><p>15、将字符串的字母进行大小写转换：</p><p>大写转小写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.ToLower(<span class="string">"Go"</span>)<span class="comment">//go</span></span><br></pre></td></tr></table></figure></p><p>小写转大写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.ToUpper(<span class="string">"Go"</span>)<span class="comment">//GO</span></span><br></pre></td></tr></table></figure></p><p>16、将字符串的左右两边空格去掉：<strong>strings.TrimSpace(“  go hello    “)</strong></p><p>17、将字符串左右两边指定的字符去掉：<strong>strings.Trim(“! hello!”,” !”)</strong><br>//将【hello】左右两边的！和空格去掉</p><p>18、将字符串左边指定的字符去掉：<strong>strings.TrimLeft(“! hello!”,” !”)</strong><br>//将【hello】左边的！和空格去掉</p><p>19、将字符串右边指定的字符去掉：<strong>strings.TrimRight(“! hello!”,” !”)</strong><br>//将【hello】右边的！和空格去掉</p><p>20、判断字符串是否以指定的字符串开头：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.HasPrefix(<span class="string">"ftp://192.168.10.1"</span>,<span class="string">"ftp"</span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>21、判断字符串是否以指定的字符串结束：<strong>strings.HasSuffix(“go_var.jpg”,”jpg”)</strong>//true</p><h4 id="8、日期和时间相关函数"><a href="#8、日期和时间相关函数" class="headerlink" title="8、日期和时间相关函数"></a>8、日期和时间相关函数</h4><p>使用时间和日期函数需要引入<strong>time包</strong><br>1、<strong>time.Time</strong>类型，用于表示时间</p><p>2、获取当前时间<br><strong>now := time.Now()</strong>//now类型是time.Time</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过变量now获取年月日、时分秒</span><br><span class="line">now.Year()</span><br><span class="line">now.Month()<span class="comment">//英文月份</span></span><br><span class="line"><span class="keyword">int</span>（now.Month()）<span class="comment">//int强转为数字月份</span></span><br><span class="line">now.Day()</span><br><span class="line">now.Hour()</span><br><span class="line">now.Minute()</span><br><span class="line">now.Second()</span><br></pre></td></tr></table></figure><p>3、格式化日期</p><h5 id="1）方式1使用Printf或者Sprintf"><a href="#1）方式1使用Printf或者Sprintf" class="headerlink" title="1）方式1使用Printf或者Sprintf"></a>1）方式1使用Printf或者Sprintf</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">"当前年月日时分秒 %02d-%02d-%02d %02d-%02d-%02d \n"</span>,now.Year(),now.Month(),now.Day(),now.Hour(),now.Minute(),now.Second())</span><br></pre></td></tr></table></figure><p>或者Sprintf，Sprintf会返回一个字符串<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">dateStr := fmt.Sprintf(<span class="string">"当前年月日时分秒 %02d-%02d-%02d %02d-%02d-%02d \n"</span>,now.Year(),now.Month(),now.Day(),now.Hour(),now.Minute(),now.Second())</span><br><span class="line"><span class="comment">//fmt.Sprintf返回一个时间日期字符串赋给变量dateStr，可对变量dateStr进行操作(输出或保存等)</span></span><br><span class="line">fmt.Printf(<span class="string">"dateStr=%v\n"</span>,dateStr)</span><br></pre></td></tr></table></figure></p><h5 id="2）方式2使用Format"><a href="#2）方式2使用Format" class="headerlink" title="2）方式2使用Format"></a>2）方式2使用Format</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.printf(now.Format(<span class="string">"2006/01/02 15:04:05"</span>))<span class="comment">//年月日时分秒</span></span><br><span class="line">fmt.printf(now.Format(<span class="string">"2006/01/02))//年月日</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">15</span>:<span class="number">04</span>:<span class="number">05</span><span class="string">"))//时分秒</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">2006</span><span class="string">"))//年</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">01</span><span class="string">"))//月</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">02</span><span class="string">"))//日</span></span><br><span class="line"><span class="string">fmt.printf(now.Format("</span><span class="number">2006</span><span class="number">-01</span><span class="number">-02</span> <span class="number">15</span>:<span class="number">04</span>:<span class="number">05</span><span class="string">"))</span></span><br></pre></td></tr></table></figure><p><strong>“2006/01/02 15:04:05”这一串数字是固定的，不能更改</strong>，但格式和组合可以改（传说这串数字是Go开发者脑海中萌生GoLang的时刻）。</p><p>4、时间的常量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    Nanosecond Duration = <span class="number">1</span>                             <span class="comment">//纳秒</span></span><br><span class="line">    Microsecond             = <span class="number">1000</span> * Nanosecond     <span class="comment">//微秒</span></span><br><span class="line">    Millisecond                = <span class="number">1000</span> * Microsecond     <span class="comment">//毫秒</span></span><br><span class="line">    Second                     = <span class="number">1000</span> * Millsecond      <span class="comment">//秒</span></span><br><span class="line">    Minute                     = <span class="number">60</span> * Second            <span class="comment">//分钟</span></span><br><span class="line">    Hour                        = <span class="number">60</span> * Minute           <span class="comment">//小时</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>常量的作用：在程序中可用于获取指定时间单位的时间，比如想得到100毫秒 100 * time.Millisecond</p><p>可用于休眠<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time.Sleep(time.Second)<span class="comment">//休眠1秒</span></span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">100</span>)<span class="comment">//休眠0.1秒</span></span><br><span class="line"><span class="comment">//只能传入整数，不能传小数</span></span><br><span class="line"><span class="comment">//休眠0.1秒不能这么写time.Sleep(time.Second * 0.1)</span></span><br></pre></td></tr></table></figure></p><p>5、时间戳</p><ul><li><p>unix时间戳<br>返回1970年1月1日0时0分0秒 到当前时间的秒数</p></li><li><p>unixnano时间戳(unix纳秒时间戳)<br>返回1970年1月1日0时0分0秒 到当前时间的纳秒数</p></li></ul><p>可以用于<strong>获取随机的数字</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了每次生成的随机数不一样，需要设定一个种子seed</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">num := rand.Intn(<span class="number">100</span>)<span class="comment">//0&lt;=n&lt;100</span></span><br><span class="line"><span class="comment">//如果不设置种子，会有一个默认值，但每次随机出来的数都一样</span></span><br></pre></td></tr></table></figure></p><h4 id="9、内置（buildin）函数"><a href="#9、内置（buildin）函数" class="headerlink" title="9、内置（buildin）函数"></a>9、内置（buildin）函数</h4><p>1、len()：求长度，比如string、array、slice、map、channel</p><p>2、func new<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure></p><p>new分配分存，第一个实参为类型而非值，new函数返回值为<strong>指向该类型</strong>的<strong>新分配</strong>的<strong>零值</strong>的<strong>指针</strong>，主要为<strong>值类型</strong>分配内存<br>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num1 := <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"num1的类型%T，num1的值%v，num1的地址%v"</span>，num1，num1，&amp;num1)</span><br><span class="line"><span class="comment">//num1的类型int，num1的值100，num1的地址0xcXXXXXXXX</span></span><br><span class="line"></span><br><span class="line">num2 := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"num2的类型%T，num2的值%v，num2的地址%v，num2指针指向的值"</span>，num2，num2，&amp;num2，*num2)</span><br><span class="line"><span class="comment">//num2的类型*int，</span></span><br><span class="line"><span class="comment">//num2的值0xcXXXXXXXX，num2的地址0xcXXXXXXXX，num2指针指向的值0,（这两个地址在程序运行时，系统动态分配）</span></span><br><span class="line"><span class="comment">//num2的值是一个地址，该地址指向int类型的零值0</span></span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/11/go-函数/func12.jpg" alt="func12"></p><p>3、make：分配内存，主要用来分配<strong>引用类型</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、函数&quot;&gt;&lt;a href=&quot;#1、函数&quot; class=&quot;headerlink&quot; title=&quot;1、函数&quot;&gt;&lt;/a&gt;1、函数&lt;/h3&gt;&lt;h4 id=&quot;1、函数调用底层机制&quot;&gt;&lt;a href=&quot;#1、函数调用底层机制&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>go:基本数据类型、运算符</title>
    <link href="http://yoursite.com/2020/06/11/go-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/06/11/go-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-06-11T07:12:36.000Z</published>
    <updated>2020-06-11T07:18:23.958Z</updated>
    
    <content type="html"><![CDATA[<h4 id="go特点"><a href="#go特点" class="headerlink" title="go特点"></a>go特点</h4><p>1、go=c+python，既有静态语言程序运行的速度以及安全和性能，又能达到动态语言（如脚本语言）的开发维护的高效率。<br>2、go语言的一个文件必须要归属一个包，不能单独存在<br>3、垃圾回收机制、内存自动回收<br>4、天然并发（超级重要）</p><ul><li>从语言层面支持并发，实现简单</li><li>goroutine：轻量级线程，可实现大并发处理，高效利用多核</li><li>基于CPS并发模型（Communicating Sequential Processes）实现</li></ul><p>5、管道通信机制，形成go语言特有的管道channel。通过管道channel可以实现不同的goroute之间的通信</p><p>6、函数返回多个值</p><p>7、新的创新，如切片slice，延时执行defer等</p><h4 id="go运行"><a href="#go运行" class="headerlink" title="go运行"></a>go运行</h4><p>如有一个hello.go文件，运行它的两种方法<br>1、<strong>go bulid</strong> hello.go先编译这个文件，生成hello.exe二进制可执行文件，再直接切到该目录下输入hello.exe命令即可运行。<br>2、<strong>go run</strong> hello.go，编译运行一起执行，直接输出结果</p><p>区别：<br>1、先编译后再运行.exe文件，运行速度很快，go run命令需要编译+运行速度明显慢<br>2、编译后生成的.exe文件，可以放在没有go开发环境的机器上运行起来，因为hello.exe文件比hello.go文件大，因为编译后的.exe文件动态引入了运行所需要的很多库，所以可以跑起来，但go run命令不行，因为需要开发环境对.go文件进行编译。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量的几种数据类型<br><img src="/2020/06/11/go-基本数据类型、运算符/var1.jpg" alt="var1"></p><p>在GO中，数据类型都有一个默认值（零值），基本数据类型的零值如下</p><ul><li>整型：0</li><li>浮点型：0</li><li>字符串：“”空串</li><li>bool类型：false</li></ul><p>格式化%v表示按照变量的值输出</p><h4 id="1、整数类型"><a href="#1、整数类型" class="headerlink" title="1、整数类型"></a>1、整数类型</h4><p>1、int，uint表示的位数与系统有关，32位系统表示4个字节，64位表示8个字节</p><p>2、rune，有符号，字节数等价int32，但表示一个Unicode码，用于处理带中文的字符串。</p><p>3、byte，无符号，与uint8等价，用来存储单个字符。<br><img src="/2020/06/11/go-基本数据类型、运算符/var2.jpg" alt="var2"></p><p>4、golang整型默认声明为int类型</p><p>5、查看某个变量的占用字节大小和数据类型<br>fmt.Printf(“n的数据类型是 %T n占用的字节数是 %d”,n,unsafe.Sizeof(n))</p><p>6、在保证程序的正确运行下，尽量使用占用空间小的数据类型，遵守保小不保大的原则，若不知道该变量之后表示的值的大小，可以稍微选用大的。</p><h4 id="2、浮点类型"><a href="#2、浮点类型" class="headerlink" title="2、浮点类型"></a>2、浮点类型</h4><p>1、浮点类型有固定的范围和字段长度，不受具体操作系统的影响</p><p>2、golang浮点类型默认声明为float64</p><p>3、开发中，推荐使用float64，因为比float32更精确</p><h4 id="3、字符类型"><a href="#3、字符类型" class="headerlink" title="3、字符类型"></a>3、字符类型</h4><p>1、Golang中没有专门的字符类型，存储单个字符（如ASCII码所表示的字符）使用byte来保存<br>注：</p><ul><li>直接输出byte变量的值时，实际上是输出了对应字符的ASCII码值，如要输出对应字符，用格式化%c输出</li><li>输出int变量表示字符的UTF-8编码的码值时用格式化%d输出</li></ul><p>2、Go的<strong>字符串</strong>是由单个<strong>字节</strong>连接起来的，与传统字符串由<strong>字符</strong>连接不同。</p><p>3、字符常量是用单引号‘’括起来的单个字符。例var c1 byte=’a’  var c2 int=’中’</p><p>4、Go的字符使用UTF-8编码，英文字母一个字节表示，汉字三个字节表示</p><p>5、Go中，字符的本质是一个整数，直接输出时是该字符对应的UTF-8编码的码值</p><p>6、可以给某个变量赋值一个数字，按格式化输出时%c会输出该数字对应的Unicode字符</p><p>7、字符类型可以进行运算，因为本质就是一个整数，都对应有Unicode码值</p><h4 id="4、布尔类型"><a href="#4、布尔类型" class="headerlink" title="4、布尔类型"></a>4、布尔类型</h4><p>1、Go中bool类型<strong>只允许取值true和false</strong></p><p>2、bool类型占1个字节</p><h4 id="5、字符串类型"><a href="#5、字符串类型" class="headerlink" title="5、字符串类型"></a>5、字符串类型</h4><p>1、Go的<strong>字符串</strong>是由单个<strong>字节</strong>连接起来的，与传统字符串由<strong>字符</strong>连接不同。</p><p>2、字符串一旦赋值，就不能修改了，即Go中字符串是不可变的</p><p>3、字符串两种表示方式</p><ul><li>双引号“”，会识别转义字符</li><li>反引号,以字符串的原生形式输出，包括换行和转义字符，可以防止攻击，输出源代码等效果。</li></ul><p>4、字符串连接使用“+”号，多行连接时需要把“+”号放在上一行末尾</p><h4 id="6、基本数据类型转换"><a href="#6、基本数据类型转换" class="headerlink" title="6、基本数据类型转换"></a>6、基本数据类型转换</h4><p>1、Go与Java/C不同，Go在不同类型的变量之间赋值时需要显示转换，即不能自动转换</p><p>2、数据转换时，被转换的是变量存储的数据（值），变量本身的数据类型不会改变<br>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i <span class="keyword">int32</span>=<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int64</span>=<span class="keyword">int64</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//i本身不会改变</span></span><br></pre></td></tr></table></figure></p><p>3、高精度向低精度转换，低精度向高精度转换都可以，只是高精度向低精度转换时会溢出，和我们预想结果不一致，但编译器不会报错</p><h4 id="6、基本数据类型和字符串类型相互转换"><a href="#6、基本数据类型和字符串类型相互转换" class="headerlink" title="6、基本数据类型和字符串类型相互转换"></a>6、基本数据类型和字符串类型相互转换</h4><h5 id="1）基本数据类型转string"><a href="#1）基本数据类型转string" class="headerlink" title="1）基本数据类型转string"></a>1）基本数据类型转string</h5><ol><li>fmt.Sprintf(“%参数”，表达式）<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>,a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Sprintf根据format参数生成格式化字符串并返回</span></span><br></pre></td></tr></table></figure></li></ol><p>参数需要和表达式的数据类型相匹配</p><p>2.使用strconv包的函数 </p><h5 id="2）string转基本数据类型"><a href="#2）string转基本数据类型" class="headerlink" title="2）string转基本数据类型"></a>2）string转基本数据类型</h5><ol><li>使用strconv包的函数 </li></ol><h5 id="3）注意事项"><a href="#3）注意事项" class="headerlink" title="3）注意事项"></a>3）注意事项</h5><p>1、string转基本数据类型时，要<strong>确保string类型能够转成有效的数据</strong>。比如可以把”123“转成一个整数，但不能把”hello“转成一个整数，如果这样做，go不会报错，而是直接转成默认值。</p><h4 id="7、指针"><a href="#7、指针" class="headerlink" title="7、指针"></a>7、指针</h4><p>1、值类型包括：基本数据类型、数组和结构体struct</p><p>2、引用类型包括：指针、切片slice、map、管道channel、interface</p><p>3、值类型和引用类型<br><img src="/2020/06/11/go-基本数据类型、运算符/var3.jpg" alt="var3"></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="1、算术运算符"><a href="#1、算术运算符" class="headerlink" title="1、算术运算符"></a>1、算术运算符</h4><p>1、Go中自增自减只能作为一个独立的语句使用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">b:=a++<span class="comment">//错误</span></span><br><span class="line">b:=a--<span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">int</span></span><br><span class="line">d=c++<span class="comment">//错误，只能独立使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> i++ &gt; <span class="number">10</span>&#123;<span class="comment">//错误，只能独立使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">e++</span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">int</span> = e<span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p><p>2、Go的自增自减只有后加加a++和后减减a–，去除了很多容易混淆的写法</p><h4 id="2、位运算符"><a href="#2、位运算符" class="headerlink" title="2、位运算符"></a>2、位运算符</h4><p>1、原码、反码、补码<br><img src="/2020/06/11/go-基本数据类型、运算符/op1.jpg" alt="op1"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">求<span class="number">-2</span>^<span class="number">2</span>=?</span><br><span class="line"></span><br><span class="line"><span class="number">-2</span> =&gt; 原码 <span class="number">1000</span> <span class="number">0010</span> =&gt; 反码（符号位不变，其他位取反） <span class="number">1111</span> <span class="number">1101</span> =&gt;补码（反码+<span class="number">1</span>） <span class="number">1111</span> <span class="number">1110</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> =&gt;为正数，原码、反码、补码一样 =&gt;<span class="number">0000</span> <span class="number">0010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算机运算都是用补码运算</span></span><br><span class="line"><span class="number">-2</span>^<span class="number">2</span>=<span class="number">1111</span> <span class="number">1110</span> ^ <span class="number">0000</span> <span class="number">0010</span> = <span class="number">1111</span> <span class="number">1100</span><span class="comment">//结果是补码，需转换为原码</span></span><br><span class="line"></span><br><span class="line">补码 <span class="number">1111</span> <span class="number">1100</span> =&gt;反码（补码<span class="number">-1</span>）<span class="number">1111</span> <span class="number">1011</span> =&gt;原码（符号位不变，其他位取反）<span class="number">1000</span> <span class="number">0100</span> =&gt; 十进制 <span class="number">-4</span></span><br><span class="line"></span><br><span class="line">则：<span class="number">-2</span>^<span class="number">2</span>=<span class="number">-4</span></span><br></pre></td></tr></table></figure><p>2、Go中有两个移位运算符</p><ul><li>右移运算符&gt;&gt;：低位溢出，符号位不变，并用符号位补溢出的高位</li><li>左移运算符&lt;&lt;：符号位不变，低位补0</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;go特点&quot;&gt;&lt;a href=&quot;#go特点&quot; class=&quot;headerlink&quot; title=&quot;go特点&quot;&gt;&lt;/a&gt;go特点&lt;/h4&gt;&lt;p&gt;1、go=c+python，既有静态语言程序运行的速度以及安全和性能，又能达到动态语言（如脚本语言）的开发维护的高效率。&lt;b
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Merkle树</title>
    <link href="http://yoursite.com/2020/06/11/Merkle%E6%A0%91/"/>
    <id>http://yoursite.com/2020/06/11/Merkle%E6%A0%91/</id>
    <published>2020-06-11T03:22:09.000Z</published>
    <updated>2020-06-11T03:30:37.161Z</updated>
    
    <content type="html"><![CDATA[<p>1、在分布式系统、<strong>P2P应用</strong>中或者是<strong>区块链</strong>中，会经常使用一种数据结构<strong>Merkle tree（默克尔树）</strong>，这里我们将详细讨论一下这个常用数据结构。Merkle treeMerkle树看起来非常像二叉树，其叶子节点上的值通常为数据块的哈希值，而非叶子节点上的值，所以有时候Merkle tree也表示为<strong>Hash tree</strong>，如下图所示：<br><img src="/2020/06/11/Merkle树/merkle1.png" alt="merkle1"></p><p>2、在构造Merkle树时，首先要对数据块计算哈希值，通常，选用SHA-256等哈希算法。但如果仅仅防止数据不是蓄意的损坏或篡改，可以改用一些安全性低但效率高的校验和算法，如CRC。</p><p>3、然后将数据块计算的哈希值两两配对（如果是奇数个数，最后一个自己与自己配对），计算上一层哈希，再重复这个步骤，一直到计算出根哈希值。Merkle树大多用来进行完整性验证，比如分布式环境下，从多台主机获取数据，怎么验证获取的数据是否正确呢，只要验证Merkle树根哈希一致，即可。例如，下图中L3数据块发生错误（比如数据被修改了），错误会传导到计算hash(L3)，接着传导到计算hash(Hash1-0+Hash1-1)，最后传导到根哈希，导致根哈希的不一致，可以说，任何底层数据块的变化，最终都会传导到根哈希。另外如果根哈希不一致，也可以通过Merkle树快速定位到导致不一致的数据。</p><p>4、Merkle树还可以用来对数据进行快速比对，快速定位到不一致的数据。比如分布式存储中，一份数据会有多个副本，并且分布在不同的机器上。为了保持数据一致性，需要进行副本同步，而首要的就是比对当前副本是否一致，如一致，则无需同步，如不一致，还需找出不一致的地方，然后进行同步。很明显，如果采用直接传输数据进行比对，非常低效，一般采用对数据进行哈希，传输哈希值进行对比的方法。为此，可以对每台机器需要比对的数据构造Merkle树，如果根哈希一致，则数据相同，如果根哈希不一致，则通过Merkle树快速检索到不一致的数据。下面举例说明快速检索的过程，如上图蓝色标注所示。假设两台机器中L3数据块不一致，我们对比根哈希，发现根哈希不一致，即，数据不一致，此时需要找出是那一块不一致，分别对比Hash0和Hash1，发现是Hash1不一致，接着向下发现是Hash1-0不一致，这样就定位到是L3数据块不一致。定位过程的算法复杂度为O(log(n))。</p><p>还有一种数据结构，在一定程度上可以看做是Merkle树的子树，但又不完全一样，这个数据结构是Hash list（为了避免中文哈希列表与哈希表的误解，这里使用英文名称），我们下面看一下这个Hash list。<br>在点对点网络中数据传输的时候，为了提高效率往往会同时从多个机器下载数据的不同部分，即，不是从一台机器下载整个数据，而是将完整数据分成不同的部分，分别同时从不同的机器获取完整数据的不同组成部分。这样分块传输不但可以同时从多台机器下载数据，另一个好处是如果这一小块数据传输过程中损坏了，只要重新下载这一小数据块就可以了，不用重新下载整个数据。但这种分布式环境下，很多机器应该认为是不稳定或者不可信的，如何校验整个数据的完整性及每一小数据块的完整性呢？<br><img src="/2020/06/11/Merkle树/merkle2.png" alt="merkle2"></p><p>5、为了校验每一个数据块，我们需要对每个数据块做哈希，形成一个哈希列表，这样进行下载前，我们先要获取一个哈希列表，下载后，我们就能够通过哈希列表，来验证每一个数据块。哪怎么保证这个哈希列表是正确的呢，或者说怎么校验完整数据呢？只要每一个数据块哈希是正确的，最终获取的完整数据就一定是正确的，所以，我们需要对哈希列表进行哈希得到根哈希，将此根哈希放到一个可信源中，在下载数据前，先从可信数据源哪里获取到数据的跟哈希，然后从任意机器获取哈希列表，再下载数据块。这样，数据完整性可以通过根哈希来保证。</p><h5 id="Merkle-tree-对比-Hash-list"><a href="#Merkle-tree-对比-Hash-list" class="headerlink" title="Merkle tree 对比 Hash list"></a>Merkle tree 对比 Hash list</h5><p>两种数据结构都有验证数据完整性的功能，都可以通过根哈希保证整体数据完整性。所不同的是，在数据庞大，数据块非常多的情况下，当根哈希检测到数据不一致时，Merkle tree可以快速的定位到导致不一致的数据块，复杂度为O(log(n))，而Hash list只能遍历庞大的哈希列表定位到导致不一致的数据块，复杂度为O(n)，很显然，此时Merkle tree的效率要高很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在分布式系统、&lt;strong&gt;P2P应用&lt;/strong&gt;中或者是&lt;strong&gt;区块链&lt;/strong&gt;中，会经常使用一种数据结构&lt;strong&gt;Merkle tree（默克尔树）&lt;/strong&gt;，这里我们将详细讨论一下这个常用数据结构。Merkle treeMer
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>区块链小白书</title>
    <link href="http://yoursite.com/2020/06/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%8F%E7%99%BD%E4%B9%A6/"/>
    <id>http://yoursite.com/2020/06/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%8F%E7%99%BD%E4%B9%A6/</id>
    <published>2020-06-11T02:50:45.000Z</published>
    <updated>2020-06-11T03:20:24.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区块链小白书"><a href="#区块链小白书" class="headerlink" title="区块链小白书"></a>区块链小白书</h2><h3 id="1、交易过程"><a href="#1、交易过程" class="headerlink" title="1、交易过程"></a>1、交易过程</h3><p>假设网络中有如下四个节点，且每个节点拥有的如下币值<br><img src="/2020/06/11/区块链小白书/link1.png" alt="link1"></p><p>1、没有可信任的第三方后，每个人互相之间无法信任，如果要创建一个交易订单（转账），需要：<br>1、发广播，让所有人都知道网络里每一个人每一笔钱的来龙去脉<br>例：B向C转账100BTC<br>1）则B需要发广播通知网络中的每一个人，“大家好，我是B，我要向C转账100BTC，我的电子签名是xxxxxxx”<br><img src="/2020/06/11/区块链小白书/link2.png" alt="link2"></p><p>2）然后网络中的每一个人都收到这个广播<br><img src="/2020/06/11/区块链小白书/link3.png" alt="link3"></p><p>3）网络中的每个节点会通过电子签名验证这个交易是否是我发起的<br><img src="/2020/06/11/区块链小白书/link4.png" alt="link4"></p><p>4）验证通过后网络中每个节点把这笔交易记在账本上，B就少100，C多100<br><img src="/2020/06/11/区块链小白书/link5.png" alt="link5"></p><p>5）网络中的每个节点怎么知道我真的有100BTC呢？<br>每个节点的账本会帮助确认，<strong>这个账本即是区块，把区块连起来就是区块链</strong>。</p><p>6）在比特币系统中，区块链记录了比特币从创立至今所有的交易记录，现在大概有60万个区块，每个区块里记录了两三千笔交易，包括网络中每一个节点有多少钱，从哪里来，花到哪儿去，都记录的一清二楚，透明公开。</p><p>7）<strong>在区块链网络里，每个节点都拿着一份相同且实时更新的账本</strong>。当B广播说要给C转账100BTC时，每个节点手里的账本就开始回溯，检查B是否有100BTC。如果没有，转账无效。</p><p>8）账本的可靠性是数字货币的基石，如果账本出了问题，什么币都不好使。这就引出两个新问题：</p><ul><li>谁来给大家记账</li><li>怎么保证账本不被造假</li></ul><p>9）如果每个人都能记账，那每个区块里包含的交易和交易顺序可能都不一样，如果有故意记假账的，那就更乱了，不可能得到一个大家都接受的账本，所以，记账的人得让所有人都能接受，这样大家的账本才能统一，这被称为<strong>共识机制</strong>。</p><p>10）今天各种区块链有各种不同的共识机制。</p><ul><li>GateChain：Pos</li><li>EOS：dPos</li><li>NEO：dBFT</li><li>中本聪提出的比特币网络使用的是做题，谁先把答案算出来谁就有权力记账，这一机制被称为PoW(Proof-of-Work)，即工作量证明。</li></ul><p>11）工作量证明的本质是穷举，你的设备算力越强，算出答案的可能性就越高，为了做到这一点，需要用到哈希加密。以SHA256算法为例</p><p>12）任何一串字符用它加密后，都能得到一串独一无二的256位的二进制数<br><img src="/2020/06/11/区块链小白书/sha5.png" alt="sha5"><br>而原输入只要有任何一点轻微改动，哈希加密后的数字都会完全不同。</p><p>13）打开一个区块，我们可以看到一个区块的区块头，交易数量，交易详情等信息<br><img src="/2020/06/11/区块链小白书/link6.png" alt="link6"><br>14）区块头是一个区块的标签，包含了时间戳，Merkle根数树根哈希值，随机数和上一个区块的哈希值等信息<br><img src="/2020/06/11/区块链小白书/link7.png" alt="link7"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、随机数：为了找到满足难度目标所设定的随机数。</span><br><span class="line">为了解决32位随机数在算力飞升的情况下不够用的问题。规定时间戳和    COINBASE交易信息均可更改，一次扩展nonce的位数</span><br><span class="line"></span><br><span class="line">2、时间戳：该区块产生的近似时间，精确到秒的UNIX时间戳，必须严格大于前11个区块时间的中值，同时全节点也会拒绝那些超出自己2个小时时间戳的区块。</span><br><span class="line"></span><br><span class="line">3、Merkle根：该区块交易的Merkle树根的哈希值。同样采用SHA256（SHA256（））计算。</span><br></pre></td></tr></table></figure></p><p>15）而把区块头做二次SHA256计算，就能得到这个区块的哈希值<br><img src="/2020/06/11/区块链小白书/link8.png" alt="link8"></p><p>16）想要记账，就得把区块里的各种信息打包好，<br><img src="/2020/06/11/区块链小白书/link9.png" alt="link9"></p><p>在修改区块头里的这个随机数，让输入值能够在哈希计算后，得到一<strong>个前n个数都是0的哈希值</strong>。<br><img src="/2020/06/11/区块链小白书/link10.png" alt="link10"></p><p>17）每一位有0和1两种可能，每改变一次随机数成功的概率为1/2的n次方(1/2^n)，比如你 n=1，则第一位为0就行，成功率为1/2。<br><img src="/2020/06/11/区块链小白书/link11.png" alt="link11"></p><p>18）而网络里参与的算力越强，要算的0就越多，工作量证明的难度越大，今天比特币网络的n大概是76，成功率为1/2^76,差不多是1/756万亿亿，<br><img src="/2020/06/11/区块链小白书/link12.png" alt="link12"></p><p>用一块8000元的RTX2080Ti显卡，大概要算1407年。</p><p>19）要算对确实不容易，但只要你算出来了，所有人就可以瞬间验证你算得是否正确。如果确实没问题，大家就会把这个区块连接在账本上，开始打包计算下一个区块。这样，网络里的所有人就有一份相同且实时更新的账本了。<br><img src="/2020/06/11/区块链小白书/link13.png" alt="link13"></p><p>20）而为了让大家用动力做题记账，第一个完成区块打包的节点，会获得系统奖励，现在是12.5个比特币，差不多是60万人民币，这个过程也被称为<strong>挖矿</strong>。<br><img src="/2020/06/11/区块链小白书/link14.png" alt="link14"></p><p>21）另一方面，为了防止账本被篡改，每一个新加入的区块，都需要在区块头里，记录上一个区块的哈希值，也被称为<strong>哈希指针</strong>。<br><img src="/2020/06/11/区块链小白书/link15.png" alt="link15"></p><p>这样一个不断向前的指针，最终会指向第一个创始区块，把所有的区块紧紧连接在一起。</p><p>22）如果你修改任何一个区块里的任何一个字符，都会改变这个区块的哈希值，让下一个区块的哈希指针失效，所以你必须修改下一个区块的哈希指针，但这又会影响这个区块的哈希值，所以还需要重新计算随机数。完成计算后，还得接着计算这个区块的下一个区块，直到修改完这个区块后的所有区块，非常麻烦。<br><img src="/2020/06/11/区块链小白书/link16.png" alt="link16"></p><p>23）这样即使记账人想造假，也是做不到的，因为有电子签名，记账人不能伪造别人给自己的转账。又因为历史账本的存在，也不能凭空变出一笔钱来。<br><img src="/2020/06/11/区块链小白书/link17.png" alt="link17"></p><p>24）但这就引出一个新问题，如果两个人同时完成了计算，打包出了一个新区快，那该听谁的呢？答案是，谁长听谁的（<strong>最长链原则</strong>）。现在所有人都可以在这两个区块后面接着打包，比如下一轮先完成计算的人选择接在B上，则B链就更长了，其他人也会愿意接在B后面。一般情况下，打包6块之内就能分出胜负。被废弃的链上的交易会被撤回，重新放到交易池等待打包。<br><img src="/2020/06/11/区块链小白书/link18.png" alt="link18"></p><p>25）但既然谁长听谁的，只要你比大家都能算，算力大于51%，就能一个人算出最长链，进而控制账本。<br><img src="/2020/06/11/区块链小白书/link19.png" alt="link19"></p><p>所以比特币世界里的矿工算力越强，大家要算的0就越多，保证谁都不能控制记账权。<br><img src="/2020/06/11/区块链小白书/link20.png" alt="link20"></p><p>26）但参与者不多的其他区块链就不好说了，比如2018年5月15日，一个叫比特黄金的数字货币就遭遇了51%攻击。攻击者先是把自己价值1000万美金的比特黄金转给交易所，这笔转账被记录在区块A上，<br><img src="/2020/06/11/区块链小白书/link21.png" alt="link21"></p><p>同时攻击者秘密准备了一个这笔转账没有发生的区块B，<br><img src="/2020/06/11/区块链小白书/link22.png" alt="link22"></p><p>同时在区块B之后计算新的区块，等A链上的转账确认后，攻击者就可以把在交易所的的比特黄金提现，但因为攻击者的算力大于全网的51%，B链的长度终将大于A链，这是只要向全网发布更长的B链，<br><img src="/2020/06/11/区块链小白书/link23.png" alt="link23"></p><p>历史就会被改写，B链会替代A链成为真正主链，而区块A里转给交易所转账也会被撤回，攻击者白赚1000万。<br><img src="/2020/06/11/区块链小白书/link24.png" alt="link24"></p><p>27）今天，对于没有算力的普通人，获得数字货币最简单的办法就是去交易所购买，再提现到钱包地址，<br><img src="/2020/06/11/区块链小白书/link25.png" alt="link25"></p><p>这个地址来自于你的私钥，私钥加密后会得到公钥，公钥加密后会得到地址。<br><img src="/2020/06/11/区块链小白书/link26.png" alt="link26"></p><p>28）在区块链这样的匿网络里，只有私钥才能证明你是你，只要转账时附上你私钥生成的电子签名，大家就能确认这笔转账有效。<br><img src="/2020/06/11/区块链小白书/link27.png" alt="link27"></p><p>如果私钥泄露，谁都可以冒充你把钱转走。比如2013年一位 叫Adam的男士在电视直播里收到了相当于今天1500元的比特币，在他开心的向镜头展示私钥后，这笔钱就被当场偷走了。</p><p>注：整理自 回形针 区块链科普视频</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;区块链小白书&quot;&gt;&lt;a href=&quot;#区块链小白书&quot; class=&quot;headerlink&quot; title=&quot;区块链小白书&quot;&gt;&lt;/a&gt;区块链小白书&lt;/h2&gt;&lt;h3 id=&quot;1、交易过程&quot;&gt;&lt;a href=&quot;#1、交易过程&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>链队列</title>
    <link href="http://yoursite.com/2020/06/07/%E9%93%BE%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/07/%E9%93%BE%E9%98%9F%E5%88%97/</id>
    <published>2020-06-07T07:38:07.420Z</published>
    <updated>2019-03-13T07:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.cnblogs.com/lixiaolun/p/4646312.html" target="_blank" rel="noopener">https://www.cnblogs.com/lixiaolun/p/4646312.html</a></p><p>1、链队列的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Node front;</span><br><span class="line">Node rear;</span><br><span class="line">Node head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">head=<span class="keyword">new</span> Node();</span><br><span class="line">front=<span class="keyword">new</span> Node();</span><br><span class="line">rear=<span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">front=head;</span><br><span class="line">rear=head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">Node node=<span class="keyword">new</span> Node();</span><br><span class="line">node.data=e;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次入队</span></span><br><span class="line"><span class="keyword">if</span>(rear==head) &#123;</span><br><span class="line">head.next=node;</span><br><span class="line">front.next=node;</span><br><span class="line">rear=node;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">rear.next=node;</span><br><span class="line">rear=node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rear==head) &#123;</span><br><span class="line"><span class="comment">//队列为空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//队中只有一个元素</span></span><br><span class="line"><span class="keyword">if</span>(front.next==rear) &#123;</span><br><span class="line">rear=front;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">front.next=front.next.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node temp=head;</span><br><span class="line"><span class="keyword">while</span>(temp!=rear) &#123;</span><br><span class="line">System.out.println(temp.next.data);</span><br><span class="line">temp=temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">Object data;</span><br><span class="line">Node next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">LinkQueue qu=<span class="keyword">new</span> LinkQueue();</span><br><span class="line">qu.init();</span><br><span class="line">qu.enQueue(<span class="string">"ddd"</span>);</span><br><span class="line">qu.enQueue(<span class="number">8</span>);</span><br><span class="line">qu.enQueue(<span class="string">"ct"</span>);</span><br><span class="line">qu.enQueue(<span class="number">99</span>);</span><br><span class="line"><span class="comment">//qu.deQueue();</span></span><br><span class="line">qu.printQueue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/lixiaolun/p/4646312.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/lixiaolun/p/4646312.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
