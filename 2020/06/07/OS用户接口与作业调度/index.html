<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>操作系统-用户接口与作业调度 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1、程 序 的 启 动 和 结 束1.1．程序的启动– 程序开始执行时必须满足两个前提条件：• 程序已装入内存• 程序计数器PC中已置入该程序在内存的入口地址  1.2 五种启动程序执行的方式1）命令方式 2）批处理方式 3）EXEC方式– 在一个程序中运行另一个程序– 返回原来的程序 4）由硬件装入程序和启动程序执行 5）自启程序• 自己装入自己，并启动自己开始执行的程序• 自启程序由两部分组成">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-用户接口与作业调度">
<meta property="og:url" content="http://yoursite.com/2020/06/07/OS用户接口与作业调度/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1、程 序 的 启 动 和 结 束1.1．程序的启动– 程序开始执行时必须满足两个前提条件：• 程序已装入内存• 程序计数器PC中已置入该程序在内存的入口地址  1.2 五种启动程序执行的方式1）命令方式 2）批处理方式 3）EXEC方式– 在一个程序中运行另一个程序– 返回原来的程序 4）由硬件装入程序和启动程序执行 5）自启程序• 自己装入自己，并启动自己开始执行的程序• 自启程序由两部分组成">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi1.png?raw=true">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi2.png?raw=true">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi3.png?raw=true">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi4.png?raw=true">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi5.png?raw=true">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi6.png?raw=true">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi7.png?raw=true">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi8.png?raw=true">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi9.png?raw=true">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi10.png?raw=true">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi11.png?raw=true">
<meta property="og:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi12.png?raw=true">
<meta property="og:updated_time" content="2019-03-28T08:35:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统-用户接口与作业调度">
<meta name="twitter:description" content="1、程 序 的 启 动 和 结 束1.1．程序的启动– 程序开始执行时必须满足两个前提条件：• 程序已装入内存• 程序计数器PC中已置入该程序在内存的入口地址  1.2 五种启动程序执行的方式1）命令方式 2）批处理方式 3）EXEC方式– 在一个程序中运行另一个程序– 返回原来的程序 4）由硬件装入程序和启动程序执行 5）自启程序• 自己装入自己，并启动自己开始执行的程序• 自启程序由两部分组成">
<meta name="twitter:image" content="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi1.png?raw=true">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-OS用户接口与作业调度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/OS用户接口与作业调度/" class="article-date">
  <time datetime="2020-06-07T07:38:06.608Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      操作系统-用户接口与作业调度
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、程 序 的 启 动 和 结 束<br>1.1．程序的启动<br>– 程序开始执行时必须满足两个前提条件：<br>• 程序已装入内存<br>• 程序计数器PC中已置入该程序在内存的入口地址 </p>
<p>1.2 五种启动程序执行的方式<br>1）命令方式<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi1.png?raw=true" alt="Image text"></p>
<p>2）批处理方式<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi2.png?raw=true" alt="Image text"></p>
<p>3）EXEC方式<br>– 在一个程序中运行另一个程序<br>– 返回原来的程序<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi3.png?raw=true" alt="Image text"></p>
<p>4）由硬件装入程序和启动程序执行</p>
<p>5）自启程序<br>• 自己装入自己，并启动自己开始执行的程序<br>• 自启程序由两部分组成：引导程序和程序主体<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi4.png?raw=true" alt="Image text"></p>
<p>2、程序的结束<br>正常结束：程序按自身的逻辑有效地完成预定功能<br>后结束<br>（a）返回父程序并回送结果信息。<br>（b）释放所用资源（空间、设备），记录使用情<br>况，记帐等<br>– 异常结束：发生了某些错误而导致程序在没有完成<br>预定功能时提前结束 </p>
<p>3、用户与操作系统的接口<br>为用户提供两种接口：<br>（1）命令接口<br>用户通过这些命令来组织和控制作业的执行。<br>（2）程序接口<br>编程人员使用他们来请求操作系统服务。</p>
<p>作业控制的主要方式：<br>（1）联机命令接口<br>又称交互式命令接口，由一组键盘操作命令组<br>成。用户通过控制台或者终端键入操作命令，完<br>成对作业的控制。<br>（2）脱机命令接口<br>又称批处理命令接口，由一组作业控制语言组<br>成，由系统负责解释执行。（涉及到作业的相关<br>概念） </p>
<p>3、作 业 的 基 本 概 念<br>（1）作业<br>用户在一次计算过程中，或者一次事务处理过程中，<br>要求计算机系统所做工作的总称<br>（2）作业步<br> 一个作业可划分成若干部分，称为一个作业步<br>（3）典型的作业控制过程：<br> “编译”、“连接装配”、“运行” </p>
<p> 作业组织：<br> 作业由三部分组成，即程序、数据、作业说明书。</p>
<p> 作 业 控 制 块（JCB：Job Control Block）<br>– 作业控制块是作业存在的标志<br>– 保存现有系统对于作业进行管理所需要的全部信息<br>– 位于磁盘区域中 </p>
<p><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi5.png?raw=true" alt="Image text"></p>
<p>作 业 的 状 态 及 转 换：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi6.png?raw=true" alt="Image text"></p>
<p>4、作 业 调 度<br>调度的实质<br>• 资源的分配<br>– 调度算法定义<br>• 根据系统的资源分配策略所规定的资源分配算法</p>
<p>调 度 算 法 的 性 能 准 则：<br>– （平均）周转时间：作业从提交到完成的时间（用户角度）<br>周转时间：Ti=Tc-Ts<br>Tc作业完成时刻；<br>Ts作业进入系统时刻</p>
<p>平均周转时间：（T1+T2+…+Tn)/n</p>
<p>– （平均）带权周转时间：周转时间 / CPU运行时间（用户角度）<br>带权周转时间:<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi7.png?raw=true" alt="Image text"></p>
<p>平均带权周转时间：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi8.png?raw=true" alt="Image text"></p>
<p>– 响应时间：用户输入一个请求（如击键）到系统给出首次响应（如屏幕<br>显示）的时间（处理机的角度）<br>– 公平性：不因作业或进程本身的特性而使上述指标过分恶化（算法本身的角度）<br>– 优先级：可以使关键任务达到更好的指标（算法本身的角度）</p>
<p>5、先来先服务算法FCFS （First Come First Served）<br>– 按作业的先后顺序进行调度<br>– 处理过程<br>1）按照作业提交先后次序，分配CPU执行；<br>2）当前作业占用CPU，直到执行完或阻塞（如申请I/O）让出CPU；<br>3）作业被唤醒后（如I/O完成），不立即恢复执行，等待当前作业<br> 让出CPU后才可以恢复执行。<br>– 最简单的调度算法<br>– 对短作业不利（平均周转时间延长）</p>
<p>举例：假设在单道批处理环境下有四个作业，已知它们进入系统的时间、估计运行时间 ，求：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi9.png?raw=true" alt="Image text"></p>
<p>6、短 作 业 优 先 算 法 SJF （Shortest Job First ）<br>按作业的长短顺序进行调度，短作业优先<br>• 对预计执行时间短的作业优先分配CPU<br>• 通常后来的短作业不抢占正在执行的作业<br>– 对FCFS算法的改进，目标是减少平均周转时间</p>
<p>– 优点：<br>• 相比于FCFS改善平均周转时间和平均带权周转时间；<br>• 缩短作业的等待时间；<br>• 提高系统的吞吐量；<br>– 缺点：<br>• 对长作业非常不利，可能长时间得不到执行；<br>• 难以准确估计作业（进程）的执行时间，从而影响调度性能。<br>• 未能依据作业的紧迫程度来划分执行的优先级；</p>
<p>举例：<br>假设在单道批处理环境下有四个作业，已知它们进入系统的时间、估计运行时间 ，求：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi10.png?raw=true" alt="Image text"></p>
<p>7、最 短 剩 余 时 间 优 先 算 法 SRT （Shortest Remaining Time）<br>– 短作业优先算法的变型，也称作抢占式的短作业优先算法<br>– 允许比当前进程剩余时间更短的进程来抢占<br>– 抢占时机：新作业加入队列时 </p>
<p>8、最 高 响 应 比 优 先 算 法HRRN （Highest Response Ratio Next）<br>– 从就绪队列中选出响应比最高的作业投入执行<br>– 响应比R = (等待时间W +要求执行时间T) / 要求执行时间T<br>– FCFS和SJF的折衷</p>
<p>– 优点：既照顾了短作业，也考虑到先后顺序<br>– 缺点：每次调度时要调用响应比计算，增加了系统开销 </p>
<p>举例：假设在单道批处理环境下有四个作业，已知它们进入系统的时间、估计运行时间 ，求：<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi11.png?raw=true" alt="Image text"></p>
<p>9、基 于 优 先 数 调 度 算 法 HPF （ Highest Priority First ）<br>（a）由用户规定优先数（外部优先数）<br> 用户提交作业时，根据急迫程度规定适当的优先数<br> 作业调度程序根据JCB优先数决定进入内存的次序<br>（b）由系统计算优先数（内部优先数） </p>
<p>举例：<br>在两道环境下有四个作业，已知它们进入系统的时间、估计运行时间； 作业调度采用短作业优先调度算法（作业被调度<br>运行后直到结束前不再退出内存）； 进程调度采用最短剩余时间优先调度算法（当新作业投入运行后，可按照作业剩余运行时间长短调整次<br>序，可抢占CPU）； 请给出这四个作业的执行时间序列，并计算出平均周转时间及平均带权周转时间；<br><img src="https://github.com/Tingzi123/blog/blob/master/_posts/picture/osapi12.png?raw=true" alt="Image text"></p>
<p>10、系 统 调 用<br>系统调用，是用户在程序中调用操作系统所提供的一些子功能（程序接口）。<br>这个指令还将系统转入管态<br>系统调用是操作系统提供给编程人员的唯一接口 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/OS用户接口与作业调度/" data-id="ckcis79jb000c6cviwv9gspen" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/07/os的硬件环境/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          操作系统的硬件环境
        
      </div>
    </a>
  
  
    <a href="/2020/06/07/OS文件管理/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">操作系统-文件管理</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/10/GO：1-2-命令源码文件/">GO：1.2 命令源码文件</a>
          </li>
        
          <li>
            <a href="/2020/07/10/GO：工作区和GOPATH/">GO：工作区和GOPATH</a>
          </li>
        
          <li>
            <a href="/2020/07/02/hexo博客迁移/">hexo博客迁移</a>
          </li>
        
          <li>
            <a href="/2020/06/15/测试驱动开发TDD/">测试驱动开发TDD</a>
          </li>
        
          <li>
            <a href="/2020/06/11/go-goroutine、channel、反射/">go:goroutine、channel、反射</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>