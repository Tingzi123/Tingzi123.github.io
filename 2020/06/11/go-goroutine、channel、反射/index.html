<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>go:goroutine、channel、反射 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1、goroutine1、基本介绍1、Go协程和Go主线程  Go主线程（有的程序员直接成为线程/也可以理解成进程）：一个Go主线程上，可以起多个协程，即协程是轻量级的线程。  2、Go协程的特点  有独立的栈空间 共享程序堆空间 调度由用户控制 协程是轻量级的线程  3、案例1）在主线程（可以理解成进程），开启一个goroutine，该协程每隔一秒输出“hello world”2）在主线程中也每">
<meta property="og:type" content="article">
<meta property="og:title" content="go:goroutine、channel、反射">
<meta property="og:url" content="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1、goroutine1、基本介绍1、Go协程和Go主线程  Go主线程（有的程序员直接成为线程/也可以理解成进程）：一个Go主线程上，可以起多个协程，即协程是轻量级的线程。  2、Go协程的特点  有独立的栈空间 共享程序堆空间 调度由用户控制 协程是轻量级的线程  3、案例1）在主线程（可以理解成进程），开启一个goroutine，该协程每隔一秒输出“hello world”2）在主线程中也每">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/goroutine1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/goroutine2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/goroutine3.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/channel1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/goandchan1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/reflect1.png">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/reflect2.png">
<meta property="og:updated_time" content="2020-06-11T08:06:24.441Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go:goroutine、channel、反射">
<meta name="twitter:description" content="1、goroutine1、基本介绍1、Go协程和Go主线程  Go主线程（有的程序员直接成为线程/也可以理解成进程）：一个Go主线程上，可以起多个协程，即协程是轻量级的线程。  2、Go协程的特点  有独立的栈空间 共享程序堆空间 调度由用户控制 协程是轻量级的线程  3、案例1）在主线程（可以理解成进程），开启一个goroutine，该协程每隔一秒输出“hello world”2）在主线程中也每">
<meta name="twitter:image" content="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/goroutine1.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-go-goroutine、channel、反射" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-goroutine、channel、反射/" class="article-date">
  <time datetime="2020-06-11T07:58:15.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      go:goroutine、channel、反射
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、goroutine"><a href="#1、goroutine" class="headerlink" title="1、goroutine"></a>1、goroutine</h3><h4 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、Go协程和Go主线程</p>
<ul>
<li><strong>Go主线程</strong>（有的程序员直接成为线程/也可以理解成进程）：<strong>一个Go主线程上，可以起多个协程</strong>，即<strong>协程是轻量级的线程</strong>。</li>
</ul>
<p>2、Go协程的特点</p>
<ul>
<li>有独立的栈空间</li>
<li>共享程序堆空间</li>
<li>调度由用户控制</li>
<li>协程是轻量级的线程</li>
</ul>
<p>3、案例<br>1）在主线程（可以理解成进程），开启一个goroutine，该协程每隔一秒输出“hello world”<br>2）在主线程中也每隔一秒输出“hello world”，输出10次后，退出程序<br>3）要求主线程和goroutine同时执行<br>4）主线程和协程执行流程图</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>    </span><br><span class="line">    <span class="string">"strconv"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个函数，每隔1秒输出“hello world”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span> ;i++  &#123;   </span><br><span class="line">        fmt.Println(<span class="string">"test() hello world"</span>+strconv.Itoa(i))     </span><br><span class="line">        </span><br><span class="line">        time.Sleep(time.Second)  <span class="comment">//休眠一秒  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">go</span> test()<span class="comment">//开启一个协程    </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span> ;i++  &#123;    </span><br><span class="line">        fmt.Println(<span class="string">"main() hello world"</span>+strconv.Itoa(i))      </span><br><span class="line">        </span><br><span class="line">        time.Sleep(time.Second)     <span class="comment">//休眠一秒  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main() hello world1</span><br><span class="line">test() hello world1</span><br><span class="line">main() hello world2</span><br><span class="line">test() hello world2</span><br><span class="line">test() hello world3</span><br><span class="line">main() hello world3</span><br><span class="line">main() hello world4</span><br><span class="line">test() hello world4</span><br><span class="line">test() hello world5</span><br><span class="line">main() hello world5</span><br><span class="line">test() hello world6</span><br><span class="line">main() hello world6</span><br><span class="line">main() hello world7</span><br><span class="line">test() hello world7</span><br><span class="line">test() hello world8</span><br><span class="line">main() hello world8</span><br><span class="line">main() hello world9</span><br><span class="line">test() hello world9</span><br></pre></td></tr></table></figure></p>
<p>由输出看出，<strong>主线程main和协程test同时执行</strong></p>
<ul>
<li><p>主线程和协程执行流程图<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine1.jpg" alt="goroutine1"></p>
</li>
<li><p>程序开始执行，main主线程开始执行</p>
</li>
<li>go test()开启协程，<strong>主线程main和协程test同时执行</strong></li>
<li>程序退出以<strong>主线程</strong>为主：<pre><code>1） 如果主线程退出了，则协程即使还没有执行完毕也会退出
2）当然协程可以在主线程没有退出前，就执行完毕退出协程
</code></pre></li>
</ul>
<p>4、总结</p>
<ul>
<li><p>1）<strong>主线程</strong>是一个<strong>物理线程</strong>，<strong>直接作用在CPU上</strong>。是重量级的，非常耗费CPU资源。</p>
</li>
<li><p>2）<strong>协程从主线程开启的</strong>，是轻量级的线程，是<strong>逻辑态的</strong>。对资源消耗相对小</p>
</li>
<li><p>3）Go的协程机制是重要特点，可以轻松的开启上万个协程。（其他编程语言的开发机制一般是基于线程的，开启过多的线程，资源消耗大）</p>
</li>
</ul>
<h4 id="2、goroutine的调度模型"><a href="#2、goroutine的调度模型" class="headerlink" title="2、goroutine的调度模型"></a>2、goroutine的调度模型</h4><p>1、MPG模式基本介绍</p>
<ul>
<li>M：操作系统的主线程（是物理线程，真正干活的人）</li>
<li>P：协程执行需要的上下文环境（运行时需要的资源和运行时的状态）</li>
<li>G：协程（逻辑态的）</li>
</ul>
<p>2、MPG模式运行的状态</p>
<p>1）MPG模式运行的状态1<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine2.jpg" alt="goroutine2"></p>
<p>2）MPG模式运行的状态2<br><img src="/2020/06/11/go-goroutine、channel、反射/goroutine3.jpg" alt="goroutine3"></p>
<h4 id="3、设置运行CPU数目"><a href="#3、设置运行CPU数目" class="headerlink" title="3、设置运行CPU数目"></a>3、设置运行CPU数目</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="comment">//runtime.NumCPU()   查询系统的CPU数目</span></span><br><span class="line">    cpuNum := runtime.NumCPU()   </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"cpuNum="</span>,cpuNum)     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置使用多个CPU     </span></span><br><span class="line">    runtime.GOMAXPROCS(cpuNum<span class="number">-1</span>)     </span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"ok"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、管道channel"><a href="#2、管道channel" class="headerlink" title="2、管道channel"></a>2、管道channel</h3><p>案例：计算1-20的各个数的阶乘，并且把各个数放入map中并打印，使用goroutine完成</p>
<p>思路：</p>
<ul>
<li>1、编写一个函数，计算各个数的阶乘并放入map中</li>
<li>2、启动多个协程，统计的结果放入map中</li>
<li>3、map应该做全局的</li>
</ul>
<p>解法一：使用全局变量加锁同步<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (     </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"sync"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(  </span><br><span class="line">    myMap =<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//全局资源不加锁，会发生资源竞争，同时写会报错   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以声明一个全局互斥锁解决    </span></span><br><span class="line">    <span class="comment">//sync是一个包，synchornized 同步    </span></span><br><span class="line">    <span class="comment">//Mutex 互斥      </span></span><br><span class="line">    lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//test函数计算n的阶乘，将结果放入myMap中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(n <span class="keyword">int</span>)</span></span>&#123;    </span><br><span class="line">    res:=<span class="number">1</span>    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++&#123;      </span><br><span class="line">    res*=i  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入map前加锁    </span></span><br><span class="line">    lock.Lock()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//把结果放入myMap     </span></span><br><span class="line">    myMap[n]=res    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//写完map后解锁    </span></span><br><span class="line">    lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//这里开启20个协程，</span></span><br><span class="line">    <span class="comment">//20个协程同时向map写数据，会发生 并发map写 错误    </span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++&#123;         </span><br><span class="line">        <span class="keyword">go</span> test(i)    </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//休眠5秒钟（人为估算），让主线程等待所有的协程执行完   </span></span><br><span class="line">    time.Sleep(<span class="number">5</span>*time.Second)   </span><br><span class="line">    <span class="comment">//如果不休眠，可能main主线程已经结束退出，但是test协程还没写入map     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//互斥性资源读写都要加锁     </span></span><br><span class="line">    lock.Lock()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出结果，对map进行读操作     </span></span><br><span class="line">    <span class="keyword">for</span> i,v :=<span class="keyword">range</span> myMap&#123;           </span><br><span class="line">        fmt.Printf(<span class="string">"map[%d]=%d\n"</span>,i,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    lock.Unlock()&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="number">17</span>]=<span class="number">355687428096000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">16</span>]=<span class="number">20922789888000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">20</span>]=<span class="number">2432902008176640000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">9</span>]=<span class="number">362880</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">10</span>]=<span class="number">3628800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">12</span>]=<span class="number">479001600</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">3</span>]=<span class="number">6</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">19</span>]=<span class="number">121645100408832000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">11</span>]=<span class="number">39916800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">15</span>]=<span class="number">1307674368000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">18</span>]=<span class="number">6402373705728000</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">8</span>]=<span class="number">40320</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">5</span>]=<span class="number">120</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">7</span>]=<span class="number">5040</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">14</span>]=<span class="number">87178291200</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">13</span>]=<span class="number">6227020800</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">4</span>]=<span class="number">24</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">6</span>]=<span class="number">720</span></span><br></pre></td></tr></table></figure></p>
<p>因为map的key是无序的，所以未按递增顺序执行，而且并发执行的顺序也可能不是递增得到结果的</p>
<p>上面的解法中</p>
<ul>
<li>主线程等待所有goroutine全部完成时间很难确定，这里设置为5秒，是为估算</li>
<li>如果主线程休眠时间长了，会加长等待时间；如果等待时间短了，可能还有goroutine处于工作状态（没有执行完），这时也会随主线程的退出二销毁</li>
<li>通过全局变量加锁同步来实现协程间通讯，并不利于多个协程对全局变量的读写操作</li>
</ul>
<p>综上，我们引出一种新的通讯机制channel</p>
<p>解法二：使用channel</p>
<h4 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、channel本质上就是一个数据结构-队列</p>
<p>2、数据先进先出</p>
<p>3、<strong>线程安全</strong>，多个goroutine访问时，自己不需要再加锁，即：<strong>channel本身就是线程安全的</strong></p>
<p>4、<strong>channel是有类型的</strong>，一个string的channel只能存放string类型数据<br><img src="/2020/06/11/go-goroutine、channel、反射/channel1.jpg" alt="channel1"></p>
<h4 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h4><h5 id="1、定义-声明"><a href="#1、定义-声明" class="headerlink" title="1、定义/声明"></a>1、定义/声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 数据类型</span><br><span class="line"></span><br><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//intChan类型为int，只能存放int型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapChan <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="comment">//mapChan类型为map[int]string，只能存放map[int]string型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> perChan <span class="keyword">chan</span> Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> perChan2 <span class="keyword">chan</span> *Person</span><br></pre></td></tr></table></figure>
<p>2、注意</p>
<ul>
<li>channel是<strong>引用类型</strong></li>
<li><strong>channel必须初始化后才能写入数据，即make后才能使用</strong></li>
<li>channel是由类型的，如intChan类型为int，只能存放int型数据</li>
</ul>
<h5 id="3、管道的初始化、从管道读写数据以及注意事项"><a href="#3、管道的初始化、从管道读写数据以及注意事项" class="headerlink" title="3、管道的初始化、从管道读写数据以及注意事项"></a>3、管道的初始化、从管道读写数据以及注意事项</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">//1、创建一个可以存放3个int的管道   </span></span><br><span class="line">    <span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span>    </span><br><span class="line">    intChan=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)  <span class="comment">//channel make后才能使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、intChan是什么     </span></span><br><span class="line">    fmt.Printf(<span class="string">"intChan的值=%v intChan本身的地址=%v\n"</span>,intChan,&amp;intChan)   </span><br><span class="line">    <span class="comment">//输出：intChan的值=0xc000092080 </span></span><br><span class="line">    <span class="comment">//intChan本身的地址=0xc00008c018      </span></span><br><span class="line">    <span class="comment">//可以看出intChan的值为一个地址，所以channel是引用类型。    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、向管道写入数据     </span></span><br><span class="line">    intChan&lt;<span class="number">-10</span><span class="comment">//直接写入常量   </span></span><br><span class="line">    num:=<span class="number">211</span>     </span><br><span class="line">    intChan&lt;-num<span class="comment">//写入变量    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、看看管道的长度和容量    </span></span><br><span class="line">    <span class="comment">//容量是make时传入的，这里传入的是3，容量不能自动增长，和slice、map不一样    </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))     </span><br><span class="line">    <span class="comment">//channel len=2 cap=3    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、注意：给管道写入数据时不能超过容量     </span></span><br><span class="line">    intChan&lt;<span class="number">-50</span>      <span class="comment">//intChan&lt;-98     </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))   </span><br><span class="line">    <span class="comment">//fatal error: all goroutines are asleep - deadlock!   </span></span><br><span class="line">    <span class="comment">//报告死锁deadlock错误     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、从管道中读取数据     </span></span><br><span class="line">    <span class="keyword">var</span> num2 <span class="keyword">int</span>     </span><br><span class="line">    num2 = &lt;-intChan  </span><br><span class="line">    fmt.Println(<span class="string">"num2="</span>,num2)<span class="comment">//num2= 10，从队列头开始取     </span></span><br><span class="line">    fmt.Printf(<span class="string">"channel len=%v cap=%v\n"</span>,<span class="built_in">len</span>(intChan),<span class="built_in">cap</span>(intChan))    </span><br><span class="line">    <span class="comment">//channel len=2 cap=3     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、在没有使用协程的情况下，如果管道中的数据已经全部取出，再取数据就会报告死锁deadlock错误     </span></span><br><span class="line">    num3 := &lt;-intChan    </span><br><span class="line">    num4 := &lt;-intChan     </span><br><span class="line">    num5 := &lt;-intChan   </span><br><span class="line">    fmt.Println(<span class="string">"num3="</span>,num3,<span class="string">"num4="</span>,num4,<span class="string">"num5="</span>,num5)   </span><br><span class="line">    <span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<ul>
<li>channel中只能存放指定的数据类型</li>
<li>channel的数据放满后，就不能再放入了，否则报告死锁deadlock错误</li>
<li>当 channel的数据放满后，如果从channel中取出数据，可以再次放入数据</li>
<li>在没有使用协程的情况下，如果channel中的数据取完了，再次取数据，会报告死锁deadlock错误</li>
</ul>
<p>一个例子，当管道是空接口interface{}类型时，可以存放任意数据类型的值，取出管道中的值对象的的字段值时，需要类型断言<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123; </span><br><span class="line">    Name <span class="keyword">string</span>     </span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    allChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">3</span>)<span class="comment">//定义一个空接口类型，容量为3的管道allChan      </span></span><br><span class="line"></span><br><span class="line">    allChan&lt;<span class="number">-10</span><span class="comment">//往管道写入int类型的值     </span></span><br><span class="line">    allChan&lt;-<span class="string">"tom"</span><span class="comment">//往管道写入string类型的值    </span></span><br><span class="line"></span><br><span class="line">    cat:=Cat&#123;<span class="string">"小花猫"</span>,<span class="number">4</span>&#125;<span class="comment">//实例化一个Cat    </span></span><br><span class="line">    allChan&lt;-cat<span class="comment">////往管道写入Cat类型的值    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//想要取出管道中的第三个值，需要丢弃第一个和第二个    </span></span><br><span class="line">    &lt;-allChan    </span><br><span class="line">    &lt;-allChan    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//取到第三个   </span></span><br><span class="line">    newCat:=&lt;-allChan   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//newCat从编译层面看是空接口类型,接口类型本身没有字段    </span></span><br><span class="line">    <span class="comment">//但在运行时可动态指向结构体Cat，</span></span><br><span class="line">    <span class="comment">//下面写法语法上没错，运行时可动态指向Cat     </span></span><br><span class="line">    fmt.Printf(<span class="string">"newCat的类型=%T newCat的值=%v\n"</span>,newCat,newCat)   </span><br><span class="line">    <span class="comment">//输出：newCat的类型=main.Cat newCat的值=&#123;小花猫 4&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//newCat从编译层面看是空接口类型，接口类型本身没有字段，</span></span><br><span class="line">    <span class="comment">//直接写编译不通过，需要类型断言      </span></span><br><span class="line">    aNewCat:=newCat.(Cat)     </span><br><span class="line">    fmt.Printf(<span class="string">"newCat.Name=%v"</span>,aNewCat.Name)</span><br><span class="line">    <span class="comment">//输出：newCat.Name=小花猫</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4、管道的遍历和关闭"><a href="#4、管道的遍历和关闭" class="headerlink" title="4、管道的遍历和关闭"></a>4、管道的遍历和关闭</h5><p> 1、管道的关闭</p>
<p>使用内置函数<strong>close()可以关闭管道</strong>，当管道关闭后，就不能再向管道写数据了，但是仍然可以从管道中读取数据<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)  </span><br><span class="line">    intChan&lt;<span class="number">-100</span>   </span><br><span class="line">    intChan&lt;<span class="number">-200</span>    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、关闭管道    </span></span><br><span class="line">    <span class="built_in">close</span>(intChan)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、关闭管道后，不能再写入数据   </span></span><br><span class="line">    <span class="comment">//intChan&lt;-300    </span></span><br><span class="line">    <span class="comment">//panic: send on closed channel     </span></span><br><span class="line">    <span class="comment">//向一个关闭的通道中发送数据，panic终止程序    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、关闭管道后，可以再读取数据   </span></span><br><span class="line">    n1:=&lt;-intChan    </span><br><span class="line">    fmt.Println(<span class="string">"n1="</span>,n1)<span class="comment">//n1= 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、管道的遍历<br>channel支持for-range的方式进行遍历，有两个细节注意：</p>
<ul>
<li>在遍历时，如果channel没有关闭，则会出现死锁deadlock错误</li>
<li>在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历</li>
</ul>
<p>在遍历时不能使用普通for循环遍历，因为管道的长度（len(intChan)）是随数据出管道-1动态变化的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环往管道中写入100个数据      </span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">100</span> ;i++  &#123;       </span><br><span class="line">        intChan&lt;-i*<span class="number">2</span>   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历，一定要先关闭管道,如果不关闭管道，会出现死锁deadlock错误     </span></span><br><span class="line">    <span class="built_in">close</span>(intChan)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//管道没有下标，for-range只返回一个值    </span></span><br><span class="line">    <span class="keyword">for</span> v:= <span class="keyword">range</span> intChan&#123;         </span><br><span class="line">        fmt.Println(<span class="string">"v="</span>,v)     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、goroutine和管道channel结合使用"><a href="#3、goroutine和管道channel结合使用" class="headerlink" title="3、goroutine和管道channel结合使用"></a>3、goroutine和管道channel结合使用</h3><h4 id="1、案例："><a href="#1、案例：" class="headerlink" title="1、案例："></a>1、案例：</h4><p>案例：<br>goroutine和管道channel协同工作<br>1）开启一个wiiteData协程，向管道写入50个整数<br>2）开启一个readData协程，从管道中读取wiiteData写入的数据<br>3）注意：wiiteData和readData操作的是同一个管道<br>4）主线程需要等待wiiteData和readData协程完成工作后才能退出<br>思路图解：<br><img src="/2020/06/11/go-goroutine、channel、反射/goandchan1.jpg" alt="goandchan1"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++  &#123;   </span><br><span class="line">        intChan&lt;-i         </span><br><span class="line">        fmt.Println(<span class="string">"writeData "</span>,i)    </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(intChan)<span class="comment">//关闭intChan，后面intChan仍然可读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//readData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>,exitChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">for</span>&#123;         </span><br><span class="line">        v,ok:=&lt;-intChan      </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;       </span><br><span class="line">          <span class="keyword">break</span>     </span><br><span class="line">         &#125;         </span><br><span class="line">        fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//readData读取数据完后，    </span></span><br><span class="line">    <span class="comment">//往exitChan写入数据true，告知主线程readData执行完毕    </span></span><br><span class="line">    exitChan&lt;-<span class="literal">true</span>   </span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//创建两个管道  </span></span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">50</span>)  </span><br><span class="line">    exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)  <span class="comment">//该管道用于等到intChan管道的读取协程工作完毕后，往exitChan写入数据，标识主线程可退出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> writeData(intChan) <span class="comment">//向管道写入50个整数</span></span><br><span class="line">    <span class="keyword">go</span> readData(intChan,exitChan)   <span class="comment">//从管道中读取wiiteData写入的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>&#123;      </span><br><span class="line">        _,ok:=&lt;-exitChan    </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;            </span><br><span class="line">             <span class="keyword">break</span>       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、管道阻塞机制"><a href="#2、管道阻塞机制" class="headerlink" title="2、管道阻塞机制"></a>2、管道阻塞机制</h4><p>如果<strong>只向管道里写数据，而没有读取</strong>，就会出现<strong>阻塞而死锁</strong>deadlock。<br>注意：如果<strong>有向管道读取数据，但读取比写数据慢得多</strong>，也不会发生死锁，只要编译器检测到数据在管道中是流动的，即有读取也有写入，那么就不会发生死锁</p>
<p>下面例子中，intChan容量改为10<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++  &#123;   </span><br><span class="line">        intChan&lt;-i     <span class="comment">//数据一下就放入，但下面readData读取慢慢读</span></span><br><span class="line">    </span><br><span class="line">        fmt.Println(<span class="string">"writeData "</span>,i)    </span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(intChan)<span class="comment">//关闭intChan，后面intChan仍然可读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//readData</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(intChan <span class="keyword">chan</span> <span class="keyword">int</span>,exitChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">for</span>&#123;         </span><br><span class="line">        v,ok:=&lt;-intChan      </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;       </span><br><span class="line">          <span class="keyword">break</span>     </span><br><span class="line">         &#125;         </span><br><span class="line">       time.Sleep(time.Second)<span class="comment">//慢慢读，每隔一秒读一次</span></span><br><span class="line">       </span><br><span class="line">      fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>,v)   </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//readData读取数据完后，    </span></span><br><span class="line">    <span class="comment">//往exitChan写入数据true，告知主线程readData执行完毕    </span></span><br><span class="line">    exitChan&lt;-<span class="literal">true</span>   </span><br><span class="line">    <span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//创建两个管道  </span></span><br><span class="line">    intChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)<span class="comment">//容量10</span></span><br><span class="line">    exitChan:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)  <span class="comment">//该管道用于等到intChan管道的读取协程工作完毕后，往exitChan写入数据，标识主线程可退出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> writeData(intChan) <span class="comment">//向管道写入50个整数</span></span><br><span class="line">    <span class="keyword">go</span> readData(intChan,exitChan)   <span class="comment">//从管道中读取wiiteData写入的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>&#123;      </span><br><span class="line">        _,ok:=&lt;-exitChan    </span><br><span class="line">        <span class="keyword">if</span> !ok &#123;            </span><br><span class="line">             <span class="keyword">break</span>       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">writeData  <span class="number">1</span></span><br><span class="line">writeData  <span class="number">2</span></span><br><span class="line">writeData  <span class="number">3</span></span><br><span class="line">writeData  <span class="number">4</span></span><br><span class="line">writeData  <span class="number">5</span></span><br><span class="line">writeData  <span class="number">6</span></span><br><span class="line">writeData  <span class="number">7</span></span><br><span class="line">writeData  <span class="number">8</span></span><br><span class="line">writeData  <span class="number">9</span></span><br><span class="line">writeData  <span class="number">10</span></span><br><span class="line">writeData  <span class="number">11</span></span><br><span class="line">readData 读到数据=<span class="number">1</span></span><br><span class="line">writeData  <span class="number">12</span></span><br><span class="line">readData 读到数据=<span class="number">2</span></span><br><span class="line">writeData  <span class="number">13</span></span><br><span class="line">readData 读到数据=<span class="number">3</span></span><br><span class="line">writeData  <span class="number">14</span></span><br><span class="line">readData 读到数据=<span class="number">4</span></span><br><span class="line">writeData  <span class="number">15</span></span><br><span class="line">readData 读到数据=<span class="number">5</span></span><br><span class="line">writeData  <span class="number">16</span></span><br><span class="line">readData 读到数据=<span class="number">6</span></span><br><span class="line">writeData  <span class="number">17</span></span><br><span class="line">readData 读到数据=<span class="number">7</span></span><br><span class="line">writeData  <span class="number">18</span></span><br><span class="line">readData 读到数据=<span class="number">8</span></span><br><span class="line">writeData  <span class="number">19</span></span><br><span class="line">readData 读到数据=<span class="number">9</span></span><br><span class="line">writeData  <span class="number">20</span></span><br><span class="line">readData 读到数据=<span class="number">10</span></span><br><span class="line">writeData  <span class="number">21</span></span><br><span class="line">readData 读到数据=<span class="number">11</span></span><br><span class="line">writeData  <span class="number">22</span></span><br><span class="line">readData 读到数据=<span class="number">12</span></span><br><span class="line">writeData  <span class="number">23</span></span><br><span class="line">readData 读到数据=<span class="number">13</span></span><br><span class="line">writeData  <span class="number">24</span></span><br><span class="line">readData 读到数据=<span class="number">14</span></span><br><span class="line">writeData  <span class="number">25</span></span><br><span class="line">readData 读到数据=<span class="number">15</span></span><br><span class="line">writeData  <span class="number">26</span></span><br><span class="line">readData 读到数据=<span class="number">16</span></span><br><span class="line">writeData  <span class="number">27</span></span><br><span class="line">readData 读到数据=<span class="number">17</span></span><br><span class="line">writeData  <span class="number">28</span></span><br><span class="line">readData 读到数据=<span class="number">18</span></span><br><span class="line">writeData  <span class="number">29</span></span><br><span class="line">readData 读到数据=<span class="number">19</span></span><br><span class="line">writeData  <span class="number">30</span></span><br><span class="line">readData 读到数据=<span class="number">20</span></span><br><span class="line">writeData  <span class="number">31</span></span><br><span class="line">readData 读到数据=<span class="number">21</span></span><br><span class="line">writeData  <span class="number">32</span></span><br><span class="line">readData 读到数据=<span class="number">22</span></span><br><span class="line">writeData  <span class="number">33</span></span><br><span class="line">readData 读到数据=<span class="number">23</span></span><br><span class="line">writeData  <span class="number">34</span></span><br><span class="line">readData 读到数据=<span class="number">24</span></span><br><span class="line">writeData  <span class="number">35</span></span><br><span class="line">readData 读到数据=<span class="number">25</span></span><br><span class="line">writeData  <span class="number">36</span></span><br><span class="line">readData 读到数据=<span class="number">26</span></span><br><span class="line">writeData  <span class="number">37</span></span><br><span class="line">readData 读到数据=<span class="number">27</span></span><br><span class="line">writeData  <span class="number">38</span></span><br><span class="line">readData 读到数据=<span class="number">28</span></span><br><span class="line">writeData  <span class="number">39</span></span><br><span class="line">readData 读到数据=<span class="number">29</span></span><br><span class="line">writeData  <span class="number">40</span></span><br><span class="line">readData 读到数据=<span class="number">30</span></span><br><span class="line">writeData  <span class="number">41</span></span><br><span class="line">readData 读到数据=<span class="number">31</span></span><br><span class="line">writeData  <span class="number">42</span></span><br><span class="line">readData 读到数据=<span class="number">32</span></span><br><span class="line">writeData  <span class="number">43</span></span><br><span class="line">readData 读到数据=<span class="number">33</span></span><br><span class="line">writeData  <span class="number">44</span></span><br><span class="line">readData 读到数据=<span class="number">34</span></span><br><span class="line">writeData  <span class="number">45</span></span><br><span class="line">readData 读到数据=<span class="number">35</span></span><br><span class="line">writeData  <span class="number">46</span></span><br><span class="line">readData 读到数据=<span class="number">36</span></span><br><span class="line">writeData  <span class="number">47</span></span><br><span class="line">readData 读到数据=<span class="number">37</span></span><br><span class="line">writeData  <span class="number">48</span></span><br><span class="line">readData 读到数据=<span class="number">38</span></span><br><span class="line">writeData  <span class="number">49</span></span><br><span class="line">readData 读到数据=<span class="number">39</span></span><br><span class="line">writeData  <span class="number">50</span></span><br><span class="line">readData 读到数据=<span class="number">40</span></span><br><span class="line">readData 读到数据=<span class="number">41</span></span><br><span class="line">readData 读到数据=<span class="number">42</span></span><br><span class="line">readData 读到数据=<span class="number">43</span></span><br><span class="line">readData 读到数据=<span class="number">44</span></span><br><span class="line">readData 读到数据=<span class="number">45</span></span><br><span class="line">readData 读到数据=<span class="number">46</span></span><br><span class="line">readData 读到数据=<span class="number">47</span></span><br><span class="line">readData 读到数据=<span class="number">48</span></span><br><span class="line">readData 读到数据=<span class="number">49</span></span><br><span class="line">readData 读到数据=<span class="number">50</span></span><br></pre></td></tr></table></figure></p>
<p>因为管道容量为10，所以写到11的时候，需要等待数据被读出才能写入，所以写数据12-50与读取是交错的，读取数据每隔一秒读取一次。最后数据全部写完，只需要读取数据。</p>
<h4 id="3、细节"><a href="#3、细节" class="headerlink" title="3、细节"></a>3、细节</h4><p>1、在默认情况下，管道是双向的，即可读可写<br>2、管道可以声明为只读或只写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管道声明为只写</span></span><br><span class="line"><span class="keyword">var</span> chan1 <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">chan1 &lt;- <span class="number">1</span> <span class="comment">//ok</span></span><br><span class="line">num1 := &lt;-chan1 <span class="comment">//error，无效的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管道声明为只读</span></span><br><span class="line"><span class="keyword">var</span> chan2 &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">num2 := &lt;-chan2 <span class="comment">//ok</span></span><br><span class="line">chan2 &lt;- <span class="number">2</span> <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>管道声明为只读或只写的应用场景：</p>
<ul>
<li>先声明一个双向管道intChan</li>
<li>声明两个函数，一个往intChan只写数据的send函数，一个往intChan只读数据的recv函数，防止误操作</li>
<li>可以将双向管道intChan作为实参，传给只写数据的send函数，send函数形参为<strong>ch chan&lt;- int</strong></li>
<li>可以将双向管道intChan作为实参，传给只读数据的recv函数，re函数形参为<strong>ch &lt;-chan int</strong></li>
<li>上面所述中，将双向管道作为实参传给单向管道（只读或只写）并不会报错。</li>
<li>管道的双向和单向只是管道的性质，但是管道的类型都是chan int，所以不会报错</li>
</ul>
<p>3、使用<strong>select</strong>可以解决<strong>从管道取数据的阻塞问题</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="comment">//使用select可以解决从管道取数据的阻塞问题     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、定义一个管道 10个数据 int     </span></span><br><span class="line">    intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++  &#123;     </span><br><span class="line">         intChan&lt;-i     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、定义一个管道 5个数据，string     </span></span><br><span class="line">    stringChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">5</span>)    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span> ;i++  &#123;   </span><br><span class="line">         stringChan&lt;-<span class="string">"hello"</span>+fmt.Sprintf(<span class="string">"%d"</span>,i)  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统方法在遍历管道时，如果不关闭会阻塞并死锁deadlock   </span></span><br><span class="line">    <span class="comment">//但在实际开发中，我们往往不确定关闭管道的时机    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由此我们使用select解决      </span></span><br><span class="line">    <span class="keyword">for</span>&#123;          </span><br><span class="line">        <span class="keyword">select</span> &#123;          </span><br><span class="line">        <span class="comment">//重点：这里如果intChan一直没有关闭，不会一直阻塞而死锁，                </span></span><br><span class="line">        <span class="comment">//会自动到下一个case匹配         </span></span><br><span class="line">            <span class="keyword">case</span> v:=&lt;-intChan:              </span><br><span class="line">            fmt.Printf(<span class="string">"从intChan读取了数据%d\n"</span>,v)         </span><br><span class="line">            <span class="keyword">case</span> v:=&lt;-stringChan:                   </span><br><span class="line">            fmt.Printf(<span class="string">"从stringChan读取了数据%s\n"</span>,v)              </span><br><span class="line">            <span class="keyword">default</span>:                     </span><br><span class="line">            fmt.Printf(<span class="string">"都取不到了，加入处理逻辑\n"</span>)                    </span><br><span class="line">            <span class="keyword">return</span>        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">从stringChan读取了数据hello0</span><br><span class="line">从intChan读取了数据<span class="number">0</span></span><br><span class="line">从stringChan读取了数据hello1</span><br><span class="line">从stringChan读取了数据hello2</span><br><span class="line">从stringChan读取了数据hello3</span><br><span class="line">从intChan读取了数据<span class="number">1</span></span><br><span class="line">从intChan读取了数据<span class="number">2</span></span><br><span class="line">从stringChan读取了数据hello4</span><br><span class="line">从intChan读取了数据<span class="number">3</span></span><br><span class="line">从intChan读取了数据<span class="number">4</span></span><br><span class="line">从intChan读取了数据<span class="number">5</span></span><br><span class="line">从intChan读取了数据<span class="number">6</span></span><br><span class="line">从intChan读取了数据<span class="number">7</span></span><br><span class="line">从intChan读取了数据<span class="number">8</span></span><br><span class="line">从intChan读取了数据<span class="number">9</span></span><br><span class="line">都取不到了，加入处理逻辑</span><br></pre></td></tr></table></figure></p>
<p>4、<strong>goroutine中使用recover，解决协程中出现panic</strong>，导致程序崩溃问题</p>
<ul>
<li><p>如果我们起了一个协程，但是这个协程出现了panic，如果我们没有捕获这个panic，就会造成成哥程序的崩溃，</p>
</li>
<li><p>这时可以在该协程中使用recover来捕获panic进行处理。这样即使这个协程发生问题，主线程仍然不受影响，继续执行。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数sayHello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;           </span><br><span class="line">        time.Sleep(time.Second)    </span><br><span class="line">        fmt.Println(<span class="string">"hello world"</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="comment">//这里使用defer+recover解决panic终止程序    </span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;           </span><br><span class="line">    <span class="comment">//捕获test抛出的panic         </span></span><br><span class="line">        <span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span> &#123;            </span><br><span class="line">              fmt.Println(<span class="string">"test() 发生错误"</span>)   </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个map  </span></span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>     </span><br><span class="line">    myMap[<span class="number">0</span>]=<span class="string">"golang"</span><span class="comment">//空map直接赋值，报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="keyword">go</span> sayHello()    </span><br><span class="line">    <span class="keyword">go</span> test()   <span class="comment">//这个协程会panic 使用defer+recover解决</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;       </span><br><span class="line">        time.Sleep(time.Second)       </span><br><span class="line">        fmt.Println(<span class="string">"main() ok="</span>,i)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">test() 发生错误</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">0</span></span><br><span class="line">main() ok= <span class="number">1</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">2</span></span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">3</span></span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">4</span></span><br><span class="line">main() ok= <span class="number">5</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">6</span></span><br><span class="line">main() ok= <span class="number">7</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">main() ok= <span class="number">8</span></span><br><span class="line">main() ok= <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>由输出看出，test协程出错，但是主线程和sayHello协程继续执行</p>
<h3 id="4、反射"><a href="#4、反射" class="headerlink" title="4、反射"></a>4、反射</h3><h4 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h4><p>1、反射的作用：</p>
<ul>
<li><p>1）、反射可以在运行时动态获取变量的各种信息，如变量的类型（type）、类别（kind）</p>
</li>
<li><p>2）、如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段、方法）</p>
</li>
<li><p>3）、通过反射，可以修改变量的值，可以调用关联的方法</p>
</li>
<li><p>4）、使用反射，需要import（“reflect”）</p>
</li>
</ul>
<p>reflect实现了运行时反射，允许程序操作任意类型的对象，典型用法是用静态类型interface{}保存一个值，通过<strong>调用TypeOf获取类型信息</strong>，该函数返回一个Type类型值，<strong>调用ValueOf函数返回一个value类型值</strong>，该值代表运行时数据，Zero接受一个Type类型参数并返回该类型零值的value类型值。</p>
<ul>
<li>5）、反射示意图</li>
</ul>
<p><img src="/2020/06/11/go-goroutine、channel、反射/reflect1.png" alt="reflect1"></p>
<p><strong>reflect.Type是一个接口</strong>，定义了非常多方法，通过这些方法可以反向操作变量，获取变量的各种信息</p>
<p><strong>reflect.Value是一个结构体</strong>，包含了非常多方法，可通过Type()方法将Value转换为Type、返回变量的字段和方法等等</p>
<ul>
<li>6）、变量、interface{}和reflect.Value是可以相互转换的<br><img src="/2020/06/11/go-goroutine、channel、反射/reflect2.png" alt="reflect2"></li>
</ul>
<h4 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h4><p>1、对基本数据类型、interface{}、reflect.Value进行反射的基本操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (     </span><br><span class="line">    <span class="string">"fmt"</span>   </span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//通过反射获取传入变量的type、kind、值     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、先获取到reflect.Type     </span></span><br><span class="line">    rTyp := reflect.TypeOf(b)     </span><br><span class="line">    fmt.Println(<span class="string">"rTyp="</span>,rTyp)     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取到reflect.Value     </span></span><br><span class="line">    rVal := reflect.ValueOf(b)<span class="comment">//rVal=100      </span></span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)     </span><br><span class="line">    <span class="comment">//n:=rVal+2 </span></span><br><span class="line">    <span class="comment">//error，rVal的类型不是int，是reflect.Value，不能做运算    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、如果要做运算，如下      </span></span><br><span class="line">    n:=rVal.Int()+<span class="number">2</span>     </span><br><span class="line">    fmt.Println(<span class="string">"n="</span>,n)    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、将rval转成interface&#123;&#125;      </span></span><br><span class="line">    iv:=rVal.Interface()     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、将interface&#123;&#125;通过断言转成int(对应的类型)    </span></span><br><span class="line">    num2:=iv.(<span class="keyword">int</span>)     </span><br><span class="line">    fmt.Printf(<span class="string">"num2=%v num2的type=%T\n"</span>,num2,num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="comment">//1、定义一个int     </span></span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span>     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、反射</span></span><br><span class="line">    reflectTest01(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rTyp= <span class="keyword">int</span></span><br><span class="line">rVal=<span class="number">100</span> rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">n= <span class="number">102</span></span><br><span class="line">num2=<span class="number">100</span> num2的<span class="keyword">type</span>=<span class="keyword">int</span></span><br></pre></td></tr></table></figure></p>
<p>2、对结构体、interface{}、reflect.Value进行反射的基本操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Name <span class="keyword">string</span>     </span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对结构体反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest02</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//通过反射获取传入变量的type、kind、值     </span></span><br><span class="line">    <span class="comment">//1、先获取到reflect.Type   </span></span><br><span class="line">    rTyp := reflect.TypeOf(b)    </span><br><span class="line">    fmt.Println(<span class="string">"rTyp="</span>,rTyp)   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取到reflect.Value     </span></span><br><span class="line">    rVal := reflect.ValueOf(b)   </span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、获取变量对应的kind，两种方式等价</span></span><br><span class="line">    <span class="comment">//(1)通过获取到的reflect.Type来获取 =》rTyp.Kind()</span></span><br><span class="line">    kind1:=rTyp.Kind()</span><br><span class="line">    <span class="comment">//(2)通过获取到的reflect.Value来获取 =》rVal.Kind()</span></span><br><span class="line">   kind2:=rVal.Kind()</span><br><span class="line">   fmt.Printf(<span class="string">"kind1=%v kind2=%v\n"</span>,kind1,kind2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、将rval转成interface&#123;&#125;     </span></span><br><span class="line">    iv:=rVal.Interface()     </span><br><span class="line">    fmt.Printf(<span class="string">"iv=%v iv的type=%T\n"</span>,iv,iv)  </span><br><span class="line">    <span class="comment">//输出：iv=&#123;tom 20&#125; iv的type=main.Student   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、iv的type=main.Student，但是通过iv取字段会报错     </span></span><br><span class="line">    <span class="comment">//iv.Name     </span></span><br><span class="line">    <span class="comment">//error 因为编译器在编译阶段无法知道iv的类型是main.Student，只有运行时才知道     </span></span><br><span class="line">    <span class="comment">//所以这里直接编译报错    </span></span><br><span class="line">    <span class="comment">//反射是在程序运行时工作的    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、将interface&#123;&#125;通过断言转成int(对应的类型)    </span></span><br><span class="line">    stu:=iv.(Student)    </span><br><span class="line">    <span class="keyword">if</span> ok &#123;     </span><br><span class="line">        fmt.Printf(<span class="string">"stu=%v stu的type=%T\n"</span>,stu,stu)    </span><br><span class="line">        fmt.Printf(<span class="string">"stu.Name=%v stu.Age=%v\n"</span>,stu.Name,stu.Age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//1、定义一个student实例   </span></span><br><span class="line">    stu:=Student&#123;<span class="string">"tom"</span>,<span class="number">20</span>&#125;     </span><br><span class="line">    <span class="comment">//2、反射   </span></span><br><span class="line">    reflectTest02(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rTyp= main.Student</span><br><span class="line">rVal=&#123;tom <span class="number">20</span>&#125; rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">kind1=<span class="keyword">struct</span> kind2=<span class="keyword">struct</span></span><br><span class="line">iv=&#123;tom <span class="number">20</span>&#125; iv的<span class="keyword">type</span>=main.Student</span><br><span class="line">stu=&#123;tom <span class="number">20</span>&#125; stu的<span class="keyword">type</span>=main.Student</span><br><span class="line">stu.Name=tom stu.Age=<span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h4><p>1、reflect.Value.Kind()，获取变量的类别，返回一个常量。type是一个大范畴，kind在type上细分（如type只返回int，kind返回具体的int32，int64的常量定义的值等）<br>在上面的例子中有：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、获取变量对应的kind，两种方式等价</span></span><br><span class="line">    <span class="comment">//(1)通过获取到的reflect.Type来获取 =》rTyp.Kind()</span></span><br><span class="line">    kind1:=rTyp.Kind()</span><br><span class="line">    <span class="comment">//(2)通过获取到的reflect.Value来获取 =》rVal.Kind()</span></span><br><span class="line">   kind2:=rVal.Kind()</span><br><span class="line">   fmt.Printf(<span class="string">"kind1=%v kind2=%v\n"</span>,kind1,kind2)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kind1=<span class="keyword">struct</span> kind2=<span class="keyword">struct</span></span><br></pre></td></tr></table></figure></p>
<p>2、Type和Kind的区别：Type是类型，Kind是类别，<strong>Type和Kind可能相同也可能不同</strong></p>
<ul>
<li>var num int = 10 num的Type是int，Kind也是int</li>
<li>var stu Student   stu的Type是<strong>包名.Student</strong>，Kind是struct</li>
</ul>
<p>3、变量、interface{}和reflect.Value是可以相互转换的</p>
<p>4、使用反射的方式来获取变量的值（并返回对应的类型），要求数据类型匹配，如x是int，那么就应该用reflect.ValueOf(x).Int()，不能使用其他，否则panic</p>
<p>5、通过反射修改变量的值，注意当使用SetXXX方法来修改变量的值，需要通过变量对应的指针来修改，这时需要使用reflect.Value.Elem()方法</p>
<ul>
<li><p>func (v Value) SetXXX(x XXX)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">SetXXX</span><span class="params">(x XXX)</span></span> </span><br><span class="line"><span class="comment">//SetXXX方法是和Value类型绑定的方法，不能用指针类型去调用它，只能把指针类型再转为Value类型，使用Elem函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>func (v Value) Elem() Value   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"> <span class="comment">//重点：Elem返回v持有的接口保管的值的Value类型封装，或持有的指针指向的值的Value类型封装</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line"><span class="string">"fmt"</span>    </span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改反射变量的值    </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest01</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;    </span><br><span class="line">    <span class="comment">//1、获取到reflect.Value  </span></span><br><span class="line">    rVal := reflect.ValueOf(b)<span class="comment">//rVal=100    </span></span><br><span class="line">    fmt.Printf(<span class="string">"rVal=%v rVal的type=%T\n"</span>,rVal,rVal)  </span><br><span class="line">    <span class="comment">//main函数中调用函数时传的是地址，rVal的值为一个地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取rVal的Kind    </span></span><br><span class="line">    rKind:=rVal.Kind()  </span><br><span class="line">    fmt.Printf(<span class="string">"rVal Kind=%v\n"</span>,rKind)   </span><br><span class="line">    <span class="comment">//输出：rVal Kind=ptr，</span></span><br><span class="line">    <span class="comment">//rVal的Kind是指针，因为main函数中调用函数时传的是地址     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、通过SetXXX修改变量的值    </span></span><br><span class="line">    <span class="comment">//rVal.SetInt(20) //error   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//func (v Value) SetXXX(x XXX)，  </span></span><br><span class="line">    <span class="comment">//SetXXX方法是和Value类型绑定的方法，不能用指针类型去调用它    </span></span><br><span class="line">    <span class="comment">//只能把指针类型再转为Value类型，使用Elem函数    </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//func (v Value) Elem() Value   </span></span><br><span class="line">    <span class="comment">//Elem返回v持有的接口保管的值的Value类型封装，或持有的指针指向的值的Value类型封装     </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、通过Elem()获取到指针指向的值，再通过SetXXX修改变量的值     </span></span><br><span class="line">    rVal.Elem().SetInt(<span class="number">20</span>)    <span class="comment">//值修改为20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;     </span><br><span class="line">    <span class="comment">//1、定义一个int    </span></span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span>     </span><br><span class="line">    <span class="comment">//2、反射    </span></span><br><span class="line">    reflectTest01(&amp;num)<span class="comment">//修改变量num的值，所以要穿num的地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、打印修改后的num</span></span><br><span class="line">    fmt.Println(<span class="string">"num="</span>,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rVal=<span class="number">0xc000060058</span> rVal的<span class="keyword">type</span>=reflect.Value</span><br><span class="line">rVal Kind=ptr</span><br><span class="line">num= <span class="number">20</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-goroutine、channel、反射/" data-id="ckgw4pbej002trwviq6iyal2w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/15/测试驱动开发TDD/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          测试驱动开发TDD
        
      </div>
    </a>
  
  
    <a href="/2020/06/11/go-文件操作、json/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">go:文件操作、json</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/30/微服务：7-1-1-服务配置总线-SpringCloud-Bus/">微服务：7-1-1 服务总线-SpringCloud Bus</a>
          </li>
        
          <li>
            <a href="/2020/10/30/微服务：6-1-1-服务配置-SpringCloud-Config/">微服务：6-1-1 服务配置-SpringCloud Config</a>
          </li>
        
          <li>
            <a href="/2020/10/29/微服务：5-1-1-服务网关-Gateway/">微服务：5-1-1 服务网关-Gateway</a>
          </li>
        
          <li>
            <a href="/2020/10/28/微服务：4-1-1-服务降级-Hystrix/">微服务：4-1-1 服务降级-Hystrix</a>
          </li>
        
          <li>
            <a href="/2020/10/27/微服务：3-1-2-服务调用-OpenFeign/">微服务：3-1-2 服务调用-OpenFeign</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>