<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>go:错误处理机制、数组、切片、map | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1、go错误处理机制1、Go引入处理方式：defer、panic、recover，通常三者结合使用2、这几个异常使用场景简单描述：Go中可以抛出一个panic异常，然后在defer中通过recover捕获这个异常，然后正常处理示例：1234567891011func test()&amp;#123;    num1 := 10    num2 := 0    res := num1/num2  //会报错">
<meta property="og:type" content="article">
<meta property="og:title" content="go:错误处理机制、数组、切片、map">
<meta property="og:url" content="http://yoursite.com/2020/06/11/go-错误处理机制、数组、切片、map/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1、go错误处理机制1、Go引入处理方式：defer、panic、recover，通常三者结合使用2、这几个异常使用场景简单描述：Go中可以抛出一个panic异常，然后在defer中通过recover捕获这个异常，然后正常处理示例：1234567891011func test()&amp;#123;    num1 := 10    num2 := 0    res := num1/num2  //会报错">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-错误处理机制、数组、切片、map/slice1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/06/11/go-错误处理机制、数组、切片、map/slice2.jpg">
<meta property="og:updated_time" content="2020-06-11T07:34:19.349Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go:错误处理机制、数组、切片、map">
<meta name="twitter:description" content="1、go错误处理机制1、Go引入处理方式：defer、panic、recover，通常三者结合使用2、这几个异常使用场景简单描述：Go中可以抛出一个panic异常，然后在defer中通过recover捕获这个异常，然后正常处理示例：1234567891011func test()&amp;#123;    num1 := 10    num2 := 0    res := num1/num2  //会报错">
<meta name="twitter:image" content="http://yoursite.com/2020/06/11/go-错误处理机制、数组、切片、map/slice1.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-go-错误处理机制、数组、切片、map" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/go-错误处理机制、数组、切片、map/" class="article-date">
  <time datetime="2020-06-11T07:29:33.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      go:错误处理机制、数组、切片、map
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、go错误处理机制"><a href="#1、go错误处理机制" class="headerlink" title="1、go错误处理机制"></a>1、go错误处理机制</h3><p>1、Go引入处理方式：<strong>defer、panic、recover</strong>，通常三者结合使用<br>2、这几个异常使用场景简单描述：Go中可以抛出一个panic异常，然后在defer中通过recover捕获这个异常，然后正常处理<br>示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num1 := <span class="number">10</span></span><br><span class="line">    num2 := <span class="number">0</span></span><br><span class="line">    res := num1/num2  <span class="comment">//会报错，10/0错误，0不可以作为除数</span></span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     test()<span class="comment">//test函数报错，下面的代码不会执行</span></span><br><span class="line">     fmt.Println(<span class="string">"main下面的代码"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异常处理：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用defer+recover结合捕获并处理异常</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        err :=<span class="built_in">recover</span>()<span class="comment">//recover()是一个内置函数，可以捕获异常</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;<span class="comment">//如果捕获到异常</span></span><br><span class="line">             fmt.Println(<span class="string">"err="</span>,err)</span><br><span class="line">             <span class="comment">//这里可以把错误信息发送给管理员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()<span class="comment">//这里调用defer后的匿名函数</span></span><br><span class="line">    num1 := <span class="number">10</span></span><br><span class="line">    num2 := <span class="number">0</span></span><br><span class="line">    res := num1/num2  <span class="comment">//会报错，10/0错误，0不可以作为除数</span></span><br><span class="line">    fmt.Println(<span class="string">"res="</span>,res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test()<span class="comment">//defer+recover结合捕获并处理异常后，使得下面的代码可以执行</span></span><br><span class="line">     fmt.Println(<span class="string">"main下面的代码"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h5><p>1、Go支持自定义错误，使用<strong>errors.New</strong>和<strong>panic</strong>内置函数<br>1）errors.New（“错误说明”），返回一个<strong>error</strong>类型的值，表示一个错误<br>2）panic内置函数，接收一个空接口interface{}类型的值（即任何值）作为参数。可以接收error类型的变量，输出错误信息，并退出程序。<br>例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数读取配置文件init.conf的信息</span></span><br><span class="line"><span class="comment">//如果文件名传入不正确，返回一个自定义错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> name == <span class="string">"init.conf"</span>&#123;<span class="comment">//如果捕获到异常</span></span><br><span class="line">             <span class="comment">//读取...</span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//返回一个自定义错误</span></span><br><span class="line">             <span class="keyword">return</span> errors.New(<span class="string">"读取文件错误"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := readConf(init.conf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">             <span class="comment">//如果发生错误，输出错误，并终止程序</span></span><br><span class="line">             <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">     fmt.Println(<span class="string">"test后面的代码"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     test()<span class="comment">//test函数如果发生读取文件错误，panic会终止程序，下面的代码不会执行</span></span><br><span class="line">     fmt.Println(<span class="string">"main下面的代码"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、数组"><a href="#2、数组" class="headerlink" title="2、数组"></a>2、数组</h3><p>1、数组可以存放多个同一类型数据。数组也是一种数据类型，Go中，数组是<strong>值类型</strong><br>2、四种初始化数组方式<br>如果定义时不赋值，则会被系统赋默认值</p>
<ul>
<li><p>1）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2）var arr时不指定类型，类型推导</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3）用“…”代替数组大小</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4）指定元素值的下标</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>:<span class="string">"tom"</span>,<span class="number">2</span>:<span class="string">"jack"</span>,<span class="number">0</span>:<span class="string">"marry"</span>&#125;<span class="comment">//顺序可乱序，输出按下标输出</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3、数组遍历"><a href="#3、数组遍历" class="headerlink" title="3、数组遍历"></a>3、数组遍历</h5><p>1、常规for循环遍历<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr);i++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"arr[%d]=%v\n]"</span>,i,arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、for-range结构遍历<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value := <span class="keyword">range</span> arr&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"i=%v,v=%v\n"</span>,index,value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4、数组使用细节"><a href="#4、数组使用细节" class="headerlink" title="4、数组使用细节"></a>4、数组使用细节</h5><p>1、var arr []int，这时arr是一个slice切片<br>2、Go数组属于值类型，默认情况下是值传递，进行值拷贝，数组间不会互相影响<br>3、如想在其他函数中修改原来的数组，可以使用引用传递（指针方式，传数组地址）<br>4、<strong>长度是数组类型的一部分</strong>，在传递函数参数时，需要考虑数组长度<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">     fmt.Println(<span class="string">"modify的arr"</span>,arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr =[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    modify(arr)<span class="comment">//这里编译错误，因为认为main函数中的[3]int与modify函数中的形参[]int不是同一类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、切片"><a href="#3、切片" class="headerlink" title="3、切片"></a>3、切片</h3><p>1、切片是数组的一个引用，因此数组时引用类型，传递方式是引用传递<br>2、切片的长度可以变化，因此切片是一个动态数组<br>3、切片的使用和数组类似，遍历、访问切片的元素和求切片长度len（slice）都一样<br>3、切片定义的基本语法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span><span class="comment">//与数组不同的是，【】中不需要填入大小或“...”</span></span><br></pre></td></tr></table></figure></p>
<p>4、示例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个数组</span></span><br><span class="line"><span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">66</span>,<span class="number">99</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// intArr[1:3]表示切片slice从intArr这个数组的下标为1的元素开始引用，到下标为3的元素，但不包含标为3的元素</span></span><br><span class="line">slice := intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(<span class="string">"slice的元素："</span>，slice)              <span class="comment">//[22,33]</span></span><br><span class="line">fmt.Println(<span class="string">"slice的元素个数："</span>，<span class="built_in">len</span>(slice))   <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="string">"slice的容量："</span>，<span class="built_in">cap</span>(slice))        <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片的容量可以动态变化</span></span><br></pre></td></tr></table></figure></p>
<h5 id="1、切片在内存中的布局"><a href="#1、切片在内存中的布局" class="headerlink" title="1、切片在内存中的布局"></a>1、切片在内存中的布局</h5><p><img src="/2020/06/11/go-错误处理机制、数组、切片、map/slice1.jpg" alt="slice1"></p>
<p>由上图可以看出<br>1、slice是一个引用类型<br>2、slice从底层来说是一个结构体是struct，由三部分构成<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">    ptr *[<span class="number">2</span>]intArr  <span class="comment">//指向切片第一个元素的地址</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span>         <span class="comment">//长度</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span>         <span class="comment">//容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于slice是引用类型，所以通过slice去修改引用到的intArr数组中的值，intArr本身的值也会发生改变</p>
<h5 id="2、切片使用的三种方式"><a href="#2、切片使用的三种方式" class="headerlink" title="2、切片使用的三种方式"></a>2、切片使用的三种方式</h5><p>1、定义一个切片，然后让切片去引用一个已经创建好的数组，如上所示<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个数组</span></span><br><span class="line"><span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">66</span>,<span class="number">99</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// intArr[1:3]表示切片slice从intArr这个数组的下标为1的元素开始引用，到下标为3的元素，但不包含标为3的元素</span></span><br><span class="line">slice := intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(<span class="string">"slice的元素："</span>，slice)              <span class="comment">//[22,33]</span></span><br><span class="line">fmt.Println(<span class="string">"slice的元素个数："</span>，<span class="built_in">len</span>(slice))   <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="string">"slice的容量："</span>，<span class="built_in">cap</span>(slice))        <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片的容量可以动态变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//几种引用数组元素写法</span></span><br><span class="line">slice1 := intArr[:<span class="number">3</span>] <span class="comment">//等价于intArr[0:3]  1,22,33</span></span><br><span class="line">slice2 := intArr[<span class="number">1</span>:] <span class="comment">//等价于intArr[1:len(intArr)]  22,33,66,99</span></span><br><span class="line">slice1 := intArr[:] <span class="comment">//等价于intArr[0:len(intArr)]  1,22,33,66,99</span></span><br></pre></td></tr></table></figure></p>
<p>2、通过make来创建切片<br>基本语法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">//cap可选参数，cap&gt;=len</span></span><br></pre></td></tr></table></figure></p>
<p>使用案例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">float64</span></span><br><span class="line"><span class="comment">//对于切片，必须make后使用</span></span><br><span class="line">fmt.Println(<span class="string">"slice="</span>，slice)<span class="comment">//输出[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//make后</span></span><br><span class="line">slice = <span class="built_in">make</span>([]<span class="keyword">float64</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="string">"slice="</span>，slice)<span class="comment">//输出[0,0,0,0,0],默认值为0</span></span><br></pre></td></tr></table></figure></p>
<p>3、定义切片时直接指定具体数组<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>方式1创建切片的方式是直接引用一个事先定义好的数组，程序员对这个数组可见</li>
<li>方式2通过make方式创建切片，<strong>make也会创建一个数组，由切片在底层进行维护，程序员不可见</strong></li>
<li><strong>切片定义完之后，还不能直接使用</strong>，这时是一个空切片【】，需要引用到一个数组或者make一个空间来使用</li>
<li>切片可以再切片</li>
</ul>
<h5 id="3、切片的遍历"><a href="#3、切片的遍历" class="headerlink" title="3、切片的遍历"></a>3、切片的遍历</h5><p>1、for循环<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//20,20,30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;<span class="built_in">len</span>(slice);i++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"slice[%v]=%v "</span>,i,slice[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、for-range<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//20,20,30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> slice&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"i=%v v=%v\n"</span>,i,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4、切片的使用注意事项"><a href="#4、切片的使用注意事项" class="headerlink" title="4、切片的使用注意事项"></a>4、切片的使用注意事项</h5><p>1、<strong>切片定义完之后，还不能直接使用</strong>，这时是一个空切片【】，需要引用到一个数组或者make一个空间来使用</p>
<p>2、切片可以再切片</p>
<p>3、用<strong>append</strong>内置函数，可以对切片动态追加<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>&#125;</span><br><span class="line"><span class="comment">//通过append直接给切片slice追加具体的值，数据类型需匹配</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">400</span>)</span><br><span class="line"><span class="comment">//append操作后，会生成一个新数组，需要将append后的值赋给slice，保证slice引用到append操作后的新数组</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">500</span>)</span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">600</span>,<span class="number">700</span>,<span class="number">800</span>)<span class="comment">//一次追加多个</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice,slice...)<span class="comment">//直接追加一个切片</span></span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>append操作的本质就是对数组扩容</li>
<li>go底层会创建一个新的数组newArr，将slice原来包含的元素拷贝到新数组newArr中，slice再重新引用数组newArr</li>
<li>数组newArr在底层维护，程序员不可见</li>
</ul>
<p>4、用<strong>copy</strong>内置函数，可以对切片拷贝<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(slice)<span class="comment">//输出[0,0,0,0,0,0,0,0,0,0]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(slice,a)<span class="comment">//将切片a的值拷贝到slice中</span></span><br><span class="line">fmt.Println(slice)<span class="comment">//输出【1，2，3，4，5，0，0，0，0，0】</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>copy操作需要两个参数都是切片，只能从切片拷贝到切片</li>
<li>上面代码中，切片a与slice的数据空间是独立的，互不影响</li>
<li>将切片a拷贝到slice，slice的长度小于a也是正确的</li>
<li>切片是引用类型，在传递时遵守引用传递机制</li>
</ul>
<h5 id="5、slice与string"><a href="#5、slice与string" class="headerlink" title="5、slice与string"></a>5、slice与string</h5><p>1、string底层是一个byte数组，因此string也可以进行切片处理操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello world"</span></span><br><span class="line"><span class="comment">//使用切片获取到world</span></span><br><span class="line">slice := str[<span class="number">6</span>:]</span><br><span class="line">fmt.Println(slice)<span class="comment">//输出world</span></span><br></pre></td></tr></table></figure></p>
<p>2、string在内存中的形式，以串“abcd”为例<br><img src="/2020/06/11/go-错误处理机制、数组、切片、map/slice2.jpg" alt="slice2"></p>
<p><em>string底层由两部分组成，指向一个字节数组的指针</em>[4]byte和长度len<br>字节数组中真正存放串的内容</p>
<p>3、string是不可变的，即不能通过str[0]=’z’的方式来修改字符(编译会报错)</p>
<p>4、如果需要修改字符串，可以先将string-&gt;[]byte（或者 []rune）-&gt;修改-&gt;重写转成string<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    str := <span class="string">"hello world"</span></span><br><span class="line">   <span class="comment">//把‘w’改成h</span></span><br><span class="line">   <span class="comment">//首先转成byte切片，可以处理英文和数字，中文用[]rune</span></span><br><span class="line">   <span class="comment">//因为[]byte按字节来处理，而一个汉字占3个字节，因此会出现乱码，[]rune按字符处理，兼容汉字</span></span><br><span class="line">   slice := []<span class="keyword">byte</span>(str)</span><br><span class="line">   slice[<span class="number">6</span>]=<span class="string">'h'</span></span><br><span class="line">   str = <span class="keyword">string</span>(slice)</span><br><span class="line">   fmt.Println(slice)<span class="comment">//输出hello horld</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 4、映射map</span></span><br><span class="line"><span class="string">1、map是key-value数据结构，又称为字段或者关联数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2、声明基本语法</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line">    <span class="keyword">var</span> myMap <span class="keyword">map</span>[keyType]valueType</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* key可以是很多种类型，如：bool，int系列、string、指针、channel，还可以是只包含前面几个类型的接口、结构体、数组，**通常为int、string**</span></span><br><span class="line"><span class="string">* **key不可以是slice、map、function**，因为这几个不能用“==”判断（key通常需要判断key存不存在）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* value的类型通常是string、map、struct</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* key不可重复，value可重复，**key**是**无序的**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* **声明不会分配内存**，初始化需要make分配内存后才能赋值和使用 </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//声明，还未分配内存</span></span><br><span class="line"></span><br><span class="line">a[<span class="string">"no1"</span>]=<span class="string">"宋江"</span>  <span class="comment">//这里会panic恐慌，给一个空map赋值，会报错</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure></p>
<p>使用map前需要先make，给map分配空间，和数组不一样，数组声明后会默认初始化为零值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//声明，还未分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用map前需要先make，给map分配空间，和数组不一样，数组声明后会默认初始化为零值</span></span><br><span class="line">a=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">10</span>)<span class="comment">//分配10个空间，不写默认为1</span></span><br><span class="line">a[<span class="string">"no1"</span>]=<span class="string">"宋江"</span></span><br><span class="line">a[<span class="string">"no2"</span>]=<span class="string">"吴用"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a)        <span class="comment">//输出 map 【no1:宋江 no2:吴用】</span></span><br></pre></td></tr></table></figure></p>
<h4 id="1、map的使用方式"><a href="#1、map的使用方式" class="headerlink" title="1、map的使用方式"></a>1、map的使用方式</h4><h5 id="1、声明-gt-make-gt-赋值"><a href="#1、声明-gt-make-gt-赋值" class="headerlink" title="1、声明-&gt;make-&gt;赋值"></a>1、声明-&gt;make-&gt;赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//声明，还未分配内存，这时map==nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用map前需要先make，给map分配空间，和数组不一样，数组声明后会默认初始化为零值</span></span><br><span class="line">a=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">10</span>)<span class="comment">//分配10个空间，不写默认为1</span></span><br><span class="line">a[<span class="string">"no1"</span>]=<span class="string">"宋江"</span></span><br><span class="line">a[<span class="string">"no2"</span>]=<span class="string">"吴用"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a)        <span class="comment">//输出 map 【no1:宋江 no2:吴用】</span></span><br></pre></td></tr></table></figure>
<h5 id="2、声明同时make-gt-赋值"><a href="#2、声明同时make-gt-赋值" class="headerlink" title="2、声明同时make-&gt;赋值"></a>2、声明同时make-&gt;赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">city[<span class="string">"no1"</span>]=<span class="string">"北京"</span></span><br><span class="line">city[<span class="string">"no2"</span>]=<span class="string">"上海"</span></span><br><span class="line">city[<span class="string">"no3"</span>]=<span class="string">"武汉"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(city)        <span class="comment">//输出 map 【no1:北京 no2:上海 no3:武汉】</span></span><br></pre></td></tr></table></figure>
<h5 id="3、声明时直接赋值"><a href="#3、声明时直接赋值" class="headerlink" title="3、声明时直接赋值"></a>3、声明时直接赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(city)        <span class="comment">//输出 map 【no1:北京 no2:上海 no3:武汉】</span></span><br></pre></td></tr></table></figure>
<h4 id="2、map的增删改查（crud）操作"><a href="#2、map的增删改查（crud）操作" class="headerlink" title="2、map的增删改查（crud）操作"></a>2、map的增删改查（crud）操作</h4><h5 id="1、增加和更新"><a href="#1、增加和更新" class="headerlink" title="1、增加和更新"></a>1、增加和更新</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="string">"key"</span>] = value</span><br><span class="line"><span class="comment">//1、如果key之前不存在，就是增加操作</span></span><br><span class="line"><span class="comment">//2、如果key之前存在，就是修改操作，新值覆盖旧值</span></span><br></pre></td></tr></table></figure>
<h5 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>,<span class="string">"key"</span>)</span><br></pre></td></tr></table></figure>
<p>1、delete是一个内置函数，如果key存在就删除该key-value，如果不存在，不操作，也不会报错<br>2、如果map为nil也不操作，不报错<br>3、如果我们要删除map所有的key，只能遍历逐个删除，不能一次全删除。或者map = make(map[keyType]valueType)，make一个新的，让原来的成为垃圾，被GC回收</p>
<h5 id="3、查找"><a href="#3、查找" class="headerlink" title="3、查找"></a>3、查找</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">val,ok := city[<span class="string">"no1"</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"有key:no1，值为：%v"</span>，val)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     fmt.Println(<span class="string">"没有key:no1"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、map的遍历"><a href="#3、map的遍历" class="headerlink" title="3、map的遍历"></a>3、map的遍历</h4><p>map遍历只能通过for-range，不能用普通for循环，因为map没有下标，key是无序的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> city &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"k=%v v=%v \n"</span>，k,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4、map的长度"><a href="#4、map的长度" class="headerlink" title="4、map的长度"></a>4、map的长度</h4><p>len(map)，统计map中有几对key-value<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">city := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    “no1”：<span class="string">"北京"</span>，</span><br><span class="line">    “no2”：<span class="string">"上海"</span>，</span><br><span class="line">    “no3”：<span class="string">"武汉"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"city 有"</span>，<span class="built_in">len</span>（city），“对key-value”)</span><br></pre></td></tr></table></figure></p>
<h4 id="5、map切片"><a href="#5、map切片" class="headerlink" title="5、map切片"></a>5、map切片</h4><p>切片的数据类型如果是map，则成为<strong>map切片</strong>，这样<strong>map的个数可以动态变化</strong>，map切片是一种切片，切片的每个元素都是一个map.<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个map切片</span></span><br><span class="line"><span class="keyword">var</span> monsters []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片make后才能使用</span></span><br><span class="line">monsters = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)<span class="comment">//len=2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> monsters[<span class="number">0</span>] == <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="comment">//切片的元素是map，map需要先make再使用</span></span><br><span class="line">    monsters[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)<span class="comment">//map有两个key</span></span><br><span class="line">    monsters[<span class="number">0</span>][<span class="string">"name"</span>] = <span class="string">"牛魔王"</span></span><br><span class="line">    monsters[<span class="number">0</span>][<span class="string">"age"</span>] = “<span class="number">500</span>”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> monsters[<span class="number">1</span>] == <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="comment">//切片的元素是map，map需要先make再使用</span></span><br><span class="line">    monsters[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">2</span>)<span class="comment">//map有两个key</span></span><br><span class="line">    monsters[<span class="number">1</span>][<span class="string">"name"</span>] = <span class="string">"玉兔精"</span></span><br><span class="line">    monsters[<span class="number">1</span>][<span class="string">"age"</span>] = “<span class="number">400</span>”</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为一开始定义切片长度为2，如果还要添加元素，用append函数动态增加</span></span><br><span class="line"><span class="comment">//1、定义一个monster信息</span></span><br><span class="line">newMonster := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"name"</span> = <span class="string">"新妖怪：红孩儿"</span>,</span><br><span class="line">    <span class="string">"age"</span> = <span class="string">"200"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、添加到切片中</span></span><br><span class="line">monsters = <span class="built_in">append</span>(monsters,newMonster)</span><br><span class="line"></span><br><span class="line"> fmt.Println(monsters)</span><br></pre></td></tr></table></figure></p>
<h4 id="6、map排序"><a href="#6、map排序" class="headerlink" title="6、map排序"></a>6、map排序</h4><p>1、GO中没有专门的map排序方法<br>2、map默认是无序的，也不是按照添加顺序存放，每次遍历的输出结果也不一样<br>3、对map排序，可以先将key排序，再根据key值遍历输出<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">map1[<span class="number">10</span>]=<span class="number">130</span></span><br><span class="line">map1[<span class="number">1</span>]=<span class="number">13</span></span><br><span class="line">map1[<span class="number">4</span>]=<span class="number">56</span></span><br><span class="line">map1[<span class="number">8</span>]=<span class="number">90</span></span><br><span class="line">    </span><br><span class="line">fmt.Println(map1)<span class="comment">//这里每次的输出结果顺序可能不一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="comment">//1、先将map的key放到切片中</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> map1&#123;</span><br><span class="line">    keys = <span class="built_in">append</span>(keys,k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、对切片排序</span></span><br><span class="line">sort.Ints(keys)</span><br><span class="line">fmt.Println(keys)<span class="comment">//key递增输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历切片，根据key值遍历输出值</span></span><br><span class="line"><span class="keyword">for</span> _,k  := <span class="keyword">range</span> keys&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"map1[%v]=%v \n"</span>,k,map1[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7、map使用细节"><a href="#7、map使用细节" class="headerlink" title="7、map使用细节"></a>7、map使用细节</h4><p>1、map是引用类型，遵守引用传递机制。<br>2、map容量到达后，想再增加元素，会自动扩容，不会panic，slice会panic<br>3、map的value也经常使用struct类型</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/go-错误处理机制、数组、切片、map/" data-id="ckgqazm2z0022zsvieddqp09q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/11/go-结构体、方法、工厂模式、OOP三大特性、类型断言、接口/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          go:结构体、方法、工厂模式、OOP三大特性、类型断言、接口
        
      </div>
    </a>
  
  
    <a href="/2020/06/11/go-函数/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">go:函数</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/25/微服务：2-1-1-服务注册与发现-Eureka/">微服务：2-1-1 服务注册与发现-Eureka</a>
          </li>
        
          <li>
            <a href="/2020/10/25/微服务：1、入门/">微服务：1、入门</a>
          </li>
        
          <li>
            <a href="/2020/08/12/GO：2-9-Go语句及其执行规则/">GO：2.9 Go语句及其执行规则</a>
          </li>
        
          <li>
            <a href="/2020/08/10/GO：2-8-关于指针的有限操作/">GO：2-8 关于指针的有限操作</a>
          </li>
        
          <li>
            <a href="/2020/07/22/GO：2-7-接口类型的合理运用/">GO：2.7 接口类型的合理运用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>